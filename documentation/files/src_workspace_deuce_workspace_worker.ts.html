<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/workspace/deuce_workspace_worker.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.17</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/parserlib.css.Combinator.html">parserlib.css.Combinator</a></li>
                                <li><a href="../classes/parserlib.css.MediaFeature.html">parserlib.css.MediaFeature</a></li>
                                <li><a href="../classes/parserlib.css.MediaQuery.html">parserlib.css.MediaQuery</a></li>
                                <li><a href="../classes/parserlib.css.Parser.html">parserlib.css.Parser</a></li>
                                <li><a href="../classes/parserlib.css.PropertyName.html">parserlib.css.PropertyName</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValue.html">parserlib.css.PropertyValue</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValueIterator.html">parserlib.css.PropertyValueIterator</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValuePart.html">parserlib.css.PropertyValuePart</a></li>
                                <li><a href="../classes/parserlib.css.Selector.html">parserlib.css.Selector</a></li>
                                <li><a href="../classes/parserlib.css.SelectorPart.html">parserlib.css.SelectorPart</a></li>
                                <li><a href="../classes/parserlib.css.SelectorSubPart.html">parserlib.css.SelectorSubPart</a></li>
                                <li><a href="../classes/parserlib.css.Specificity.html">parserlib.css.Specificity</a></li>
                                <li><a href="../classes/parserlib.css.TokenStream.html">parserlib.css.TokenStream</a></li>
                                <li><a href="../classes/parserlib.css.TokenStreamBase.html">parserlib.css.TokenStreamBase</a></li>
                                <li><a href="../classes/parserlib.util.Anchor.html">parserlib.util.Anchor</a></li>
                                <li><a href="../classes/parserlib.util.BackgroundTokenizer.html">parserlib.util.BackgroundTokenizer</a></li>
                                <li><a href="../classes/parserlib.util.CSSLint.html">parserlib.util.CSSLint</a></li>
                                <li><a href="../classes/parserlib.util.Editor.html">parserlib.util.Editor</a></li>
                                <li><a href="../classes/parserlib.util.EditorDocument.html">parserlib.util.EditorDocument</a></li>
                                <li><a href="../classes/parserlib.util.EditSession.html">parserlib.util.EditSession</a></li>
                                <li><a href="../classes/parserlib.util.EventTarget.html">parserlib.util.EventTarget</a></li>
                                <li><a href="../classes/parserlib.util.Fold.html">parserlib.util.Fold</a></li>
                                <li><a href="../classes/parserlib.util.FoldLine.html">parserlib.util.FoldLine</a></li>
                                <li><a href="../classes/parserlib.util.GutterTooltip.html">parserlib.util.GutterTooltip</a></li>
                                <li><a href="../classes/parserlib.util.HScrollBar.html">parserlib.util.HScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.HtmlMode.html">parserlib.util.HtmlMode</a></li>
                                <li><a href="../classes/parserlib.util.Mode.html">parserlib.util.Mode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/parserlib.util.Position.html">parserlib.util.Position</a></li>
                                <li><a href="../classes/parserlib.util.Range.html">parserlib.util.Range</a></li>
                                <li><a href="../classes/parserlib.util.Reporter.html">parserlib.util.Reporter</a></li>
                                <li><a href="../classes/parserlib.util.ScrollBar.html">parserlib.util.ScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.Search.html">parserlib.util.Search</a></li>
                                <li><a href="../classes/parserlib.util.Selection.html">parserlib.util.Selection</a></li>
                                <li><a href="../classes/parserlib.util.StringReader.html">parserlib.util.StringReader</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxError.html">parserlib.util.SyntaxError</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxUnit.html">parserlib.util.SyntaxUnit</a></li>
                                <li><a href="../classes/parserlib.util.TokenIterator.html">parserlib.util.TokenIterator</a></li>
                                <li><a href="../classes/parserlib.util.Tokenizer.html">parserlib.util.Tokenizer</a></li>
                                <li><a href="../classes/parserlib.util.Tooltip.html">parserlib.util.Tooltip</a></li>
                                <li><a href="../classes/parserlib.util.TypeScriptWorker.html">parserlib.util.TypeScriptWorker</a></li>
                                <li><a href="../classes/parserlib.util.UndoManager.html">parserlib.util.UndoManager</a></li>
                                <li><a href="../classes/parserlib.util.ValidationError.html">parserlib.util.ValidationError</a></li>
                                <li><a href="../classes/parserlib.util.VirtualRenderer.html">parserlib.util.VirtualRenderer</a></li>
                                <li><a href="../classes/parserlib.util.VScrollBar.html">parserlib.util.VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/workspace/deuce_workspace_worker.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/// &lt;reference path=&quot;../../typings/typescriptServices.d.ts&quot;/&gt;
/**
 * WorkspaceWorker
 */
import protocol = require(&#x27;./workspace_protocol&#x27;);

var TypeScript = require(&#x27;./typescriptServices&#x27;).TypeScript;

var Services = TypeScript.Services;
var TypeScriptServicesFactory = Services.TypeScriptServicesFactory;

var LineMap1 = TypeScript.LineMap1;
var ScriptSnapshot = TypeScript.ScriptSnapshot;
var TextChangeRange = TypeScript.TextChangeRange;
var TextSpan = TypeScript.TextSpan;

class ScriptInfo {
    fileName: string;
    content: string;
    version: number;
    editRanges: { length: number; textChangeRange: TypeScript.TextChangeRange }[];
    lineMap;
    constructor(fileName: string, content: string) {
        this.fileName = fileName;
        this.version = 1;
        this.editRanges = [];
        this.setContent(content);
    }

    setContent(content: string): void {
        this.content = content;
        this.lineMap = null;
    }

    getLineMap = function() {
        if (!this.lineMap) {
            this.lineMap = LineMap1.fromString(this.content);
        }
        return this.lineMap;
    }

    updateContent(content: string) {
        this.editRanges = [];
        this.setContent(content);
        this.version++;
    }

    editContent(minChar: number, limChar: number, newText: string) {
        // Apply edits
        var prefix: string = this.content.substring(0, minChar);
        var middle: string = newText;
        var suffix: string = this.content.substring(limChar);
        this.setContent(prefix + middle + suffix);

        // Store edit range and the length of the script.
        var length: number = this.content.length;
        var range = new TextChangeRange(TextSpan.fromBounds(minChar, limChar), newText.length);

        this.editRanges.push({ &#x27;length&#x27;: length, &#x27;textChangeRange&#x27;: range });

        // Bump the version.
        this.version++;
    }

    getTextChangeRangeSinceVersion(version) {
        if (this.version === version) {
            // No edits.
            return TextChangeRange.unchanged;
        }

        var initialEditRangeIndex = this.editRanges.length - (this.version - version);

        var entries = this.editRanges.slice(initialEditRangeIndex);

        return TextChangeRange.collapseChangesAcrossMultipleVersions(entries.map(function(e) {
            return e.textChangeRange;
        }));
    }
}

class ScriptCache implements TypeScript.Services.ILanguageServiceHost {
    compilationSettings;
    scripts: { [fileName: string]: ScriptInfo };
    maxScriptVersions: number;
    constructor() {
        this.compilationSettings = null;
        this.scripts = {};
        this.maxScriptVersions = 100;
    }

    getScriptFileNames() {
        return Object.keys(this.scripts);
    }

    getFileNames(callback) {
        callback(Object.keys(this.scripts));
    }

    getScriptIsOpen(fileName) {
        return true;
    }

    getScriptByteOrderMark(fileName) {
        return null;
    }

    getLocalizedDiagnosticMessages() {
        return &quot;&quot;;
    }

    ///////////////////////////////////////////////////////////////////////
    // IReferenceResolveHost implementation

    fileExists(path) {
        return true;
    }

    directoryExists(path) {
        return true;
    }

    getParentDirectory(path) {
        return &quot;&quot;;
    }

    resolveRelativePath(path, directory) {
        return &quot;&quot;;
    }

    getScriptSnapshot(fileName) {
        var script = this.scripts[fileName];
        var result = ScriptSnapshot.fromString(script.content);

        // Quick hack: We don&#x27;t want this to blow up.
        /*
        Uncaught Error: Not yet implemented. typescriptServices.js:1267
        Errors.notYetImplemented typescriptServices.js:1267
        StringScriptSnapshot.getTextChangeRangeSinceVersion typescriptServices.js:4138
        HostCache.getScriptTextChangeRangeSinceVersion typescriptServices.js:64510
        LanguageServiceCompiler.tryUpdateFile typescriptServices.js:64675
        LanguageServiceCompiler.synchronizeHostDataWorker typescriptServices.js:64657
        (anonymous function) typescriptServices.js:64627
        timeFunction typescriptServices.js:27531
        LanguageServiceCompiler.synchronizeHostData typescriptServices.js:64626
        LanguageServiceCompiler.getDocument typescriptServices.js:64717
        LanguageService.getSymbolInfoAtPosition typescriptServices.js:65423
        LanguageService.getOccurrencesAtPosition typescriptServices.js:65510
        showOccurrences main.js:150
        callback
        */
        result[&quot;getTextChangeRangeSinceVersion&quot;] = function(version) {
            return null;
            // return new TextChangeRange(new TextSpan(0, script.content.length),script.content.length);
        };

        return result;
    }

    ///////////////////////////////////////////////////////////////////////
    // local implementation

    private addScript(fileName: string, content: string) {
        var script = new ScriptInfo(fileName, content);
        this.scripts[fileName] = script;
    }

    ensureScript(fileName, content) {
        var script = this.scripts[fileName];
        if (script) {
            script.updateContent(content);
        }
        else {
            this.addScript(fileName, content);
        }
    }

    editScript(fileName, minChar, limChar, newText) {
        var script = this.scripts[fileName];
        if (script) {
            script.editContent(minChar, limChar, newText);
        }
        else {
            throw new Error(&quot;No script with fileName &#x27;&quot; + fileName + &quot;&#x27;&quot;);
        }
    }

    removeScript(fileName) {
        var script = this.scripts[fileName];
        if (script) {
            delete this.scripts[fileName];
        }
        else {
            throw new Error(&quot;No script with fileName &#x27;&quot; + fileName + &quot;&#x27;&quot;);
        }
    }

    ///////////////////////////////////////////////////////////////////////
    // ILogger implementation

    information() {
        return false;
    }

    debug() {
        return false;
    }

    warning() {
        return false;
    }

    error() {
        return false;
    }

    fatal() {
        return false;
    }

    log(s) {

    }

    getDiagnosticsObject() {
        var diagnostics =
            {
                log: function(content) { }
            };
        return diagnostics;
    }

    ///////////////////////////////////////////////////////////////////////
    // ILanguageServiceHost implementation

    getCompilationSettings() {
        return this.compilationSettings;
    }

    setCompilationSettings(value) {
        this.compilationSettings = value;
    }

    getScriptVersion(fileName) {
        var script = this.scripts[fileName];
        return script.version;
    }

    /**
     * Apply an array of text edits to a string, and return the resulting string.
     */
    applyEdits(content, edits) {
        var result = content;
        edits = this.normalizeEdits(edits);

        for (var i = edits.length - 1; i &gt;= 0; i--) {
            var edit = edits[i];
            var prefix = result.substring(0, edit.minChar);
            var middle = edit.text;
            var suffix = result.substring(edit.limChar);
            result = prefix + middle + suffix;
        }
        return result;
    }

    /**
     * Normalize an array of edits by removing overlapping entries and sorting
     * entries on the &quot;minChar&quot; position.
     */
    normalizeEdits(edits) {
        var result = [];

        function mapEdits(edits) {
            var result = [];
            for (var i = 0; i &lt; edits.length; i++) {
                result.push({ &#x27;edit&#x27;: edits[i], &#x27;index&#x27;: i });
            }
            return result;
        }

        var temp = mapEdits(edits).sort(function(a, b) {
            var result = a.edit.minChar - b.edit.minChar;
            if (result === 0) {
                result = a.index - b.index;
            }
            return result;
        });

        var current = 0;
        var next = 1;
        while (current &lt; temp.length) {
            var currentEdit = temp[current].edit;

            // Last edit.
            if (next &gt;= temp.length) {
                result.push(currentEdit);
                current++;
                continue;
            }
            var nextEdit = temp[next].edit;

            var gap = nextEdit.minChar - currentEdit.limChar;

            // non-overlapping edits.
            if (gap &gt;= 0) {
                result.push(currentEdit);
                current = next;
                next++;
                continue;
            }

            // overlapping edits: for now, we only support ignoring an next edit
            // entirely contained in the current edit.
            if (currentEdit.limChar &gt;= nextEdit.limChar) {
                next++;
                continue;
            }
            else {
                throw new Error(&quot;Trying to apply overlapping edits&quot;);
            }
        }
        return result;
    }
}

/**
 * WorkspaceWorker is responsible for maintaining the language service host and language service. 
 */
export class WorkspaceWorker {

    private scriptCache = new ScriptCache();
    private ls: TypeScript.Services.ILanguageService = new TypeScriptServicesFactory().createPullLanguageService(this.scriptCache);

    constructor(sender/*FIXME: ace.WorkerSender*/) {

        var self = this;

        sender.on(&#x27;ensureScript&#x27;, function(message: { data: { fileName: string; content: string } }) {
            // This call, in turn will add the library to the lsHost.
            self.ensureScript(message.data.fileName, message.data.content);
        });

        sender.on(&#x27;editScript&#x27;, function(message: { data: { fileName: string; start: number; end: number; text: string } }) {
            var data = message.data;
            var fileName = data.fileName;
            var start = data.start;
            var end = data.end;
            var text = data.text;
            self.editScript(fileName, start, end, text);
        });

        sender.on(&#x27;removeScript&#x27;, function(message: { data: { fileName: string; content: string } }) {
            self.removeScript(message.data.fileName);
        });

        sender.on(&#x27;getFileNames&#x27;, function(request: { data: { callbackId: number } }) {
            var data = request.data;
            var callbackId: number = data.callbackId;
            var names = self.scriptCache.getScriptFileNames();
            var response = { names: names, callbackId: callbackId };
            sender.emit(&quot;fileNames&quot;, response);
        });

        sender.on(&#x27;getSyntaxErrors&#x27;, function(request: { data: { fileName: string; callbackId: number } }) {
            var data = request.data;
            var fileName: string = data.fileName;
            var callbackId: number = data.callbackId;
            var errors = self.ls.getSyntacticDiagnostics(fileName).map((error) =&gt; { return { message: error.message(), start: error.start(), length: error.length() }; });
            var response = { errors: errors, callbackId: callbackId };
            sender.emit(&quot;syntaxErrors&quot;, response);
        });

        sender.on(&#x27;getSemanticErrors&#x27;, function(request: { data: { fileName: string; callbackId: number } }) {
            var data = request.data;
            var fileName: string = data.fileName;
            var callbackId: number = data.callbackId;
            try {
                var errors = self.ls.getSemanticDiagnostics(fileName).map((error) =&gt; { return { message: error.message(), start: error.start(), length: error.length() }; });
                var response = { errors: errors, callbackId: callbackId };
                sender.emit(&quot;semanticErrors&quot;, response);
            }
            catch (e) {
            }
        });

        sender.on(&#x27;getCompletionsAtPosition&#x27;, function(request: { data: { fileName: string; position: number; memberMode: boolean; callbackId: number } }) {
            try {
                var data = request.data;
                var fileName: string = data.fileName;
                var position: number = data.position;
                var memberMode: boolean = data.memberMode;
                var callbackId: number = data.callbackId;
                if (typeof position !== &#x27;number&#x27; || isNaN(position)) {
                    throw new Error(&quot;position must be a number and not NaN&quot;);
                }
                var completions = self.ls.getCompletionsAtPosition(fileName, position, memberMode);
                sender.emit(protocol.EVENT_NAME_COMPLETIONS, { completions: completions, callbackId: callbackId });
            }
            catch (e) {
                // e parameter cannot have a type annotation so we really have to do some introspection.
                // FIXME: It would be nice to ensure a {name, message} structure.
                sender.emit(protocol.EVENT_NAME_COMPLETIONS, { err: e.toString(), callbackId: callbackId });
            }
        });

        sender.on(&#x27;getTypeAtDocumentPosition&#x27;, function(request: { data: { fileName: string; documentPosition: { row: number; column: number }; callbackId: number } }) {
            try {
                var data = request.data;
                var fileName: string = data.fileName;
                var documentPosition: { row: number; column: number } = data.documentPosition;
                var callbackId: number = data.callbackId;
                var script: ScriptInfo = self.scriptCache.scripts[fileName];
                var row = documentPosition.row;
                var column = documentPosition.column;
                var position = script.getLineMap().getPosition(row, column);
                var typeInfo: TypeScript.Services.TypeInfo = self.ls.getTypeAtPosition(fileName, position);
                if (typeInfo) {
                    /**
                     * The type information from the source.
                     */
                    var description = null;
                    var memberName = typeInfo.memberName;
                    if (memberName) {
                        // TODO: This API call has several options. Maybe need to query?
                        description = TypeScript.MemberName.memberNameToString(memberName);
                    }
                    var kind = typeInfo.kind;
                    var minChar = typeInfo.minChar;
                    var limChar = typeInfo.limChar;
                    /**
                     * The JS documentation comments with &#x60;@param&#x60; parsed out.
                     */
                    var docComment = typeInfo.docComment;
                    var fullSymbolName = typeInfo.fullSymbolName;

                    var results = { kind: kind, minChar: minChar, limChar: limChar, description: description, docComment: docComment, fullSymbolName: fullSymbolName };
                    var response = { results: results, callbackId: callbackId };
                    sender.emit(&quot;typeAtDocumentPosition&quot;, response);
                }
                else {
                    // We should call back, if only to allow the receiver to cleanup quickly.
                    sender.emit(&quot;typeAtDocumentPosition&quot;, { callbackId: callbackId });
                }
            }
            catch (e) {
                sender.emit(&quot;typeAtDocumentPosition&quot;, { err: &quot;&quot; + e, callbackId: callbackId });
            }
        });

        sender.on(&#x27;getOutputFiles&#x27;, function(request: { data: { fileName: string; callbackId: number } }) {
            var data = request.data;
            var fileName: string = data.fileName;
            var callbackId: number = data.callbackId;
            try {
                var emitOutput: TypeScript.EmitOutput = self.ls.getEmitOutput(fileName);
                var outputFiles: TypeScript.OutputFile[] = emitOutput.outputFiles;
                var response = { results: outputFiles, callbackId: callbackId };
                sender.emit(&quot;outputFiles&quot;, response);
            }
            catch (e) {
            }
        });

        sender.emit(&#x27;initAfter&#x27;);
    }

    private ensureScript(fileName: string, content: string): void {
        this.scriptCache.ensureScript(fileName, content);
    }

    private editScript(fileName: string, start: number, end: number, text: string): void {
        this.scriptCache.editScript(fileName, start, end, text);
    }

    private removeScript(fileName: string): void {
        this.scriptCache.removeScript(fileName);
    }
}
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
