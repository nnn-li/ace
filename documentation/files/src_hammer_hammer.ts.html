<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/hammer/hammer.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.17</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/parserlib.css.Combinator.html">parserlib.css.Combinator</a></li>
                                <li><a href="../classes/parserlib.css.MediaFeature.html">parserlib.css.MediaFeature</a></li>
                                <li><a href="../classes/parserlib.css.MediaQuery.html">parserlib.css.MediaQuery</a></li>
                                <li><a href="../classes/parserlib.css.Parser.html">parserlib.css.Parser</a></li>
                                <li><a href="../classes/parserlib.css.PropertyName.html">parserlib.css.PropertyName</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValue.html">parserlib.css.PropertyValue</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValueIterator.html">parserlib.css.PropertyValueIterator</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValuePart.html">parserlib.css.PropertyValuePart</a></li>
                                <li><a href="../classes/parserlib.css.Selector.html">parserlib.css.Selector</a></li>
                                <li><a href="../classes/parserlib.css.SelectorPart.html">parserlib.css.SelectorPart</a></li>
                                <li><a href="../classes/parserlib.css.SelectorSubPart.html">parserlib.css.SelectorSubPart</a></li>
                                <li><a href="../classes/parserlib.css.Specificity.html">parserlib.css.Specificity</a></li>
                                <li><a href="../classes/parserlib.css.TokenStream.html">parserlib.css.TokenStream</a></li>
                                <li><a href="../classes/parserlib.css.TokenStreamBase.html">parserlib.css.TokenStreamBase</a></li>
                                <li><a href="../classes/parserlib.util.Anchor.html">parserlib.util.Anchor</a></li>
                                <li><a href="../classes/parserlib.util.BackgroundTokenizer.html">parserlib.util.BackgroundTokenizer</a></li>
                                <li><a href="../classes/parserlib.util.CSSLint.html">parserlib.util.CSSLint</a></li>
                                <li><a href="../classes/parserlib.util.Editor.html">parserlib.util.Editor</a></li>
                                <li><a href="../classes/parserlib.util.EditorDocument.html">parserlib.util.EditorDocument</a></li>
                                <li><a href="../classes/parserlib.util.EditSession.html">parserlib.util.EditSession</a></li>
                                <li><a href="../classes/parserlib.util.EventTarget.html">parserlib.util.EventTarget</a></li>
                                <li><a href="../classes/parserlib.util.Fold.html">parserlib.util.Fold</a></li>
                                <li><a href="../classes/parserlib.util.FoldLine.html">parserlib.util.FoldLine</a></li>
                                <li><a href="../classes/parserlib.util.GutterTooltip.html">parserlib.util.GutterTooltip</a></li>
                                <li><a href="../classes/parserlib.util.HScrollBar.html">parserlib.util.HScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.HtmlMode.html">parserlib.util.HtmlMode</a></li>
                                <li><a href="../classes/parserlib.util.Mode.html">parserlib.util.Mode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/parserlib.util.Position.html">parserlib.util.Position</a></li>
                                <li><a href="../classes/parserlib.util.Range.html">parserlib.util.Range</a></li>
                                <li><a href="../classes/parserlib.util.Reporter.html">parserlib.util.Reporter</a></li>
                                <li><a href="../classes/parserlib.util.ScrollBar.html">parserlib.util.ScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.Search.html">parserlib.util.Search</a></li>
                                <li><a href="../classes/parserlib.util.Selection.html">parserlib.util.Selection</a></li>
                                <li><a href="../classes/parserlib.util.StringReader.html">parserlib.util.StringReader</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxError.html">parserlib.util.SyntaxError</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxUnit.html">parserlib.util.SyntaxUnit</a></li>
                                <li><a href="../classes/parserlib.util.TokenIterator.html">parserlib.util.TokenIterator</a></li>
                                <li><a href="../classes/parserlib.util.Tokenizer.html">parserlib.util.Tokenizer</a></li>
                                <li><a href="../classes/parserlib.util.Tooltip.html">parserlib.util.Tooltip</a></li>
                                <li><a href="../classes/parserlib.util.TypeScriptWorker.html">parserlib.util.TypeScriptWorker</a></li>
                                <li><a href="../classes/parserlib.util.UndoManager.html">parserlib.util.UndoManager</a></li>
                                <li><a href="../classes/parserlib.util.ValidationError.html">parserlib.util.ValidationError</a></li>
                                <li><a href="../classes/parserlib.util.VirtualRenderer.html">parserlib.util.VirtualRenderer</a></li>
                                <li><a href="../classes/parserlib.util.VScrollBar.html">parserlib.util.VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/hammer/hammer.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { addEventListeners, each, getWindowForElement, hasParent, inArray, inStr, prefixed, removeEventListeners, splitStr, TEST_ELEMENT, toArray, uniqueArray, uniqueId } from &#x27;./utils&#x27;;

export interface Touch {
    clientX: number;
    clientY: number;
    pageX: number;
    pageY: number;
}

export interface TouchEvent extends Event {
    type: string;
    touches: Touch[];
    changedTouches: Touch[];
}

// magical touchAction value
export var TOUCH_ACTION_COMPUTE = &#x27;compute&#x27;;
export var TOUCH_ACTION_AUTO = &#x27;auto&#x27;;
export var TOUCH_ACTION_MANIPULATION = &#x27;manipulation&#x27;; // not implemented
export var TOUCH_ACTION_NONE = &#x27;none&#x27;;
export var TOUCH_ACTION_PAN_X = &#x27;pan-x&#x27;;
export var TOUCH_ACTION_PAN_Y = &#x27;pan-y&#x27;;

var STOP = 1;
var FORCED_STOP = 2;

export class VectorE2 {
    public x;
    public y;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
    add(other: VectorE2): VectorE2 {
        return new VectorE2(this.x + other.x, this.y + other.y);
    }
    sub(other: VectorE2): VectorE2 {
        return new VectorE2(this.x - other.x, this.y - other.y);
    }
    div(other: number): VectorE2 {
        return new VectorE2(this.x / other, this.y / other);
    }
    dot(other: VectorE2): number {
        return this.x * other.x + this.y * other.y;
    }
    norm(): number {
        return Math.sqrt(this.quadrance());
    }
    quadrance(): number {
        return this.x * this.x + this.y * this.y;
    }
    toString(): string {
        return &#x27;VectorE2(&#x27; + this.x + &#x27;, &#x27; + this.y + &#x27;)&#x27;;
    }
}

export class ClientLocation {
    public clientX;
    public clientY;
    constructor(clientX: number, clientY: number) {
        this.clientX = clientX;
        this.clientY = clientY;
    }
    moveTo(clientX: number, clientY: number) {
        this.clientX = clientX;
        this.clientY = clientY;
    }
    sub(other: ClientLocation): VectorE2 {
        return new VectorE2(this.clientX - other.clientX, this.clientY - other.clientY);
    }
    static fromTouch(touch: { clientX: number; clientY: number }) {
        return new ClientLocation(touch.clientX, touch.clientY);
    }
    toString(): string {
        return &#x27;ClientLocation(&#x27; + this.clientX + &#x27;, &#x27; + this.clientY + &#x27;)&#x27;;
    }
}

export interface IComputedEvent {
    eventType: number;
    touchesLength: number;
    timeStamp: number;
    center: ClientLocation;
    rotation: number;
    deltaTime: number;
    distance: number;
    movement: VectorE2;
    direction: number;
    scale: number;
    velocity: VectorE2;
}

/**
 * Maintains the history of events for a gesture recognition.
 */
export class Session {
    public startTime: number;
    public stopped: number;
    public curRecognizer: IRecognizer;
    private compEvents: IComputedEvent[] = [];
    constructor() {
        this.reset();
    }
    reset(): void {
        this.startTime = Date.now();
        this.compEvents = [];
        this.curRecognizer = undefined;
    }
    push(compEvent: IComputedEvent): void {
        this.compEvents.push(compEvent);
    }
    computeMovement(center: ClientLocation): VectorE2 {
        if (center) {
            if (this.compEvents.length &gt; 0) {
                var prev: IComputedEvent = this.compEvents[this.compEvents.length - 1];
                return center.sub(prev.center);
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }
    computeVelocity(center: ClientLocation, deltaTime: number): VectorE2 {
        if (center) {
            if (this.compEvents.length &gt; 0) {
                var prev: IComputedEvent = this.compEvents[this.compEvents.length - 1];
                return center.sub(prev.center).div(deltaTime - prev.deltaTime);
            }
            else {
                return undefined;
            }
        }
        else {
            return undefined;
        }
    }

}

/**
 * The contract for what the Manager requires from a Recognizer.
 */
export interface IRecognizer {
    eventName: string;
    canRecognizeWith(recognizer: IRecognizer): boolean;
    recognizeWith(recognizer: IRecognizer): IRecognizer;
    requireFailure(recognizer: IRecognizer): IRecognizer;
    recognize(inputData: IComputedEvent): void;
    reset(): void;
    state: number;
    manager: IRecognizerCallback;
    id: number;
}

export interface IRecognizerCallback {
    emit(eventName: string, data?);
    get(eventName: string): IRecognizer;
    updateTouchAction(): void;
}

export class Manager implements IRecognizerCallback {
    public handlers = {};
    public session = new Session();
    public recognizers: IRecognizer[] = [];
    public element;
    public input;
    private touchAction: TouchAction;
    // The following properties are defaults.
    private domEvents = false;
    public enable = true;  // What does this enable?
    public inputTarget;
    private cssProps = {};
    private callback: IRecognizerCallback;
    /**
     * Manager
     * @param {HTMLElement} element
     * @constructor
     */
    constructor(element: HTMLElement) {
        this.element = element;
        this.inputTarget = element; // Why would this be different?
        this.input = new TouchInput(this, inputHandler);
        this.touchAction = new TouchAction(this, TOUCH_ACTION_COMPUTE);
        this.toggleCssProps(true);
    }

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop(force: boolean) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    }

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize(inputData: IComputedEvent, touchEvent: TouchEvent): void {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData, touchEvent);

        var recognizer: IRecognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer&#x27;s state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to &#x60;null&#x60;
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we&#x27;re in a new session
        if (!curRecognizer || (curRecognizer &amp;&amp; curRecognizer.state &amp; STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i &lt; recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven&#x27;t recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the &#x60;recognizeWith()&#x60; method on the recognizer.
            if (session.stopped !== FORCED_STOP &amp;&amp; ( // 1
                !curRecognizer || recognizer == curRecognizer || // 2
                recognizer.canRecognizeWith(curRecognizer))) { // 3

                recognizer.recognize(inputData);
            }
            else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don&#x27;t already have an active recognizer
            if (!curRecognizer &amp;&amp; recognizer.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_RECOGNIZED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    }

    /**
     * get a recognizer by its event name.
     */
    get(eventName: string): IRecognizer {
        var recognizers = this.recognizers;
        for (var i = 0; i &lt; recognizers.length; i++) {
            if (recognizers[i].eventName === eventName) {
                return recognizers[i];
            }
        }
        return null;
    }

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     */
    add(recognizer: IRecognizer): IRecognizer {
        var existing = this.get(recognizer.eventName);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    }

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @return {Manager}
     */
    remove(recognizer: IRecognizer) {
        var recognizers = this.recognizers;
        recognizer = this.get(recognizer.eventName);
        recognizers.splice(inArray(recognizers, recognizer), 1);

        this.touchAction.update();
        return this;
    }

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @return {EventEmitter} this
     */
    on(events: string, handler): Manager {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    }

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @return {EventEmitter} this
     */
    off(events: string, handler): Manager {
        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            }
            else {
                handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    }

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {IComputedEvent} data
     */
    emit(eventName: string, data: Event) {
        // we also want to trigger dom events
        if (this.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[eventName] &amp;&amp; this.handlers[eventName].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        // Make it look like a normal DOM event?
        /*
        data.type = eventName;
        data.preventDefault = function() {
          data.srcEvent.preventDefault();
        };
        */

        var i = 0;
        while (i &lt; handlers.length) {
            handlers[i](data);
            i++;
        }
    }

    updateTouchAction(): void {
        this.touchAction.update();
    }

    /**
     * destroy the manager and unbinds all events
     * it doesn&#x27;t unbind dom events, that is the user own responsibility
     */
    destroy() {
        this.element &amp;&amp; this.toggleCssProps(false);

        this.handlers = {};
        this.session = undefined;
        this.input.destroy();
        this.element = null;
    }

    toggleCssProps(add: boolean) {
        if (!this.element.style) {
            return;
        }
        var element = this.element;
        each(this.cssProps, function(value, name) {
            element.style[prefixed(element.style, name)] = add ? value : &#x27;&#x27;;
        });
    }

    cancelContextMenu(): void {
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent(&#x27;Event&#x27;);
    gestureEvent.initEvent(event, true, true);
    gestureEvent[&#x27;gesture&#x27;] = data;
    data.target.dispatchEvent(gestureEvent);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = (&#x27;ontouchstart&#x27; in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, &#x27;PointerEvent&#x27;) !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH &amp;&amp; MOBILE_REGEX.test(navigator.userAgent);

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, &#x27;touchAction&#x27;);
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

class TouchAction {
    public manager: Manager;
    public actions: string;
    private prevented;
    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    constructor(manager: Manager, value: string) {
        this.manager = manager;
        this.set(value);
    }
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set(value: string) {
        // find out the touch-action by the event handlers
        if (value === TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION &amp;&amp; this.manager.element.style) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    }

    /**
     * just re-set the touchAction value
     */
    update() {
        this.set(TOUCH_ACTION_COMPUTE);
    }

    /**
     * compute the value for the touchAction property based on the recognizer&#x27;s settings
     * @return {String} value
     */
    compute() {
        var actions: string[] = [];
        // FIXME: Make this type-safe automagically
        each(this.manager.recognizers, function(recognizer: Recognizer) {
            if (recognizer.enabled) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(&#x27; &#x27;));
    }

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults(input: IComputedEvent, touchEvent: TouchEvent) {
        // not needed with native support for the touchAction property
        if (NATIVE_TOUCH_ACTION) {
            return;
        }

        // var direction = input.offsetDirection;

        if (this.prevented) {
            touchEvent.preventDefault();
            return;
        }
        /*
        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);

        if (hasNone ||
            (hasPanY &amp;&amp; direction &amp; DIRECTION_HORIZONTAL) ||
            (hasPanX &amp;&amp; direction &amp; DIRECTION_VERTICAL)) {
            return this.preventSrc(touchEvent);
        }
        */
    }

    /**
     * call preventDefault to prevent the browser&#x27;s default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc(srcEvent) {
        this.prevented = true;
        srcEvent.preventDefault();
    }
}

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @return {*}
 */
function cleanTouchActions(actions: string): string {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // pan-x and pan-y can be combined
    if (hasPanX &amp;&amp; hasPanY) {
        return TOUCH_ACTION_PAN_X + &#x27; &#x27; + TOUCH_ACTION_PAN_Y;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

export var INPUT_TYPE_TOUCH = &#x27;touch&#x27;;
export var INPUT_TYPE_PEN = &#x27;pen&#x27;;
export var INPUT_TYPE_MOUSE = &#x27;mouse&#x27;;
export var INPUT_TYPE_KINECT = &#x27;kinect&#x27;;

var COMPUTE_INTERVAL = 25;

export var INPUT_START = 1;
export var INPUT_MOVE = 2;
export var INPUT_END = 4;
export var INPUT_CANCEL = 8;

export function decodeEventType(eventType: number) {
    switch (eventType) {
        case INPUT_START: {
            return &quot;START&quot;;
        }
        case INPUT_MOVE: {
            return &quot;MOVE&quot;;
        }
        case INPUT_END: {
            return &quot;END&quot;;
        }
        case INPUT_CANCEL: {
            return &quot;CANCEL&quot;;
        }
        default: {
            return &quot;eventType=&quot; + eventType;
        }
    }
}

export var DIRECTION_UNDEFINED = 0;
export var DIRECTION_LEFT = 1;
export var DIRECTION_RIGHT = 2;
export var DIRECTION_UP = 4;
export var DIRECTION_DOWN = 8;

export var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
export var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
export var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = [&#x27;x&#x27;, &#x27;y&#x27;];
var PROPS_CLIENT_XY = [&#x27;clientX&#x27;, &#x27;clientY&#x27;];

class Input {
    public manager: Manager;
    public element;
    public target;
    public domHandler;
    private evEl;
    private evTarget;
    private evWin;
    /**
     * create new input type manager
     * @param {Manager} manager
     * @return {Input}
     * @constructor
     */
    constructor(
        manager: Manager,
        touchElementEvents: string,
        touchTargetEvents: string,
        touchWindowEvents: string) {
        var self = this;
        this.manager = manager;
        this.evEl = touchElementEvents;
        this.evTarget = touchTargetEvents;
        this.evWin = touchWindowEvents;
        this.element = manager.element;
        this.target = manager.inputTarget;

        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function(event: TouchEvent) {
            if (manager.enable) {
                self.handler(event);
            }
        };

        this.init();
    }
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler(event: any) { }

    /**
     * bind the events
     */
    init() {
        this.evEl &amp;&amp; addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget &amp;&amp; addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin &amp;&amp; addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }

    /**
     * unbind the events
     */
    destroy() {
        this.evEl &amp;&amp; removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget &amp;&amp; removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin &amp;&amp; removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {Number} eventType
 * @param {IComputedEvent} input
 */
function inputHandler(manager: Manager, eventType: number, touchEvent: TouchEvent) {

    var compEvent: IComputedEvent = computeIComputedEvent(manager, eventType, touchEvent);

    manager.recognize(compEvent, touchEvent);

    manager.session.push(compEvent);
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Manager} manager
 * @param {IComputedEvent} input
 */
function computeIComputedEvent(manager: Manager, eventType: number, touchEvent: TouchEvent): IComputedEvent {
    var touchesLength = touchEvent.touches.length;
    var changedPointersLen = touchEvent.changedTouches.length;
    var isFirst: boolean = (eventType &amp; INPUT_START &amp;&amp; (touchesLength - changedPointersLen === 0));
    var isFinal: boolean = (eventType &amp; (INPUT_END | INPUT_CANCEL) &amp;&amp; (touchesLength - changedPointersLen === 0));

    //var compEvent: any/*IComputedEvent*/ = {};
    //compEvent.isFirst = !!isFirst;
    //compEvent.isFinal = !!isFinal;

    if (isFirst) {
        manager.session.reset();
    }

    // source event is the normalized value of the domEvents
    // like &#x27;touchstart, mouseup, pointerdown&#x27;
    var session = manager.session;
    //  var pointers = input.pointers;
    //  var pointersLength = pointers.length;

    var center: ClientLocation = computeCenter(touchEvent.touches);
    var movement: VectorE2 = session.computeMovement(center);

    // store the first input to calculate the distance and direction
    /*
    if (!session.firstInput) {
      session.firstInput = snapshot(touchEvent, movement);
    }
  
    // to compute scale and rotation we need to store the multiple touches
    if (touchesLength &gt; 1 &amp;&amp; !session.firstMultiple) {
      session.firstMultiple = snapshot(touchEvent, movement);
    }
    else if (touchesLength === 1) {
      session.firstMultiple = undefined;
    }
  
    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
    */

    var timeStamp = Date.now();
    var movementTime = timeStamp - session.startTime;

    //var angle = getAngle(offsetCenter, center);
    var distance: number = movement ? movement.norm() : 0;
    var direction: number = getDirection(movement);

    // var scale = firstMultiple ? getScale(firstMultiple.pointers, touchEvent.touches) : 1;
    // var rotation = firstMultiple ? getRotation(firstMultiple.pointers, touchEvent.touches) : 0;

    var velocity: VectorE2 = session.computeVelocity(center, movementTime);

    // find the correct target
    /*
    var target = manager.element;
    if (hasParent(touchEvent.target, target)) {
        target = input.srcEvent.target;
    }
    */
    //  input.target = target;
    var compEvent: IComputedEvent = {
        center: center,
        movement: movement,
        deltaTime: movementTime,
        direction: direction,
        distance: distance,
        eventType: eventType,
        rotation: 0,
        timeStamp: timeStamp,
        touchesLength: touchEvent.touches.length,
        // type: touchEvent.type,
        scale: 1,
        velocity: velocity
    };
    return compEvent;
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {ClientLocation} center contains &#x60;clientX&#x60; and &#x60;clientY&#x60; properties
 */
function computeCenter(touches: Touch[]): ClientLocation {
    var touchesLength = touches.length;
    if (touchesLength === 1) {
        return ClientLocation.fromTouch(touches[0]);
    }
    else if (touchesLength === 0) {
        return undefined;
    }
    else {
        var x = 0, y = 0, i = 0;
        while (i &lt; touchesLength) {
            x += touches[i].clientX;
            y += touches[i].clientY;
            i++;
        }
        return new ClientLocation(Math.round(x / touchesLength), Math.round(y / touchesLength));
    }
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity &#x60;x&#x60; and &#x60;y&#x60;
 */
function getVelocity(deltaTime: number, x: number, y: number): { x: number; y: number } {
    return { x: x / deltaTime || 0, y: y / deltaTime || 0 };
}

/**
 * get the direction between two points
 * @param {VectorE2} movement
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(movement: VectorE2): number {
    var N = new VectorE2(0, -1);
    var S = new VectorE2(0, +1);
    var E = new VectorE2(+1, 0);
    var W = new VectorE2(-1, 0);
    // Allow combinations of the cardinal directions.
    // A cardinal direction matches if we are within 22.5 degrees either side.
    var cosineThreshold = Math.cos(7 * Math.PI / 16);
    if (movement) {
        var unit = movement.div(movement.norm());
        var direction = DIRECTION_UNDEFINED;
        if (unit.dot(N) &gt; cosineThreshold) {
            direction |= DIRECTION_UP;
        }
        if (unit.dot(S) &gt; cosineThreshold) {
            direction |= DIRECTION_DOWN;
        }
        if (unit.dot(E) &gt; cosineThreshold) {
            direction |= DIRECTION_RIGHT;
        }
        if (unit.dot(W) &gt; cosineThreshold) {
            direction |= DIRECTION_LEFT;
        }
        return direction;
    }
    else {
        return DIRECTION_UNDEFINED;
    }
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
export function getDistance(p1, p2, props?) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props?) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var TOUCH_INPUT_MAP: { [s: string]: number; } = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = &#x27;touchstart touchmove touchend touchcancel&#x27;;

class TouchInput extends Input {
    private targetIds = {};
    private callback: (manager: Manager, type: number, data: TouchEvent) =&gt; void;
    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    constructor(manager: Manager, callback: (manager: Manager, type: number, data: TouchEvent) =&gt; void) {
        // FIXME: The base class registers handlers and could be firing events
        // before this constructor has initialized callback?
        super(manager, undefined, TOUCH_TARGET_EVENTS, undefined);
        this.callback = callback;
    }
    handler(event: TouchEvent) {
        var eventType: number = TOUCH_INPUT_MAP[event.type];
        this.callback(this.manager, eventType, event);
    }
}

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @return {undefined|Array} [all, changed]
 */
function getTouches(event: TouchEvent, type: number) {
    var allTouches = toArray(event.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type &amp; (INPUT_START | INPUT_MOVE) &amp;&amp; allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(event.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i &lt; targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i &lt; changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type &amp; (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including &#x27;end&#x27; and &#x27;cancel&#x27;
        uniqueArray(targetTouches.concat(changedTargetTouches), &#x27;identifier&#x27;, true),
        changedTargetTouches
    ];
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it&#x27;s movement in it. *
 * Example session for mouse-input: mousedown -&gt; mousemove -&gt; mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                     Recognized
 */
export var STATE_UNDEFINED = 0;
export var STATE_POSSIBLE = 1;
export var STATE_BEGAN = 2;
export var STATE_CHANGED = 4;
export var STATE_RECOGNIZED = 8;
export var STATE_CANCELLED = 16;
export var STATE_FAILED = 32;

export class Recognizer implements IRecognizer {
    public id;
    public manager: IRecognizerCallback;
    public eventName: string;
    public enabled: boolean;
    public state: number;
    public simultaneous = {}; // TODO: Type as map of string to Recognizer.
    public requireFail: IRecognizer[] = [];
    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     */
    constructor(eventName: string, enabled: boolean) {
        this.eventName = eventName;
        this.enabled = enabled;
        this.id = uniqueId();

        this.manager = null;
        //      this.options = merge(options || {}, this.defaults);

        // default is enable true
        //      this.options.enable = ifUndefined(this.options.enable, true);

        this.state = STATE_POSSIBLE;
    }
    set(options) {
        //      extend(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager &amp;&amp; this.manager.updateTouchAction();
        return this;
    }

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @return {Recognizer} this
     */
    recognizeWith(otherRecognizer: IRecognizer): IRecognizer {
        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    }

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @return {Recognizer} this
     */
    dropRecognizeWith(otherRecognizer: IRecognizer) {
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    }

    /**
     * recognizer can only run when an other is failing
     */
    requireFailure(otherRecognizer: IRecognizer): IRecognizer {
        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    }

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @return {Recognizer} this
     */
    dropRequireFailure(otherRecognizer: IRecognizer) {
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index &gt; -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    }

    /**
     * has require failures boolean
     * @return {boolean}
     */
    hasRequireFailures(): boolean {
        return this.requireFail.length &gt; 0;
    }

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @return {Boolean}
     */
    canRecognizeWith(otherRecognizer: IRecognizer): boolean {
        return !!this.simultaneous[otherRecognizer.id];
    }

    /**
     * You should use &#x60;tryEmit&#x60; instead of &#x60;emit&#x60; directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit(): void {
        var self = this;
        var state = this.state;

        function emit(withState?: boolean) {
            var eventName = self.eventName + (withState ? stateStr(state) : &#x27;&#x27;);
            self.manager.emit(eventName, undefined);
        }

        // FIXME: Not nice, meaning implicit in state numbering.
        // &#x27;panstart&#x27; and &#x27;panmove&#x27;
        if (state &lt; STATE_RECOGNIZED) {
            emit(true);
        }

        emit(false); // simple &#x27;eventName&#x27; events

        // panend and pancancel
        if (state &gt;= STATE_RECOGNIZED) {
            emit(true);
        }
    }

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit() {
        if (this.canEmit()) {
            return this.emit();
        }
        else {
        }
        // it&#x27;s failing anyway?
        this.state = STATE_FAILED;
    }

    /**
     * can we emit?
     * @return {boolean}
     */
    canEmit() {
        var i = 0;
        while (i &lt; this.requireFail.length) {
            if (!(this.requireFail[i].state &amp; (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    }

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize(compEvent: IComputedEvent): void {

        if (!this.enabled) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we&#x27;ve reached the end
        if (this.state &amp; (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(compEvent);

        // the recognizer has recognized a gesture so trigger an event
        if (this.state &amp; (STATE_BEGAN | STATE_CHANGED | STATE_RECOGNIZED | STATE_CANCELLED)) {
            this.tryEmit();
        }
    }

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @return {Const} STATE
     */
    process(inputData: IComputedEvent): number {
        return STATE_UNDEFINED;
    }

    /**
     * return the preferred touch-action
     * @virtual
     * @return {Array}
     */
    getTouchAction(): string[] { return []; }

    /**
     * called when the gesture isn&#x27;t allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset() { }
}

/**
 * TODO: Are the string values part of the API, or just for debugging?
 * get a usable string, used as event postfix
 * @param {Const} state
 * @return {String} state
 */
export function stateStr(state: number): string {
    if (state &amp; STATE_CANCELLED) {
        return &#x27;cancel&#x27;;
    }
    else if (state &amp; STATE_RECOGNIZED) {
        return &#x27;end&#x27;;
    }
    else if (state &amp; STATE_CHANGED) {
        return &#x27;move&#x27;;
    }
    else if (state &amp; STATE_BEGAN) {
        return &#x27;start&#x27;;
    }
    return &#x27;&#x27;;
}

/**
 * Provide a decode of the state.
 * The result is not normative and should not be considered API.
 * Sine the state is a bit field, show all bits even though they may/should be exclusive.
 */
export function stateDecode(state: number): string {
    var states: string[] = [];
    if (state &amp; STATE_POSSIBLE) {
        states.push(&#x27;STATE_POSSIBLE&#x27;);
    }
    else if (state &amp; STATE_CANCELLED) {
        states.push(&#x27;STATE_CANCELLED&#x27;);
    }
    else if (state &amp; STATE_RECOGNIZED) {
        states.push(&#x27;STATE_RECOGNIZED&#x27;);
    }
    else if (state &amp; STATE_CHANGED) {
        states.push(&#x27;STATE_CHANGED&#x27;);
    }
    else if (state &amp; STATE_BEGAN) {
        states.push(&#x27;STATE_BEGAN&#x27;);
    }
    else if (state &amp; STATE_UNDEFINED) {
        states.push(&#x27;STATE_UNDEFINED&#x27;);
    }
    else if (state &amp; STATE_FAILED) {
        states.push(&#x27;STATE_FAILED&#x27;);
    }
    else {
        states.push(&#x27;&#x27; + state);
    }
    return states.join(&#x27; &#x27;);
}

/**
 * TODO: This really belongs in the input service.
 * direction cons to string
 * @param {Const} direction
 * @return {String}
 */
export function directionStr(direction: number): string {
    var ds: string[] = [];
    if (direction &amp; DIRECTION_DOWN) {
        ds.push(&#x27;down&#x27;);
    }
    if (direction &amp; DIRECTION_UP) {
        ds.push(&#x27;up&#x27;);
    }
    if (direction &amp; DIRECTION_LEFT) {
        ds.push(&#x27;left&#x27;);
    }
    if (direction &amp; DIRECTION_RIGHT) {
        ds.push(&#x27;right&#x27;);
    }
    return ds.join(&#x27; &#x27;);
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @return {Recognizer}
 */
function getRecognizerByNameIfManager(recognizer: IRecognizer, manager: IRecognizerCallback): IRecognizer {
    if (manager) {
        return manager.get(recognizer.eventName);
    }
    return recognizer;
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
