<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/EditSession.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.13</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Ace.html">Ace</a></li>
                                <li><a href="../classes/Anchor
                 
                 Creates a new &#x60;Anchor&#x60; and associates it with a document..html">Anchor
                 
                 Creates a new &#x60;Anchor&#x60; and associates it with a document.</a></li>
                                <li><a href="../classes/BackgroundTokenizer.html">BackgroundTokenizer</a></li>
                                <li><a href="../classes/Editor.html">Editor</a></li>
                                <li><a href="../classes/GutterTooltip.html">GutterTooltip</a></li>
                                <li><a href="../classes/HScrollBar.html">HScrollBar</a></li>
                                <li><a href="../classes/Mode.html">Mode</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ScrollBar.html">ScrollBar</a></li>
                                <li><a href="../classes/Search
                
                A class designed to handle all sorts of text searches within a [[Document &#x60;Document&#x60;]]..html">Search
                
                A class designed to handle all sorts of text searches within a [[Document &#x60;Document&#x60;]].</a></li>
                                <li><a href="../classes/Selection.html">Selection</a></li>
                                <li><a href="../classes/TokenIterator.html">TokenIterator</a></li>
                                <li><a href="../classes/Tokenizer.html">Tokenizer</a></li>
                                <li><a href="../classes/Tooltip.html">Tooltip</a></li>
                                <li><a href="../classes/UndoManager.html">UndoManager</a></li>
                                <li><a href="../classes/VirtualRenderer.html">VirtualRenderer</a></li>
                                <li><a href="../classes/VScrollBar.html">VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/EditSession.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

import {mixin} from &quot;./lib/oop&quot;;
import {delayedCall, stringRepeat} from &quot;./lib/lang&quot;;
import {_signal, defineOptions, loadModule, resetOptions} from &quot;./config&quot;;
import EventEmitterClass from &quot;./lib/event_emitter&quot;;
import FoldLine from &quot;./FoldLine&quot;;
import Fold from &quot;./Fold&quot;;
import Selection from &quot;./Selection&quot;;
import Mode from &quot;./mode/Mode&quot;;
import Range from &quot;./Range&quot;;
import EditorDocument from &quot;./EditorDocument&quot;;
import BackgroundTokenizer from &quot;./BackgroundTokenizer&quot;;
import SearchHighlight from &quot;./SearchHighlight&quot;;
import {assert} from &#x27;./lib/asserts&#x27;;
import BracketMatch from &quot;./edit_session/BracketMatch&quot;;
import UndoManager from &#x27;./UndoManager&#x27;
import TokenIterator from &#x27;./TokenIterator&#x27;;
import FontMetrics from &quot;./layer/FontMetrics&quot;;
import WorkerClient from &quot;./worker/WorkerClient&quot;;
import LineWidget from &#x27;./LineWidget&#x27;;
import LineWidgets from &#x27;./LineWidgets&#x27;;

// &quot;Tokens&quot;
var CHAR = 1,
    CHAR_EXT = 2,
    PLACEHOLDER_START = 3,
    PLACEHOLDER_BODY = 4,
    PUNCTUATION = 9,
    SPACE = 10,
    TAB = 11,
    TAB_SPACE = 12;

// For every keystroke this gets called once per char in the whole doc!!
// Wouldn&#x27;t hurt to make it a bit faster for c &gt;= 0x1100
function isFullWidth(c: number): boolean {
    if (c &lt; 0x1100)
        return false;
    return c &gt;= 0x1100 &amp;&amp; c &lt;= 0x115F ||
        c &gt;= 0x11A3 &amp;&amp; c &lt;= 0x11A7 ||
        c &gt;= 0x11FA &amp;&amp; c &lt;= 0x11FF ||
        c &gt;= 0x2329 &amp;&amp; c &lt;= 0x232A ||
        c &gt;= 0x2E80 &amp;&amp; c &lt;= 0x2E99 ||
        c &gt;= 0x2E9B &amp;&amp; c &lt;= 0x2EF3 ||
        c &gt;= 0x2F00 &amp;&amp; c &lt;= 0x2FD5 ||
        c &gt;= 0x2FF0 &amp;&amp; c &lt;= 0x2FFB ||
        c &gt;= 0x3000 &amp;&amp; c &lt;= 0x303E ||
        c &gt;= 0x3041 &amp;&amp; c &lt;= 0x3096 ||
        c &gt;= 0x3099 &amp;&amp; c &lt;= 0x30FF ||
        c &gt;= 0x3105 &amp;&amp; c &lt;= 0x312D ||
        c &gt;= 0x3131 &amp;&amp; c &lt;= 0x318E ||
        c &gt;= 0x3190 &amp;&amp; c &lt;= 0x31BA ||
        c &gt;= 0x31C0 &amp;&amp; c &lt;= 0x31E3 ||
        c &gt;= 0x31F0 &amp;&amp; c &lt;= 0x321E ||
        c &gt;= 0x3220 &amp;&amp; c &lt;= 0x3247 ||
        c &gt;= 0x3250 &amp;&amp; c &lt;= 0x32FE ||
        c &gt;= 0x3300 &amp;&amp; c &lt;= 0x4DBF ||
        c &gt;= 0x4E00 &amp;&amp; c &lt;= 0xA48C ||
        c &gt;= 0xA490 &amp;&amp; c &lt;= 0xA4C6 ||
        c &gt;= 0xA960 &amp;&amp; c &lt;= 0xA97C ||
        c &gt;= 0xAC00 &amp;&amp; c &lt;= 0xD7A3 ||
        c &gt;= 0xD7B0 &amp;&amp; c &lt;= 0xD7C6 ||
        c &gt;= 0xD7CB &amp;&amp; c &lt;= 0xD7FB ||
        c &gt;= 0xF900 &amp;&amp; c &lt;= 0xFAFF ||
        c &gt;= 0xFE10 &amp;&amp; c &lt;= 0xFE19 ||
        c &gt;= 0xFE30 &amp;&amp; c &lt;= 0xFE52 ||
        c &gt;= 0xFE54 &amp;&amp; c &lt;= 0xFE66 ||
        c &gt;= 0xFE68 &amp;&amp; c &lt;= 0xFE6B ||
        c &gt;= 0xFF01 &amp;&amp; c &lt;= 0xFF60 ||
        c &gt;= 0xFFE0 &amp;&amp; c &lt;= 0xFFE6;
}

export default class EditSession extends EventEmitterClass {
    public $breakpoints: string[] = [];
    public $decorations: string[] = [];
    private $frontMarkers = {};
    public $backMarkers = {};
    private $markerId = 1;
    private $undoSelect = true;
    private $deltas;
    private $deltasDoc;
    private $deltasFold;
    private $fromUndo;

    public widgetManager: LineWidgets;
    private $updateFoldWidgets: (event, editSession: EditSession) =&gt; any;
    private $foldData: FoldLine[];
    public foldWidgets: any[];
    public getFoldWidget: (row: number) =&gt; any;
    public getFoldWidgetRange: (row: number, forceMultiline?: boolean) =&gt; Range;
    public _changedWidgets: LineWidget[];

    public doc: EditorDocument;
    private $defaultUndoManager = { undo: function() { }, redo: function() { }, reset: function() { } };
    private $undoManager: UndoManager;
    private $informUndoManager: { cancel: () =&gt; void; schedule: () =&gt; void };
    public bgTokenizer: BackgroundTokenizer;
    public $modified;
    private selection: Selection;
    private $docRowCache: number[];
    private $wrapData: number[][];
    private $screenRowCache: number[];
    private $rowLengthCache;
    private $overwrite = false;
    public $searchHighlight: SearchHighlight;
    private $annotations;
    private $autoNewLine;
    private getOption;
    private setOption;
    private $useWorker;
    /**
     *
     */
    private $modes: { [path: string]: Mode } = {};

    /**
     *
     */
    public $mode: Mode = null;
    private $modeId = null;
    /**
     * The worker corresponding to the mode (i.e. Language).
     */
    private $worker: WorkerClient;
    private $options;
    public tokenRe: RegExp;
    public nonTokenRe: RegExp;
    public $scrollTop = 0;
    private $scrollLeft = 0;
    // WRAPMODE
    private $wrapAsCode;
    private $wrapLimit = 80;
    public $useWrapMode = false;
    private $wrapLimitRange = {
        min: null,
        max: null
    };
    public $updating;
    private $onChange = this.onChange.bind(this);
    private $syncInformUndoManager: () =&gt; void;
    public mergeUndoDeltas: boolean;
    private $useSoftTabs: boolean;
    private $tabSize: number;
    private $wrapMethod;
    private screenWidth: number;
    public lineWidgets: LineWidget[] = null;
    private lineWidgetsWidth: number;
    public lineWidgetWidth: number;
    public $getWidgetScreenLength;
    //
    public $tagHighlight;
    /**
     * This is a marker identifier.
     */
    public $bracketHighlight: number;
    /**
     * This is really a Range with an added marker id.
     */
    public $highlightLineMarker: Range;
    /**
     * A number is a marker identifier, null indicates that no such marker exists. 
     */
    public $selectionMarker: number = null;
    private $bracketMatcher = new BracketMatch(this);

    constructor(doc: EditorDocument, mode?, cb?: () =&gt; any) {
        super();
        this.$foldData = [];
        this.$foldData.toString = function() {
            return this.join(&quot;\n&quot;);
        }
        this.on(&quot;changeFold&quot;, this.onChangeFold.bind(this));
        this.setDocument(doc);
        this.selection = new Selection(this);

        resetOptions(this);
        this.setMode(mode, cb);
        _signal(&quot;session&quot;, this);
    }

    /**
     * Sets the &#x60;EditSession&#x60; to point to a new &#x60;EditorDocument&#x60;. If a &#x60;BackgroundTokenizer&#x60; exists, it also points to &#x60;doc&#x60;.
     * @method setDocument
     * @param doc {EditorDocument} The new &#x60;EditorDocument&#x60; to use.
     * @return {void}
     */
    private setDocument(doc: EditorDocument): void {
        if (!(doc instanceof EditorDocument)) {
            throw new Error(&quot;doc must be a EditorDocument&quot;);
        }
        if (this.doc) {
            this.doc.off(&quot;change&quot;, this.$onChange);
        }

        this.doc = doc;
        doc.on(&quot;change&quot;, this.$onChange);

        if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(this.getDocument());
        }

        this.resetCaches();
    }

    /**
     * Returns the &#x60;EditorDocument&#x60; associated with this session.
     * @method getDocument
     * @return {EditorDocument}
     */
    public getDocument(): EditorDocument {
        return this.doc;
    }

    /**
     * @method $resetRowCache
     * @param {number} row The row to work with
     * @return {void}
     * @private
     */
    private $resetRowCache(docRow: number): void {
        if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
        }
        var l = this.$docRowCache.length;
        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
        if (l &gt; i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
        }
    }

    private $getRowCacheIndex(cacheArray: number[], val: number): number {
        var low = 0;
        var hi = cacheArray.length - 1;

        while (low &lt;= hi) {
            var mid = (low + hi) &gt;&gt; 1;
            var c = cacheArray[mid];

            if (val &gt; c) {
                low = mid + 1;
            }
            else if (val &lt; c) {
                hi = mid - 1;
            }
            else {
                return mid;
            }
        }

        return low - 1;
    }

    private resetCaches() {
        this.$modified = true;
        this.$wrapData = [];
        this.$rowLengthCache = [];
        this.$resetRowCache(0);
        if (this.bgTokenizer) {
            this.bgTokenizer.start(0);
        }
    }

    private onChangeFold(e) {
        var fold = e.data;
        this.$resetRowCache(fold.start.row);
    }

    private onChange(e, doc: EditorDocument) {
        var delta = e.data;
        this.$modified = true;

        this.$resetRowCache(delta.range.start.row);

        var removedFolds = this.$updateInternalDataOnChange(e);
        if (!this.$fromUndo &amp;&amp; this.$undoManager &amp;&amp; !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds &amp;&amp; removedFolds.length != 0) {
                this.$deltasFold.push({
                    action: &quot;removeFolds&quot;,
                    folds: removedFolds
                });
            }

            this.$informUndoManager.schedule();
        }

        this.bgTokenizer.$updateOnChange(delta);
        this._signal(&quot;change&quot;, e);
    }

    /**
     * Sets the session text.
     * @method setValue
     * @param text {string} The new text to place.
     * @return {void}
     * @private
     */
    private setValue(text: string): void {
        this.doc.setValue(text);
        this.selection.moveTo(0, 0);

        this.$resetRowCache(0);
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];
        this.setUndoManager(this.$undoManager);
        this.getUndoManager().reset();
    }

    /**
    * Returns the current [[EditorDocument &#x60;EditorDocument&#x60;]] as a string.
    * @method toString
    * @returns {string}
    * @alias EditSession.getValue
    **/
    public toString(): string {
        return this.getValue();
    }

    /**
    * Returns the current [[EditorDocument &#x60;EditorDocument&#x60;]] as a string.
    * @method getValue
    * @returns {string}
    * @alias EditSession.toString
    **/
    public getValue(): string {
        return this.doc.getValue();
    }

    /**
     * Returns the string of the current selection.
     */
    public getSelection(): Selection {
        return this.selection;
    }
    public setSelection(selection: Selection): void {
        this.selection = selection;
    }

    /**
     * {:BackgroundTokenizer.getState}
     * @param {Number} row The row to start at
     *
     * @related BackgroundTokenizer.getState
     **/
    public getState(row: number): string {
        return this.bgTokenizer.getState(row);
    }

    /**
     * Starts tokenizing at the row indicated. Returns a list of objects of the tokenized rows.
     * @method getTokens
     * @param row {number} The row to start at.
     **/
    public getTokens(row: number): { start: number; type: string; value: string }[] {
        return this.bgTokenizer.getTokens(row);
    }

    /**
    * Returns an object indicating the token at the current row. The object has two properties: &#x60;index&#x60; and &#x60;start&#x60;.
    * @param {Number} row The row number to retrieve from
    * @param {Number} column The column number to retrieve from
    *
    *
    **/
    public getTokenAt(row: number, column?: number) {
        var tokens: { value: string }[] = this.bgTokenizer.getTokens(row);
        var token: { index?: number; start?: number; value: string };
        var c = 0;
        if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
        }
        else {
            for (var i = 0; i &lt; tokens.length; i++) {
                c += tokens[i].value.length;
                if (c &gt;= column)
                    break;
            }
        }
        token = tokens[i];
        if (!token)
            return null;
        token.index = i;
        token.start = c - token.value.length;
        return token;
    }

    /**
    * Sets the undo manager.
    * @param {UndoManager} undoManager The new undo manager
    **/
    public setUndoManager(undoManager: UndoManager): void {
        this.$undoManager = undoManager;
        this.$deltas = [];
        this.$deltasDoc = [];
        this.$deltasFold = [];

        if (this.$informUndoManager)
            this.$informUndoManager.cancel();

        if (undoManager) {
            var self = this;

            this.$syncInformUndoManager = function() {
                self.$informUndoManager.cancel();

                if (self.$deltasFold.length) {
                    self.$deltas.push({
                        group: &quot;fold&quot;,
                        deltas: self.$deltasFold
                    });
                    self.$deltasFold = [];
                }

                if (self.$deltasDoc.length) {
                    self.$deltas.push({
                        group: &quot;doc&quot;,
                        deltas: self.$deltasDoc
                    });
                    self.$deltasDoc = [];
                }

                if (self.$deltas.length &gt; 0) {
                    undoManager.execute({
                        action: &quot;aceupdate&quot;,
                        args: [self.$deltas, self],
                        merge: self.mergeUndoDeltas
                    });
                }
                self.mergeUndoDeltas = false;
                self.$deltas = [];
            };
            this.$informUndoManager = delayedCall(this.$syncInformUndoManager);
        }
    }

    /**
     * starts a new group in undo history
     */
    public markUndoGroup(): void {
        if (this.$syncInformUndoManager) {
            this.$syncInformUndoManager();
        }
    }

    /**
    * Returns the current undo manager.
    **/
    public getUndoManager() {
        return this.$undoManager || this.$defaultUndoManager;
    }

    /**
    * Returns the current value for tabs. If the user is using soft tabs, this will be a series of spaces (defined by [[EditSession.getTabSize &#x60;getTabSize()&#x60;]]); otherwise it&#x27;s simply &#x60;&#x27;\t&#x27;&#x60;.
    **/
    public getTabString() {
        if (this.getUseSoftTabs()) {
            return stringRepeat(&quot; &quot;, this.getTabSize());
        } else {
            return &quot;\t&quot;;
        }
    }

    /**
    /**
    * Pass &#x60;true&#x60; to enable the use of soft tabs. Soft tabs means you&#x27;re using spaces instead of the tab character (&#x60;&#x27;\t&#x27;&#x60;).
    * @param {Boolean} useSoftTabs Value indicating whether or not to use soft tabs
    **/
    private setUseSoftTabs(useSoftTabs: boolean) {
        this.setOption(&quot;useSoftTabs&quot;, useSoftTabs);
    }

    /**
    * Returns &#x60;true&#x60; if soft tabs are being used, &#x60;false&#x60; otherwise.
    * @returns {Boolean}
    **/
    public getUseSoftTabs(): boolean {
        // todo might need more general way for changing settings from mode, but this is ok for now
        return this.$useSoftTabs &amp;&amp; !this.$mode.$indentWithTabs;
    }

    /**
    * Set the number of spaces that define a soft tab.
    * For example, passing in &#x60;4&#x60; transforms the soft tabs to be equivalent to four spaces.
    * This function also emits the &#x60;changeTabSize&#x60; event.
    * @param {Number} tabSize The new tab size
    **/
    private setTabSize(tabSize: number) {
        this.setOption(&quot;tabSize&quot;, tabSize);
    }

    /**
    * Returns the current tab size.
    **/
    public getTabSize(): number {
        return this.$tabSize;
    }

    /**
    * Returns &#x60;true&#x60; if the character at the position is a soft tab.
    * @param {Object} position The position to check
    *
    *
    **/
    public isTabStop(position: { column: number }) {
        return this.$useSoftTabs &amp;&amp; (position.column % this.$tabSize === 0);
    }

    /**
    * Pass in &#x60;true&#x60; to enable overwrites in your session, or &#x60;false&#x60; to disable.
    *
    * If overwrites is enabled, any text you enter will type over any text after it. If the value of &#x60;overwrite&#x60; changes, this function also emites the &#x60;changeOverwrite&#x60; event.
    *
    * @param {Boolean} overwrite Defines whether or not to set overwrites
    *
    *
    **/
    public setOverwrite(overwrite: boolean) {
        this.setOption(&quot;overwrite&quot;, overwrite);
    }

    /**
    * Returns &#x60;true&#x60; if overwrites are enabled; &#x60;false&#x60; otherwise.
    **/
    public getOverwrite(): boolean {
        return this.$overwrite;
    }

    /**
    * Sets the value of overwrite to the opposite of whatever it currently is.
    **/
    public toggleOverwrite(): void {
        this.setOverwrite(!this.$overwrite);
    }

    /**
     * Adds &#x60;className&#x60; to the &#x60;row&#x60;, to be used for CSS stylings and whatnot.
     * @param {Number} row The row number
     * @param {String} className The class to add
     */
    public addGutterDecoration(row: number, className: string): void {
        if (!this.$decorations[row]) {
            this.$decorations[row] = &quot;&quot;;
        }
        this.$decorations[row] += &quot; &quot; + className;
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
     * Removes &#x60;className&#x60; from the &#x60;row&#x60;.
     * @param {Number} row The row number
     * @param {String} className The class to add
     */
    public removeGutterDecoration(row: number, className: string): void {
        this.$decorations[row] = (this.$decorations[row] || &quot;&quot;).replace(&quot; &quot; + className, &quot;&quot;);
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
    * Returns an array of numbers, indicating which rows have breakpoints.
    * @returns {[Number]}
    **/
    private getBreakpoints() {
        return this.$breakpoints;
    }

    /**
    * Sets a breakpoint on every row number given by &#x60;rows&#x60;. This function also emites the &#x60;&#x27;changeBreakpoint&#x27;&#x60; event.
    * @param {Array} rows An array of row indices
    *
    *
    *
    **/
    private setBreakpoints(rows: number[]): void {
        this.$breakpoints = [];
        for (var i = 0; i &lt; rows.length; i++) {
            this.$breakpoints[rows[i]] = &quot;ace_breakpoint&quot;;
        }
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
    * Removes all breakpoints on the rows. This function also emites the &#x60;&#x27;changeBreakpoint&#x27;&#x60; event.
    **/
    private clearBreakpoints() {
        this.$breakpoints = [];
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
    * Sets a breakpoint on the row number given by &#x60;rows&#x60;. This function also emites the &#x60;&#x27;changeBreakpoint&#x27;&#x60; event.
    * @param {Number} row A row index
    * @param {String} className Class of the breakpoint
    *
    *
    **/
    private setBreakpoint(row: number, className: string): void {
        if (className === undefined)
            className = &quot;ace_breakpoint&quot;;
        if (className)
            this.$breakpoints[row] = className;
        else
            delete this.$breakpoints[row];
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
    * Removes a breakpoint on the row number given by &#x60;rows&#x60;. This function also emites the &#x60;&#x27;changeBreakpoint&#x27;&#x60; event.
    * @param {Number} row A row index
    *
    *
    **/
    private clearBreakpoint(row: number): void {
        delete this.$breakpoints[row];
        this._signal(&quot;changeBreakpoint&quot;, {});
    }

    /**
    * Adds a new marker to the given &#x60;Range&#x60;. If &#x60;inFront&#x60; is &#x60;true&#x60;, a front marker is defined, and the &#x60;&#x27;changeFrontMarker&#x27;&#x60; event fires; otherwise, the &#x60;&#x27;changeBackMarker&#x27;&#x60; event fires.
    * @param {Range} range Define the range of the marker
    * @param {String} clazz Set the CSS class for the marker
    * @param {Function | String} type Identify the type of the marker.
    * @param {Boolean} inFront Set to &#x60;true&#x60; to establish a front marker
    *
    *
    * @return {Number} The new marker id
    **/
    public addMarker(range: Range, clazz: string, type: string, inFront?: boolean): number {
        var id = this.$markerId++;

        // FIXME: Need more type safety here.
        var marker = {
            range: range,
            type: type || &quot;line&quot;,
            renderer: typeof type === &quot;function&quot; ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
        };

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal(&quot;changeFrontMarker&quot;);
        }
        else {
            this.$backMarkers[id] = marker;
            this._signal(&quot;changeBackMarker&quot;);
        }

        return id;
    }

    /**
     * Adds a dynamic marker to the session.
     * @param {Object} marker object with update method
     * @param {Boolean} inFront Set to &#x60;true&#x60; to establish a front marker
     *
     *
     * @return {Object} The added marker
     **/
    private addDynamicMarker(marker, inFront?) {
        if (!marker.update)
            return;
        var id = this.$markerId++;
        marker.id = id;
        marker.inFront = !!inFront;

        if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal(&quot;changeFrontMarker&quot;);
        } else {
            this.$backMarkers[id] = marker;
            this._signal(&quot;changeBackMarker&quot;);
        }

        return marker;
    }

    /**
    * Removes the marker with the specified ID. If this marker was in front, the &#x60;&#x27;changeFrontMarker&#x27;&#x60; event is emitted. If the marker was in the back, the &#x60;&#x27;changeBackMarker&#x27;&#x60; event is emitted.
    * @param {Number} markerId A number representing a marker
    *
    *
    *
    **/
    public removeMarker(markerId: number): void {
        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
        if (!marker)
            return;

        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
        if (marker) {
            delete (markers[markerId]);
            this._signal(marker.inFront ? &quot;changeFrontMarker&quot; : &quot;changeBackMarker&quot;);
        }
    }

    /**
    * Returns an array containing the IDs of all the markers, either front or back.
    * @param {boolean} inFront If &#x60;true&#x60;, indicates you only want front markers; &#x60;false&#x60; indicates only back markers
    *
    * @returns {Array}
    **/
    public getMarkers(inFront: boolean) {
        return inFront ? this.$frontMarkers : this.$backMarkers;
    }

    public highlight(re: RegExp) {
        if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, &quot;ace_selected-word&quot;, &quot;text&quot;);
            this.$searchHighlight = this.addDynamicMarker(highlight);
        }
        this.$searchHighlight.setRegexp(re);
    }

    private highlightLines(startRow: number, endRow: number, clazz: string = &quot;ace_step&quot;, inFront?: boolean): Range {
        var range: Range = new Range(startRow, 0, endRow, Infinity);
        range.markerId = this.addMarker(range, clazz, &quot;fullLine&quot;, inFront);
        return range;
    }

    /*
     * Error:
     *  {
     *    row: 12,
     *    column: 2, //can be undefined
     *    text: &quot;Missing argument&quot;,
     *    type: &quot;error&quot; // or &quot;warning&quot; or &quot;info&quot;
     *  }
     */
    /**
    * Sets annotations for the &#x60;EditSession&#x60;. This functions emits the &#x60;&#x27;changeAnnotation&#x27;&#x60; event.
    * @param {Array} annotations A list of annotations
    *
    **/
    public setAnnotations(annotations) {
        this.$annotations = annotations;
        this._signal(&quot;changeAnnotation&quot;, {});
    }

    /**
    * Returns the annotations for the &#x60;EditSession&#x60;.
    * @returns {Array}
    **/
    public getAnnotations = function() {
        return this.$annotations || [];
    }

    /**
     * Clears all the annotations for this session.
     * This function also triggers the &#x60;&#x27;changeAnnotation&#x27;&#x60; event.
     * This is called by the language modes when the worker terminates.
     */
    public clearAnnotations() {
        this.setAnnotations([]);
    }

    /**
    * If &#x60;text&#x60; contains either the newline (&#x60;\n&#x60;) or carriage-return (&#x27;\r&#x27;) characters, &#x60;$autoNewLine&#x60; stores that value.
    * @param {String} text A block of text
    *
    **/
    private $detectNewLine(text: string) {
        var match = text.match(/^.*?(\r?\n)/m);
        if (match) {
            this.$autoNewLine = match[1];
        }
        else {
            this.$autoNewLine = &quot;\n&quot;;
        }
    }

    /**
    * Given a starting row and column, this method returns the &#x60;Range&#x60; of the first word boundary it finds.
    * @param {Number} row The row to start at
    * @param {Number} column The column to start at
    *
    * @returns {Range}
    **/
    public getWordRange(row: number, column: number): Range {
        var line: string = this.getLine(row);

        var inToken = false;
        if (column &gt; 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);

        if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);

        if (inToken)
            var re = this.tokenRe;
        else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
        else
            var re = this.nonTokenRe;

        var start = column;
        if (start &gt; 0) {
            do {
                start--;
            }
            while (start &gt;= 0 &amp;&amp; line.charAt(start).match(re));
            start++;
        }

        var end = column;
        while (end &lt; line.length &amp;&amp; line.charAt(end).match(re)) {
            end++;
        }

        return new Range(row, start, row, end);
    }

    /**
    * Gets the range of a word, including its right whitespace.
    * @param {Number} row The row number to start from
    * @param {Number} column The column number to start from
    *
    * @return {Range}
    **/
    public getAWordRange(row: number, column: number): Range {
        var wordRange = this.getWordRange(row, column);
        var line = this.getLine(wordRange.end.row);

        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
        }

        return wordRange;
    }

    /**
    * {:EditorDocument.setNewLineMode.desc}
    * @param {String} newLineMode {:EditorDocument.setNewLineMode.param}
    *
    *
    * @related EditorDocument.setNewLineMode
    **/
    private setNewLineMode(newLineMode: string): void {
        this.doc.setNewLineMode(newLineMode);
    }

    /**
    *
    * Returns the current new line mode.
    * @returns {String}
    * @related EditorDocument.getNewLineMode
    **/
    private getNewLineMode(): string {
        return this.doc.getNewLineMode();
    }

    /**
    * Identifies if you want to use a worker for the &#x60;EditSession&#x60;.
    * @param {Boolean} useWorker Set to &#x60;true&#x60; to use a worker
    *
    **/
    private setUseWorker(useWorker: boolean) { this.setOption(&quot;useWorker&quot;, useWorker); }

    /**
    * Returns &#x60;true&#x60; if workers are being used.
    **/
    private getUseWorker(): boolean { return this.$useWorker; }

    /**
    * Reloads all the tokens on the current session. This function calls [[BackgroundTokenizer.start &#x60;BackgroundTokenizer.start ()&#x60;]] to all the rows; it also emits the &#x60;&#x27;tokenizerUpdate&#x27;&#x60; event.
    **/
    private onReloadTokenizer(e) {
        var rows = e.data;
        this.bgTokenizer.start(rows.first);
        this._signal(&quot;tokenizerUpdate&quot;, e);
    }


    /**
    * Sets a new text mode for the &#x60;EditSession&#x60;. This method also emits the &#x60;&#x27;changeMode&#x27;&#x60; event. If a [[BackgroundTokenizer &#x60;BackgroundTokenizer&#x60;]] is set, the &#x60;&#x27;tokenizerUpdate&#x27;&#x60; event is also emitted.
    * @param {TextMode} mode Set a new text mode
    * @param {cb} optional callback
    *
    **/
    private setMode(mode, cb?: () =&gt; any): void {
        if (mode &amp;&amp; typeof mode === &quot;object&quot;) {
            if (mode.getTokenizer) {
                return this.$onChangeMode(mode);
            }
            var options = mode;
            var path = options.path;
        }
        else {
            path = mode || &quot;ace/mode/text&quot;;
        }

        // this is needed if ace isn&#x27;t on require path (e.g tests in node)
        if (!this.$modes[&quot;ace/mode/text&quot;]) {
            this.$modes[&quot;ace/mode/text&quot;] = new Mode();
        }

        if (this.$modes[path] &amp;&amp; !options) {
            this.$onChangeMode(this.$modes[path]);
            cb &amp;&amp; cb();
            return;
        }
        // load on demand
        this.$modeId = path;
        loadModule([&quot;mode&quot;, path], function(m: any) {
            if (this.$modeId !== path)
                return cb &amp;&amp; cb();
            if (this.$modes[path] &amp;&amp; !options)
                return this.$onChangeMode(this.$modes[path]);
            if (m &amp;&amp; m.Mode) {
                m = new m.Mode(options);
                if (!options) {
                    this.$modes[path] = m;
                    m.$id = path;
                }
                this.$onChangeMode(m);
                cb &amp;&amp; cb();
            }
        }.bind(this));

        // set mode to text until loading is finished
        if (!this.$mode) {
            this.$onChangeMode(this.$modes[&quot;ace/mode/text&quot;], true);
        }
    }

    private $onChangeMode(mode: Mode, $isPlaceholder?: boolean): void {
        if (!$isPlaceholder) {
            this.$modeId = mode.$id;
        }
        if (this.$mode === mode) {
            // Nothing to do. Be idempotent.
            return;
        }

        this.$mode = mode;

        // TODO: Wouldn&#x27;t it make more sense to stop the worker, then change the mode?
        this.$stopWorker();

        if (this.$useWorker) {
            this.$startWorker();
        }

        var tokenizer = mode.getTokenizer();

        if (tokenizer[&#x27;addEventListener&#x27;] !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer[&#x27;addEventListener&#x27;](&quot;update&quot;, onReloadTokenizer);
        }

        if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.on(&quot;update&quot;, function(event, bg: BackgroundTokenizer) {
                _self._signal(&quot;tokenizerUpdate&quot;, event);
            });
        }
        else {
            this.bgTokenizer.setTokenizer(tokenizer);
        }

        this.bgTokenizer.setDocument(this.getDocument());

        this.tokenRe = mode.tokenRe;
        this.nonTokenRe = mode.nonTokenRe;


        if (!$isPlaceholder) {
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit(&quot;changeMode&quot;);
        }
    }


    private $stopWorker() {
        if (this.$worker) {
            this.$worker.terminate();
        }
        this.$worker = null;
    }

    private $startWorker() {
        try {
            this.$worker = this.$mode.createWorker(this);
        }
        catch (e) {
            this.$worker = null;
        }
    }

    /**
    * Returns the current text mode.
    * @returns {TextMode} The current text mode
    **/
    public getMode() {
        return this.$mode;
    }

    /**
    * This function sets the scroll top value. It also emits the &#x60;&#x27;changeScrollTop&#x27;&#x60; event.
    * @param {Number} scrollTop The new scroll top value
    *
    **/
    public setScrollTop(scrollTop: number) {
        // TODO: should we force integer lineheight instead? scrollTop = Math.round(scrollTop); 
        if (this.$scrollTop === scrollTop || isNaN(scrollTop)) {
            return;
        }
        this.$scrollTop = scrollTop;
        this._signal(&quot;changeScrollTop&quot;, scrollTop);
    }

    /**
    * [Returns the value of the distance between the top of the editor and the topmost part of the visible content.]{: #EditSession.getScrollTop}
    * @returns {Number}
    **/
    public getScrollTop(): number {
        return this.$scrollTop;
    }

    /**
    * [Sets the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.setScrollLeft}
    **/
    public setScrollLeft(scrollLeft: number) {
        // scrollLeft = Math.round(scrollLeft);
        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;

        this.$scrollLeft = scrollLeft;
        this._signal(&quot;changeScrollLeft&quot;, scrollLeft);
    }

    /**
    * [Returns the value of the distance between the left of the editor and the leftmost part of the visible content.]{: #EditSession.getScrollLeft}
    * @returns {Number}
    **/
    public getScrollLeft(): number {
        return this.$scrollLeft;
    }

    /**
    * Returns the width of the screen.
    * @returns {Number}
    **/
    public getScreenWidth(): number {
        this.$computeWidth();
        if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
        return this.screenWidth;
    }

    private getLineWidgetMaxWidth(): number {
        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
        var width = 0;
        this.lineWidgets.forEach(function(w) {
            if (w &amp;&amp; w.screenWidth &gt; width)
                width = w.screenWidth;
        });
        return this.lineWidgetWidth = width;
    }

    public $computeWidth(force?: boolean): number {
        if (this.$modified || force) {
            this.$modified = false;

            if (this.$useWrapMode) {
                return this.screenWidth = this.$wrapLimit;
            }

            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;

            for (var i = 0; i &lt; len; i++) {
                if (i &gt; foldStart) {
                    i = foldLine.end.row + 1;
                    if (i &gt;= len)
                        break;
                    foldLine = this.$foldData[foldIndex++];
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }

                if (cache[i] == null)
                    cache[i] = this.$getStringScreenWidth(lines[i])[0];

                if (cache[i] &gt; longestScreenLine)
                    longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
        }
    }

    /**
     * Returns a verbatim copy of the given line as it is in the document
     * @param {Number} row The row to retrieve from
     *
    *
     * @returns {String}
    *
    **/
    public getLine(row: number): string {
        return this.doc.getLine(row);
    }

    /**
     * Returns an array of strings of the rows between &#x60;firstRow&#x60; and &#x60;lastRow&#x60;. This function is inclusive of &#x60;lastRow&#x60;.
     * @param {Number} firstRow The first row index to retrieve
     * @param {Number} lastRow The final row index to retrieve
     *
     * @returns {[String]}
     *
     **/
    public getLines(firstRow: number, lastRow: number): string[] {
        return this.doc.getLines(firstRow, lastRow);
    }

    /**
     * Returns the number of rows in the document.
     * @returns {Number}
     **/
    public getLength(): number {
        return this.doc.getLength();
    }

    /**
     * {:EditorDocument.getTextRange.desc}
     * @param {Range} range The range to work with
     *
     * @returns {string}
     **/
    public getTextRange(range: Range): string {
        return this.doc.getTextRange(range || this.selection.getRange());
    }

    /**
     * Inserts a block of &#x60;text&#x60; and the indicated &#x60;position&#x60;.
     * @param {Object} position The position {row, column} to start inserting at
     * @param {String} text A chunk of text to insert
     * @returns {Object} The position of the last line of &#x60;text&#x60;. If the length of &#x60;text&#x60; is 0, this function simply returns &#x60;position&#x60;.
     *
     *
     **/
    public insert(position: { row: number; column: number }, text: string) {
        return this.doc.insert(position, text);
    }

    /**
     * Removes the &#x60;range&#x60; from the document.
     * @param {Range} range A specified Range to remove
     * @returns {Object} The new &#x60;start&#x60; property of the range, which contains &#x60;startRow&#x60; and &#x60;startColumn&#x60;. If &#x60;range&#x60; is empty, this function returns the unmodified value of &#x60;range.start&#x60;.
     *
     * @related EditorDocument.remove
     *
     **/
    public remove(range: Range) {
        return this.doc.remove(range);
    }

    /**
     * Reverts previous changes to your document.
     * @param {Array} deltas An array of previous changes
     * @param {Boolean} dontSelect [If &#x60;true&#x60;, doesn&#x27;t select the range of where the change occured]{: #dontSelect}
     *
     *
     * @returns {Range}
    **/
    public undoChanges(deltas, dontSelect?: boolean) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange: Range = null;
        for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == &quot;doc&quot;) {
                this.doc.revertDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
                delta.deltas.forEach(function(foldDelta) {
                    this.addFolds(foldDelta.folds);
                }, this);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &amp;&amp;
            this.$undoSelect &amp;&amp;
            !dontSelect &amp;&amp;
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    }

    /**
     * Re-implements a previously undone change to your document.
     * @param {Array} deltas An array of previous changes
     * @param {Boolean} dontSelect {:dontSelect}
     *
    *
     * @returns {Range}
    **/
    public redoChanges(deltas, dontSelect?: boolean) {
        if (!deltas.length)
            return;

        this.$fromUndo = true;
        var lastUndoRange: Range = null;
        for (var i = 0; i &lt; deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == &quot;doc&quot;) {
                this.doc.applyDeltas(delta.deltas);
                lastUndoRange =
                    this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
        }
        this.$fromUndo = false;
        lastUndoRange &amp;&amp;
            this.$undoSelect &amp;&amp;
            !dontSelect &amp;&amp;
            this.selection.setSelectionRange(lastUndoRange);
        return lastUndoRange;
    }

    /**
     * Enables or disables highlighting of the range where an undo occurred.
     * @param {Boolean} enable If &#x60;true&#x60;, selects the range of the reinserted change
    *
    **/
    private setUndoSelect(enable: boolean): void {
        this.$undoSelect = enable;
    }

    private $getUndoSelection(deltas: { action: string; range: Range }[], isUndo: boolean, lastUndoRange: Range): Range {
        function isInsert(delta: { action: string }) {
            var insert = delta.action === &quot;insertText&quot; || delta.action === &quot;insertLines&quot;;
            return isUndo ? !insert : insert;
        }

        var delta: { action: string; range: Range } = deltas[0];
        var range: Range;
        var point: { row: number; column: number };
        var lastDeltaIsInsert = false;
        if (isInsert(delta)) {
            range = Range.fromPoints(delta.range.start, delta.range.end);
            lastDeltaIsInsert = true;
        }
        else {
            range = Range.fromPoints(delta.range.start, delta.range.start);
            lastDeltaIsInsert = false;
        }

        for (var i = 1; i &lt; deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
                point = delta.range.start;
                if (range.compare(point.row, point.column) === -1) {
                    range.setStart(delta.range.start.row, delta.range.start.column);
                }
                point = delta.range.end;
                if (range.compare(point.row, point.column) === 1) {
                    range.setEnd(delta.range.end.row, delta.range.end.column);
                }
                lastDeltaIsInsert = true;
            }
            else {
                point = delta.range.start;
                if (range.compare(point.row, point.column) === -1) {
                    range = Range.fromPoints(delta.range.start, delta.range.start);
                }
                lastDeltaIsInsert = false;
            }
        }

        // Check if this range and the last undo range has something in common.
        // If true, merge the ranges.
        if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                lastUndoRange.start.column += range.end.column - range.start.column;
                lastUndoRange.end.column += range.end.column - range.start.column;
            }

            var cmp = lastUndoRange.compareRange(range);
            if (cmp === 1) {
                range.setStart(lastUndoRange.start.row, lastUndoRange.start.column);
            }
            else if (cmp === -1) {
                range.setEnd(lastUndoRange.end.row, lastUndoRange.start.column);
            }
        }

        return range;
    }

    /**
    * Replaces a range in the document with the new &#x60;text&#x60;.
    *
    * @param {Range} range A specified Range to replace
    * @param {String} text The new text to use as a replacement
    * @returns {Object} An object containing the final row and column, like this:
    * &#x60;&#x60;&#x60;
    * {row: endRow, column: 0}
    * &#x60;&#x60;&#x60;
    * If the text and range are empty, this function returns an object containing the current &#x60;range.start&#x60; value.
    * If the text is the exact same as what currently exists, this function returns an object containing the current &#x60;range.end&#x60; value.
    *
    *
    *
    * @related EditorDocument.replace
    *
    *
    **/
    public replace(range: Range, text: string) {
        return this.doc.replace(range, text);
    }

    /**
    * Moves a range of text from the given range to the given position. &#x60;toPosition&#x60; is an object that looks like this:
     *  &#x60;&#x60;&#x60;json
    *    { row: newRowLocation, column: newColumnLocation }
     *  &#x60;&#x60;&#x60;
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     * @returns {Range} The new range where the text was moved to.
    *
    *
    *
    **/
    public moveText(fromRange: Range, toPosition: { row: number; column: number }, copy) {
        var text = this.getTextRange(fromRange);
        var folds = this.getFoldsInRange(fromRange);
        var rowDiff: number;
        var colDiff: number;

        var toRange = Range.fromPoints(toPosition, toPosition);
        if (!copy) {
            this.remove(fromRange);
            rowDiff = fromRange.start.row - fromRange.end.row;
            colDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (colDiff) {
                if (toRange.start.row == fromRange.end.row &amp;&amp; toRange.start.column &gt; fromRange.end.column) {
                    toRange.start.column += colDiff;
                }
                if (toRange.end.row == fromRange.end.row &amp;&amp; toRange.end.column &gt; fromRange.end.column) {
                    toRange.end.column += colDiff;
                }
            }
            if (rowDiff &amp;&amp; toRange.start.row &gt;= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
            }
        }

        toRange.end = this.insert(toRange.start, text);
        if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            rowDiff = newStart.row - oldStart.row;
            colDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
                x = x.clone();
                if (x.start.row == oldStart.row) {
                    x.start.column += colDiff;
                }
                if (x.end.row == oldStart.row) {
                    x.end.column += colDiff;
                }
                x.start.row += rowDiff;
                x.end.row += rowDiff;
                return x;
            }));
        }

        return toRange;
    }

    /**
    * Indents all the rows, from &#x60;startRow&#x60; to &#x60;endRow&#x60; (inclusive), by prefixing each row with the token in &#x60;indentString&#x60;.
    *
    * If &#x60;indentString&#x60; contains the &#x60;&#x27;\t&#x27;&#x60; character, it&#x27;s replaced by whatever is defined by [[EditSession.getTabString &#x60;getTabString()&#x60;]].
    * @param {Number} startRow Starting row
    * @param {Number} endRow Ending row
    * @param {String} indentString The indent token
    *
    *
    **/
    public indentRows(startRow: number, endRow: number, indentString: string): void {
        indentString = indentString.replace(/\t/g, this.getTabString());
        for (var row = startRow; row &lt;= endRow; row++)
            this.insert({ row: row, column: 0 }, indentString);
    }

    /**
    * Outdents all the rows defined by the &#x60;start&#x60; and &#x60;end&#x60; properties of &#x60;range&#x60;.
    * @param {Range} range A range of rows
    *
    *
    **/
    public outdentRows(range: Range) {
        var rowRange = range.collapseRows();
        var deleteRange = new Range(0, 0, 0, 0);
        var size = this.getTabSize();

        for (var i = rowRange.start.row; i &lt;= rowRange.end.row; ++i) {
            var line = this.getLine(i);

            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j &lt; size; ++j)
                if (line.charAt(j) != &#x27; &#x27;)
                    break;
            if (j &lt; size &amp;&amp; line.charAt(j) == &#x27;\t&#x27;) {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
            } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
            }
            this.remove(deleteRange);
        }
    }

    private $moveLines(firstRow: number, lastRow: number, dir: number) {
        firstRow = this.getRowFoldStart(firstRow);
        lastRow = this.getRowFoldEnd(lastRow);
        if (dir &lt; 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row &lt; 0) return 0;
            var diff = row - firstRow;
        } else if (dir &gt; 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row &gt; this.doc.getLength() - 1) return 0;
            var diff = row - lastRow;
        } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
        }

        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
        var folds = this.getFoldsInRange(range).map(function(x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
        });

        var lines = dir == 0
            ? this.doc.getLines(firstRow, lastRow)
            : this.doc.removeLines(firstRow, lastRow);
        this.doc.insertLines(firstRow + diff, lines);
        folds.length &amp;&amp; this.addFolds(folds);
        return diff;
    }
    /**
    * Shifts all the lines in the document up one, starting from &#x60;firstRow&#x60; and ending at &#x60;lastRow&#x60;.
    * @param {Number} firstRow The starting row to move up
    * @param {Number} lastRow The final row to move up
    * @returns {Number} If &#x60;firstRow&#x60; is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
    *
    * @related EditorDocument.insertLines
    *
    **/
    private moveLinesUp(firstRow: number, lastRow: number): number {
        return this.$moveLines(firstRow, lastRow, -1);
    }

    /**
    * Shifts all the lines in the document down one, starting from &#x60;firstRow&#x60; and ending at &#x60;lastRow&#x60;.
    * @param {Number} firstRow The starting row to move down
    * @param {Number} lastRow The final row to move down
    * @returns {Number} If &#x60;firstRow&#x60; is less-than or equal to 0, this function returns 0. Otherwise, on success, it returns -1.
    *
    * @related EditorDocument.insertLines
    **/
    private moveLinesDown(firstRow: number, lastRow: number): number {
        return this.$moveLines(firstRow, lastRow, 1);
    }

    /**
    * Duplicates all the text between &#x60;firstRow&#x60; and &#x60;lastRow&#x60;.
    * @param {Number} firstRow The starting row to duplicate
    * @param {Number} lastRow The final row to duplicate
    * @returns {Number} Returns the number of new rows added; in other words, &#x60;lastRow - firstRow + 1&#x60;.
    *
    *
    **/
    public duplicateLines(firstRow, lastRow) {
        return this.$moveLines(firstRow, lastRow, 0);
    }


    private $clipRowToDocument(row) {
        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
    }

    private $clipColumnToRow(row, column) {
        if (column &lt; 0)
            return 0;
        return Math.min(this.doc.getLine(row).length, column);
    }


    private $clipPositionToDocument(row: number, column: number): { row: number; column: number } {
        column = Math.max(0, column);

        if (row &lt; 0) {
            row = 0;
            column = 0;
        }
        else {
            var len = this.doc.getLength();
            if (row &gt;= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
            }
            else {
                column = Math.min(this.doc.getLine(row).length, column);
            }
        }

        return {
            row: row,
            column: column
        };
    }

    public $clipRangeToDocument(range: Range): Range {
        if (range.start.row &lt; 0) {
            range.start.row = 0;
            range.start.column = 0;
        }
        else {
            range.start.column = this.$clipColumnToRow(
                range.start.row,
                range.start.column
            );
        }

        var len = this.doc.getLength() - 1;
        if (range.end.row &gt; len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
        }
        else {
            range.end.column = this.$clipColumnToRow(
                range.end.row,
                range.end.column
            );
        }
        return range;
    }

    /**
     * Sets whether or not line wrapping is enabled. If &#x60;useWrapMode&#x60; is different than the current value, the &#x60;&#x27;changeWrapMode&#x27;&#x60; event is emitted.
     * @param {Boolean} useWrapMode Enable (or disable) wrap mode
     *
    *
    **/
    private setUseWrapMode(useWrapMode: boolean) {
        if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);

            // If wrapMode is activaed, the wrapData array has to be initialized.
            if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array&lt;number[]&gt;(len);
                this.$updateWrapData(0, len - 1);
            }

            this._signal(&quot;changeWrapMode&quot;);
        }
    }

    /**
    * Returns &#x60;true&#x60; if wrap mode is being used; &#x60;false&#x60; otherwise.
    * @returns {Boolean}
    **/
    getUseWrapMode() {
        return this.$useWrapMode;
    }

    // Allow the wrap limit to move freely between min and max. Either
    // parameter can be null to allow the wrap limit to be unconstrained
    // in that direction. Or set both parameters to the same number to pin
    // the limit to that value.
    /**
     * Sets the boundaries of wrap. Either value can be &#x60;null&#x60; to have an unconstrained wrap, or, they can be the same number to pin the limit. If the wrap limits for &#x60;min&#x60; or &#x60;max&#x60; are different, this method also emits the &#x60;&#x27;changeWrapMode&#x27;&#x60; event.
     * @param {Number} min The minimum wrap value (the left side wrap)
     * @param {Number} max The maximum wrap value (the right side wrap)
     *
    *
    **/
    setWrapLimitRange(min: number, max: number): void {
        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = {
                min: min,
                max: max
            };
            this.$modified = true;
            // This will force a recalculation of the wrap limit
            this._signal(&quot;changeWrapMode&quot;);
        }
    }

    /**
    * This should generally only be called by the renderer when a resize is detected.
    * @param {Number} desiredLimit The new wrap limit
    * @returns {Boolean}
    *
    * @private
    **/
    public adjustWrapLimit(desiredLimit: number, $printMargin: number) {
        var limits = this.$wrapLimitRange
        if (limits.max &lt; 0)
            limits = { min: $printMargin, max: $printMargin };
        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
        if (wrapLimit != this.$wrapLimit &amp;&amp; wrapLimit &gt; 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal(&quot;changeWrapLimit&quot;);
            }
            return true;
        }
        return false;
    }

    private $constrainWrapLimit(wrapLimit: number, min: number, max: number): number {
        if (min)
            wrapLimit = Math.max(min, wrapLimit);

        if (max)
            wrapLimit = Math.min(max, wrapLimit);

        return wrapLimit;
    }

    /**
    * Returns the value of wrap limit.
    * @returns {Number} The wrap limit.
    **/
    private getWrapLimit() {
        return this.$wrapLimit;
    }

    /**
     * Sets the line length for soft wrap in the editor. Lines will break
     *  at a minimum of the given length minus 20 chars and at a maximum
     *  of the given number of chars.
     * @param {number} limit The maximum line length in chars, for soft wrapping lines.
     */
    private setWrapLimit(limit) {
        this.setWrapLimitRange(limit, limit);
    }

    /**
    * Returns an object that defines the minimum and maximum of the wrap limit; it looks something like this:
    *
    *     { min: wrapLimitRange_min, max: wrapLimitRange_max }
    *
    * @returns {Object}
    **/
    private getWrapLimitRange() {
        // Avoid unexpected mutation by returning a copy
        return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
        };
    }

    private $updateInternalDataOnChange(e) {
        var useWrapMode = this.$useWrapMode;
        var len;
        var action = e.data.action;
        var firstRow = e.data.range.start.row;
        var lastRow = e.data.range.end.row;
        var start = e.data.range.start;
        var end = e.data.range.end;
        var removedFolds = null;

        if (action.indexOf(&quot;Lines&quot;) != -1) {
            if (action == &quot;insertLines&quot;) {
                lastRow = firstRow + (e.data.lines.length);
            } else {
                lastRow = firstRow;
            }
            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
        } else {
            len = lastRow - firstRow;
        }

        this.$updating = true;
        if (len != 0) {
            if (action.indexOf(&quot;remove&quot;) != -1) {
                this[useWrapMode ? &quot;$wrapData&quot; : &quot;$rowLengthCache&quot;].splice(firstRow, len);

                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                    foldLine.shiftRow(-len);

                    var foldLineBefore = this.getFoldLine(firstRow);
                    if (foldLineBefore &amp;&amp; foldLineBefore !== foldLine) {
                        foldLineBefore.merge(foldLine);
                        foldLine = foldLineBefore;
                    }
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx &lt; foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row &gt;= end.row) {
                        foldLine.shiftRow(-len);
                    }
                }

                lastRow = firstRow;
            } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache
                arr.splice.apply(arr, args);

                // If some new line is added inside of a foldLine, then split
                // the fold line up.
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                    var cmp = foldLine.range.compareInside(start.row, start.column)
                    // Inside of the foldLine range. Need to split stuff up.
                    if (cmp == 0) {
                        foldLine = foldLine.split(start.row, start.column);
                        foldLine.shiftRow(len);
                        foldLine.addRemoveChars(
                            lastRow, 0, end.column - start.column);
                    } else
                        // Infront of the foldLine but same row. Need to shift column.
                        if (cmp == -1) {
                            foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                            foldLine.shiftRow(len);
                        }
                    // Nothing to do if the insert is after the foldLine.
                    idx = foldLines.indexOf(foldLine) + 1;
                }

                for (idx; idx &lt; foldLines.length; idx++) {
                    var foldLine = foldLines[idx];
                    if (foldLine.start.row &gt;= firstRow) {
                        foldLine.shiftRow(len);
                    }
                }
            }
        } else {
            // Realign folds. E.g. if you add some new chars before a fold, the
            // fold should &quot;move&quot; to the right.
            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
            if (action.indexOf(&quot;remove&quot;) != -1) {
                // Get all the folds in the change range and remove them.
                removedFolds = this.getFoldsInRange(e.data.range);
                this.removeFolds(removedFolds);

                len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
            }
        }

        if (useWrapMode &amp;&amp; this.$wrapData.length != this.doc.getLength()) {
            console.error(&quot;doc.getLength() and $wrapData.length have to be the same!&quot;);
        }
        this.$updating = false;

        if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
        else
            this.$updateRowLengthCache(firstRow, lastRow);

        return removedFolds;
    }

    public $updateRowLengthCache(firstRow, lastRow, b?) {
        this.$rowLengthCache[firstRow] = null;
        this.$rowLengthCache[lastRow] = null;
    }

    public $updateWrapData(firstRow, lastRow) {
        var lines = this.doc.getAllLines();
        var tabSize = this.getTabSize();
        var wrapData = this.$wrapData;
        var wrapLimit = this.$wrapLimit;
        var tokens;
        var foldLine;

        var row = firstRow;
        lastRow = Math.min(lastRow, lines.length - 1);
        while (row &lt;= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
            } else {
                tokens = [];
                foldLine.walk(function(placeholder, row, column, lastColumn) {
                    var walkTokens: number[];
                    if (placeholder != null) {
                        walkTokens = this.$getDisplayTokens(
                            placeholder, tokens.length);
                        walkTokens[0] = PLACEHOLDER_START;
                        for (var i = 1; i &lt; walkTokens.length; i++) {
                            walkTokens[i] = PLACEHOLDER_BODY;
                        }
                    } else {
                        walkTokens = this.$getDisplayTokens(
                            lines[row].substring(lastColumn, column),
                            tokens.length);
                    }
                    tokens = tokens.concat(walkTokens);
                }.bind(this),
                    foldLine.end.row,
                    lines[foldLine.end.row].length + 1
                );

                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
            }
        }
    }

    private $computeWrapSplits(tokens: number[], wrapLimit: number, tabSize?: number) {
        if (tokens.length == 0) {
            return [];
        }

        var splits: number[] = [];
        var displayLength = tokens.length;
        var lastSplit = 0, lastDocSplit = 0;

        var isCode = this.$wrapAsCode;

        function addSplit(screenPos: number) {
            var displayed = tokens.slice(lastSplit, screenPos);

            // The document size is the current size - the extra width for tabs
            // and multipleWidth characters.
            var len = displayed.length;
            displayed.join(&quot;&quot;).
                // Get all the TAB_SPACEs.
                replace(/12/g, function() {
                    len -= 1;
                    return void 0;
                }).
                // Get all the CHAR_EXT/multipleWidth characters.
                replace(/2/g, function() {
                    len -= 1;
                    return void 0;
                });

            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
        }

        while (displayLength - lastSplit &gt; wrapLimit) {
            // This is, where the split should be.
            var split = lastSplit + wrapLimit;

            // If there is a space or tab at this split position, then making
            // a split is simple.
            if (tokens[split - 1] &gt;= SPACE &amp;&amp; tokens[split] &gt;= SPACE) {
                /* disabled see https://github.com/ajaxorg/ace/issues/1186
                // Include all following spaces + tabs in this split as well.
                while (tokens[split] &gt;= SPACE) {
                    split ++;
                } */
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Check if split is inside of a placeholder. Placeholder are
            // not splitable. Therefore, seek the beginning of the placeholder
            // and try to place the split beofre the placeholder&#x27;s start.
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                // Seek the start of the placeholder and do the split
                // before the placeholder. By definition there always
                // a PLACEHOLDER_START between split and lastSplit.
                for (split; split != lastSplit - 1; split--) {
                    if (tokens[split] == PLACEHOLDER_START) {
                        // split++; &lt;&lt; No incremental here as we want to
                        //  have the position before the Placeholder.
                        break;
                    }
                }

                // If the PLACEHOLDER_START is not the index of the
                // last split, then we can do the split
                if (split &gt; lastSplit) {
                    addSplit(split);
                    continue;
                }

                // If the PLACEHOLDER_START IS the index of the last
                // split, then we have to place the split after the
                // placeholder. So, let&#x27;s seek for the end of the placeholder.
                split = lastSplit + wrapLimit;
                for (split; split &lt; tokens.length; split++) {
                    if (tokens[split] != PLACEHOLDER_BODY) {
                        break;
                    }
                }

                // If spilt == tokens.length, then the placeholder is the last
                // thing in the line and adding a new split doesn&#x27;t make sense.
                if (split == tokens.length) {
                    break;  // Breaks the while-loop.
                }

                // Finally, add the split...
                addSplit(split);
                continue;
            }

            // === ELSE ===
            // Search for the first non space/tab/placeholder/punctuation token backwards.
            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit - (wrapLimit &gt;&gt; 2)), lastSplit - 1);
            while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                split--;
            }
            if (isCode) {
                while (split &gt; minSplit &amp;&amp; tokens[split] &lt; PLACEHOLDER_START) {
                    split--;
                }
                while (split &gt; minSplit &amp;&amp; tokens[split] == PUNCTUATION) {
                    split--;
                }
            } else {
                while (split &gt; minSplit &amp;&amp; tokens[split] &lt; SPACE) {
                    split--;
                }
            }
            // If we found one, then add the split.
            if (split &gt; minSplit) {
                addSplit(++split);
                continue;
            }

            // === ELSE ===
            split = lastSplit + wrapLimit;
            // The split is inside of a CHAR or CHAR_EXT token and no space
            // around -&gt; force a split.
            addSplit(split);
        }
        return splits;
    }

    /**
    * Given a string, returns an array of the display characters, including tabs and spaces.
    * @param {String} str The string to check
    * @param {Number} offset The value to start at
    *
    *
    **/
    private $getDisplayTokens(str: string, offset?: number): number[] {
        var arr: number[] = [];
        var tabSize: number;
        offset = offset || 0;

        for (var i = 0; i &lt; str.length; i++) {
            var c = str.charCodeAt(i);
            // Tab
            if (c == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n &lt; tabSize; n++) {
                    arr.push(TAB_SPACE);
                }
            }
            // Space
            else if (c == 32) {
                arr.push(SPACE);
            }
            else if ((c &gt; 39 &amp;&amp; c &lt; 48) || (c &gt; 57 &amp;&amp; c &lt; 64)) {
                arr.push(PUNCTUATION);
            }
            // full width characters
            else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                arr.push(CHAR, CHAR_EXT);
            }
            else {
                arr.push(CHAR);
            }
        }
        return arr;
    }

    /**
     * Calculates the width of the string &#x60;str&#x60; on the screen while assuming that the string starts at the first column on the screen.
    * @param {String} str The string to calculate the screen width of
    * @param {Number} maxScreenColumn
    * @param {Number} screenColumn
    * @returns {[Number]} Returns an &#x60;int[]&#x60; array with two elements:&lt;br/&gt;
    * The first position indicates the number of columns for &#x60;str&#x60; on screen.&lt;br/&gt;
    * The second value contains the position of the document column that this function read until.
    *
    **/
    public $getStringScreenWidth(str: string, maxScreenColumn?: number, screenColumn?: number): number[] {
        if (maxScreenColumn == 0)
            return [0, 0];
        if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
        screenColumn = screenColumn || 0;

        var c: number;
        var column: number;
        for (column = 0; column &lt; str.length; column++) {
            c = str.charCodeAt(column);
            // tab
            if (c == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
            }
            // full width characters
            else if (c &gt;= 0x1100 &amp;&amp; isFullWidth(c)) {
                screenColumn += 2;
            } else {
                screenColumn += 1;
            }
            if (screenColumn &gt; maxScreenColumn) {
                break;
            }
        }

        return [screenColumn, column];
    }

    /**
    * Returns number of screenrows in a wrapped line.
    * @param {Number} row The row number to check
    *
    * @returns {Number}
    **/
    public getRowLength(row: number): number {
        if (this.lineWidgets)
            var h = this.lineWidgets[row] &amp;&amp; this.lineWidgets[row].rowCount || 0;
        else
            h = 0
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
        } else {
            return this.$wrapData[row].length + 1 + h;
        }
    }

    public getRowLineCount(row: number): number {
        if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
        }
        else {
            return this.$wrapData[row].length + 1;
        }
    }

    public getRowWrapIndent(screenRow: number) {
        if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            // FIXME: indent does not exists on number[]
            return splits.length &amp;&amp; splits[0] &lt; pos.column ? splits[&#x27;indent&#x27;] : 0;
        }
        else {
            return 0;
        }
    }

    /**
     * Returns the position (on screen) for the last character in the provided screen row.
     * @param {Number} screenRow The screen row to check
     * @returns {Number}
     *
     * @related EditSession.documentToScreenColumn
    **/
    public getScreenLastRowColumn(screenRow: number): number {
        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
        return this.documentToScreenColumn(pos.row, pos.column);
    }

    /**
    * For the given document row and column, this returns the column position of the last screen row.
    * @param {Number} docRow
    *
    * @param {Number} docColumn
    **/
    public getDocumentLastRowColumn(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.getScreenLastRowColumn(screenRow);
    }

    /**
    * For the given document row and column, this returns the document position of the last row.
    * @param {Number} docRow
    * @param {Number} docColumn
    *
    *
    **/
    public getDocumentLastRowColumnPosition(docRow, docColumn) {
        var screenRow = this.documentToScreenRow(docRow, docColumn);
        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
    }

    /**
    * For the given row, this returns the split data.
    * @returns {String}
    **/
    public getRowSplitData(row: number): number[] {
        if (!this.$useWrapMode) {
            return undefined;
        } else {
            return this.$wrapData[row];
        }
    }

    /**
     * The distance to the next tab stop at the specified screen column.
     * @methos getScreenTabSize
     * @param screenColumn {number} The screen column to check
     * @return {number}
     */
    public getScreenTabSize(screenColumn: number): number {
        return this.$tabSize - screenColumn % this.$tabSize;
    }


    public screenToDocumentRow(screenRow: number, screenColumn: number): number {
        return this.screenToDocumentPosition(screenRow, screenColumn).row;
    }


    private screenToDocumentColumn(screenRow: number, screenColumn: number): number {
        return this.screenToDocumentPosition(screenRow, screenColumn).column;
    }

    /**
    * Converts characters coordinates on the screen to characters coordinates within the document. [This takes into account code folding, word wrap, tab size, and any other visual modifications.]{: #conversionConsiderations}
    * @param {number} screenRow The screen row to check
    * @param {number} screenColumn The screen column to check
    * @returns {Object} The object returned has two properties: &#x60;row&#x60; and &#x60;column&#x60;.
    **/
    public screenToDocumentPosition(screenRow: number, screenColumn: number): { row: number; column: number } {
        if (screenRow &lt; 0) {
            return { row: 0, column: 0 };
        }

        var line;
        var docRow = 0;
        var docColumn = 0;
        var column;
        var row = 0;
        var rowLength = 0;

        var rowCache = this.$screenRowCache;
        var i = this.$getRowCacheIndex(rowCache, screenRow);
        var l = rowCache.length;
        if (l &amp;&amp; i &gt;= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow &gt; rowCache[l - 1];
        } else {
            var doCache = !l;
        }

        var maxRow = this.getLength() - 1;
        var foldLine = this.getNextFoldLine(docRow);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row &lt;= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength &gt; screenRow || docRow &gt;= maxRow) {
                break;
            } else {
                row += rowLength;
                docRow++;
                if (docRow &gt; foldStart) {
                    docRow = foldLine.end.row + 1;
                    foldLine = this.getNextFoldLine(docRow, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
            }

            if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
            }
        }

        if (foldLine &amp;&amp; foldLine.start.row &lt;= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
        } else if (row + rowLength &lt;= screenRow || docRow &gt; maxRow) {
            // clip at the end of the document
            return {
                row: maxRow,
                column: this.getLine(maxRow).length
            }
        } else {
            line = this.getLine(docRow);
            foldLine = null;
        }

        if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
                var splitIndex = Math.floor(screenRow - row);
                column = splits[splitIndex];
                if (splitIndex &gt; 0 &amp;&amp; splits.length) {
                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                    line = line.substring(docColumn);
                }
            }
        }

        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];

        // We remove one character at the end so that the docColumn
        // position returned is not associated to the next row on the screen.
        if (this.$useWrapMode &amp;&amp; docColumn &gt;= column)
            docColumn = column - 1;

        if (foldLine)
            return foldLine.idxToPosition(docColumn);

        return { row: docRow, column: docColumn };
    }

    /**
    * Converts document coordinates to screen coordinates. {:conversionConsiderations}
    * @param {Number} docRow The document row to check
    * @param {Number} docColumn The document column to check
    * @returns {Object} The object returned by this method has two properties: &#x60;row&#x60; and &#x60;column&#x60;.
    *
    * @related EditSession.screenToDocumentPosition
    **/
    public documentToScreenPosition(docRow: number, docColumn: number): { row: number; column: number } {
        var pos: { row: number; column: number };
        // Normalize the passed in arguments.
        if (typeof docColumn === &quot;undefined&quot;) {
            pos = this.$clipPositionToDocument(docRow[&#x27;row&#x27;], docRow[&#x27;column&#x27;]);
        }
        else {
            assert(typeof docRow === &#x27;number&#x27;, &quot;docRow must be a number&quot;);
            assert(typeof docColumn === &#x27;number&#x27;, &quot;docColumn must be a number&quot;);
            pos = this.$clipPositionToDocument(docRow, docColumn);
        }

        docRow = pos.row;
        docColumn = pos.column;
        assert(typeof docRow === &#x27;number&#x27;, &quot;docRow must be a number&quot;);
        assert(typeof docColumn === &#x27;number&#x27;, &quot;docColumn must be a number&quot;);

        var screenRow = 0;
        var foldStartRow = null;
        var fold = null;

        // Clamp the docRow position in case it&#x27;s inside of a folded block.
        fold = this.getFoldAt(docRow, docColumn, 1);
        if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
        }

        var rowEnd, row = 0;

        var rowCache = this.$docRowCache;
        var i = this.$getRowCacheIndex(rowCache, docRow);
        var l = rowCache.length;
        if (l &amp;&amp; i &gt;= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow &gt; rowCache[l - 1];
        }
        else {
            var doCache = !l;
        }

        var foldLine = this.getNextFoldLine(row);
        var foldStart = foldLine ? foldLine.start.row : Infinity;

        while (row &lt; docRow) {
            if (row &gt;= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd &gt; docRow)
                    break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            else {
                rowEnd = row + 1;
            }

            screenRow += this.getRowLength(row);
            row = rowEnd;

            if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
            }
        }

        // Calculate the text line that is displayed in docRow on the screen.
        var textLine = &quot;&quot;;
        // Check if the final row we want to reach is inside of a fold.
        if (foldLine &amp;&amp; row &gt;= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
        } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
        }
        // Clamp textLine if in wrapMode.
        if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length &gt;= wrapRow[screenRowOffset]) {
                    screenRow++;
                    screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
            }
        }

        return {
            row: screenRow,
            column: this.$getStringScreenWidth(textLine)[0]
        };
    }

    /**
    * For the given document row and column, returns the screen column.
    * @param {Number} docRow
    * @param {Number} docColumn
    * @returns {Number}
    *
    **/
    public documentToScreenColumn(docRow: number, docColumn: number): number {
        return this.documentToScreenPosition(docRow, docColumn).column;
    }

    /**
    * For the given document row and column, returns the screen row.
    * @param {Number} docRow
    * @param {Number} docColumn
    **/
    public documentToScreenRow(docRow: number, docColumn: number): number {
        return this.documentToScreenPosition(docRow, docColumn).row;
    }

    public documentToScreenRange(range: Range): Range {
        var screenPosStart = this.documentToScreenPosition(range.start.row, range.start.column);
        var screenPosEnd = this.documentToScreenPosition(range.end.row, range.end.column);
        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
    }

    /**
    * Returns the length of the screen.
    * @returns {Number}
    **/
    public getScreenLength(): number {
        var screenRows = 0;
        var fold: FoldLine = null;
        if (!this.$useWrapMode) {
            screenRows = this.getLength();

            // Remove the folded lines again.
            var foldData = this.$foldData;
            for (var i = 0; i &lt; foldData.length; i++) {
                fold = foldData[i];
                screenRows -= fold.end.row - fold.start.row;
            }
        }
        else {
            var lastRow = this.$wrapData.length;
            var row = 0, i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;

            while (row &lt; lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row &gt; foldStart) {
                    row = fold.end.row + 1;
                    fold = this.$foldData[i++];
                    foldStart = fold ? fold.start.row : Infinity;
                }
            }
        }

        // todo
        if (this.lineWidgets) {
            screenRows += this.$getWidgetScreenLength();
        }

        return screenRows;
    }

    /**
     * @private
     */
    public $setFontMetrics(fm: FontMetrics) {
        // TODO?
    }

    findMatchingBracket(position: { row: number; column: number }, chr?: string): { row: number; column: number } {
        return this.$bracketMatcher.findMatchingBracket(position, chr);
    }

    getBracketRange(position: { row: number; column: number }): Range {
        return this.$bracketMatcher.getBracketRange(position);
    }

    $findOpeningBracket(bracket: string, position: { row: number; column: number }, typeRe?: RegExp): { row: number; column: number } {
        return this.$bracketMatcher.$findOpeningBracket(bracket, position, typeRe);
    }

    $findClosingBracket(bracket: string, position: { row: number; column: number }, typeRe?: RegExp): { row: number; column: number } {
        return this.$bracketMatcher.$findClosingBracket(bracket, position, typeRe);
    }
    private $foldMode;

    // structured folding
    $foldStyles = {
        &quot;manual&quot;: 1,
        &quot;markbegin&quot;: 1,
        &quot;markbeginend&quot;: 1
    }
    $foldStyle = &quot;markbegin&quot;;
    /*
     * Looks up a fold at a given row/column. Possible values for side:
     *   -1: ignore a fold if fold.start = row/column
     *   +1: ignore a fold if fold.end = row/column
     */
    getFoldAt(row: number, column: number, side?: number): Fold {
        var foldLine = this.getFoldLine(row);
        if (!foldLine)
            return null;

        var folds = foldLine.folds;
        for (var i = 0; i &lt; folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
                if (side === 1 &amp;&amp; fold.range.isEnd(row, column)) {
                    continue;
                } else if (side === -1 &amp;&amp; fold.range.isStart(row, column)) {
                    continue;
                }
                return fold;
            }
        }
    }

    /*
     * Returns all folds in the given range. Note, that this will return folds
     *
     */
    getFoldsInRange(range: Range): Fold[] {
        var start = range.start;
        var end = range.end;
        var foldLines = this.$foldData;
        var foundFolds: Fold[] = [];

        start.column += 1;
        end.column -= 1;

        for (var i = 0; i &lt; foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
                // Range is before foldLine. No intersection. This means,
                // there might be other foldLines that intersect.
                continue;
            }
            else if (cmp == -2) {
                // Range is after foldLine. There can&#x27;t be any other foldLines then,
                // so let&#x27;s give up.
                break;
            }

            var folds = foldLines[i].folds;
            for (var j = 0; j &lt; folds.length; j++) {
                var fold = folds[j];
                cmp = fold.range.compareRange(range);
                if (cmp == -2) {
                    break;
                } else if (cmp == 2) {
                    continue;
                } else
                    // WTF-state: Can happen due to -1/+1 to start/end column.
                    if (cmp == 42) {
                        break;
                    }
                foundFolds.push(fold);
            }
        }
        start.column -= 1;
        end.column += 1;

        return foundFolds;
    }

    getFoldsInRangeList(ranges): Fold[] {
        if (Array.isArray(ranges)) {
            var folds: Fold[] = [];
            ranges.forEach(function(range) {
                folds = folds.concat(this.getFoldsInRange(range));
            }, this);
        }
        else {
            var folds = this.getFoldsInRange(ranges);
        }
        return folds;
    }
    
    /*
     * Returns all folds in the document
     */
    getAllFolds(): Fold[] {
        var folds = [];
        var foldLines = this.$foldData;

        for (var i = 0; i &lt; foldLines.length; i++)
            for (var j = 0; j &lt; foldLines[i].folds.length; j++)
                folds.push(foldLines[i].folds[j]);

        return folds;
    }

    /*
     * Returns the string between folds at the given position.
     * E.g.
     *  foo&lt;fold&gt;b|ar&lt;fold&gt;wolrd -&gt; &quot;bar&quot;
     *  foo&lt;fold&gt;bar&lt;fold&gt;wol|rd -&gt; &quot;world&quot;
     *  foo&lt;fold&gt;bar&lt;fo|ld&gt;wolrd -&gt; &lt;null&gt;
     *
     * where | means the position of row/column
     *
     * The trim option determs if the return string should be trimed according
     * to the &quot;side&quot; passed with the trim value:
     *
     * E.g.
     *  foo&lt;fold&gt;b|ar&lt;fold&gt;wolrd -trim=-1&gt; &quot;b&quot;
     *  foo&lt;fold&gt;bar&lt;fold&gt;wol|rd -trim=+1&gt; &quot;rld&quot;
     *  fo|o&lt;fold&gt;bar&lt;fold&gt;wolrd -trim=00&gt; &quot;foo&quot;
     */
    getFoldStringAt(row: number, column: number, trim: number, foldLine?: FoldLine): string {
        foldLine = foldLine || this.getFoldLine(row);
        if (!foldLine)
            return null;

        var lastFold = {
            end: { column: 0 }
        };
        // TODO: Refactor to use getNextFoldTo function.
        var str: string;
        var fold: Fold;
        for (var i = 0; i &lt; foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
                str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                break;
            }
            else if (cmp === 0) {
                return null;
            }
            lastFold = fold;
        }
        if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);

        if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
        else if (trim == 1)
            return str.substring(column - lastFold.end.column);
        else
            return str;
    }

    getFoldLine(docRow: number, startFoldLine?: FoldLine): FoldLine {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row &lt;= docRow &amp;&amp; foldLine.end.row &gt;= docRow) {
                return foldLine;
            } else if (foldLine.end.row &gt; docRow) {
                return null;
            }
        }
        return null;
    }

    // returns the fold which starts after or contains docRow
    getNextFoldLine(docRow: number, startFoldLine?: FoldLine): FoldLine {
        var foldData = this.$foldData;
        var i = 0;
        if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
        if (i == -1)
            i = 0;
        for (i; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row &gt;= docRow) {
                return foldLine;
            }
        }
        return null;
    }

    getFoldedRowCount(first: number, last: number): number {
        var foldData = this.$foldData;
        var rowCount = last - first + 1;
        for (var i = 0; i &lt; foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end &gt;= last) {
                if (start &lt; last) {
                    if (start &gt;= first)
                        rowCount -= last - start;
                    else
                        rowCount = 0;//in one fold
                }
                break;
            } else if (end &gt;= first) {
                if (start &gt;= first) //fold inside range
                    rowCount -= end - start;
                else
                    rowCount -= end - first + 1;
            }
        }
        return rowCount;
    }

    private $addFoldLine(foldLine: FoldLine) {
        this.$foldData.push(foldLine);
        this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
        });
        return foldLine;
    }

    /**
     * Adds a new fold.
     *
     * @returns
     *      The new created Fold object or an existing fold object in case the
     *      passed in range fits an existing fold exactly.
     */
    addFold(placeholder: string | Fold, range: Range): Fold {
        var foldData = this.$foldData;
        var added = false;
        var fold: Fold;

        if (placeholder instanceof Fold)
            fold = placeholder;
        else if (typeof placeholder === &#x27;string&#x27;) {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
        }
        else {
            throw new Error(&quot;placeholder must be a string or a Fold.&quot;);
        }
        // FIXME: $clipRangeToDocument?
        // fold.range = this.clipRange(fold.range);
        fold.range = this.$clipRangeToDocument(fold.range)

        var startRow = fold.start.row;
        var startColumn = fold.start.column;
        var endRow = fold.end.row;
        var endColumn = fold.end.column;

        // --- Some checking ---
        if (!(startRow &lt; endRow ||
            startRow == endRow &amp;&amp; startColumn &lt;= endColumn - 2))
            throw new Error(&quot;The range has to be at least 2 characters width&quot;);

        var startFold = this.getFoldAt(startRow, startColumn, 1);
        var endFold = this.getFoldAt(endRow, endColumn, -1);
        if (startFold &amp;&amp; endFold == startFold)
            return startFold.addSubFold(fold);

        if (
            (startFold &amp;&amp; !startFold.range.isStart(startRow, startColumn))
            || (endFold &amp;&amp; !endFold.range.isEnd(endRow, endColumn))
        ) {
            throw new Error(&quot;A fold can&#x27;t intersect already existing fold&quot; + fold.range + startFold.range);
        }

        // Check if there are folds in the range we create the new fold for.
        var folds = this.getFoldsInRange(fold.range);
        if (folds.length &gt; 0) {
            // Remove the folds from fold data.
            this.removeFolds(folds);
            // Add the removed folds as subfolds on the new fold.
            folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
            });
        }

        for (var i = 0; i &lt; foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
                foldLine.addFold(fold);
                added = true;
                break;
            } else if (startRow == foldLine.end.row) {
                foldLine.addFold(fold);
                added = true;
                if (!fold.sameRow) {
                    // Check if we might have to merge two FoldLines.
                    var foldLineNext = foldData[i + 1];
                    if (foldLineNext &amp;&amp; foldLineNext.start.row == endRow) {
                        // We need to merge!
                        foldLine.merge(foldLineNext);
                        break;
                    }
                }
                break;
            } else if (endRow &lt;= foldLine.start.row) {
                break;
            }
        }

        if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));

        if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
        else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);

        // Notify that fold data has changed.
        this.setModified(true);
        this._emit(&quot;changeFold&quot;, { data: fold, action: &quot;add&quot; });

        return fold;
    }

    setModified(modified: boolean) {

    }

    addFolds(folds: Fold[]) {
        folds.forEach(function(fold) {
            this.addFold(fold);
        }, this);
    }

    removeFold(fold: Fold): void {
        var foldLine = fold.foldLine;
        var startRow = foldLine.start.row;
        var endRow = foldLine.end.row;

        var foldLines = this.$foldData;
        var folds = foldLine.folds;
        // Simple case where there is only one fold in the FoldLine such that
        // the entire fold line can get removed directly.
        if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
        }
        else
            // If the fold is the last fold of the foldLine, just remove it.
            if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                folds.pop();
                foldLine.end.row = folds[folds.length - 1].end.row;
                foldLine.end.column = folds[folds.length - 1].end.column;
            }
            else
                // If the fold is the first fold of the foldLine, just remove it.
                if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                    folds.shift();
                    foldLine.start.row = folds[0].start.row;
                    foldLine.start.column = folds[0].start.column;
                }
                else
                    // We know there are more then 2 folds and the fold is not at the edge.
                    // This means, the fold is somewhere in between.
                    //
                    // If the fold is in one row, we just can remove it.
                    if (fold.sameRow) {
                        folds.splice(folds.indexOf(fold), 1);
                    } else
                    // The fold goes over more then one row. This means remvoing this fold
                    // will cause the fold line to get splitted up. newFoldLine is the second part
                    {
                        var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                        folds = newFoldLine.folds;
                        folds.shift();
                        newFoldLine.start.row = folds[0].start.row;
                        newFoldLine.start.column = folds[0].start.column;
                    }

        if (!this.$updating) {
            if (this.$useWrapMode)
                this.$updateWrapData(startRow, endRow);
            else
                this.$updateRowLengthCache(startRow, endRow);
        }
        
        // Notify that fold data has changed.
        this.setModified(true);
        this._emit(&quot;changeFold&quot;, { data: fold, action: &quot;remove&quot; });
    }

    removeFolds(folds: Fold[]): void {
        // We need to clone the folds array passed in as it might be the folds
        // array of a fold line and as we call this.removeFold(fold), folds
        // are removed from folds and changes the current index.
        var cloneFolds = [];
        for (var i = 0; i &lt; folds.length; i++) {
            cloneFolds.push(folds[i]);
        }

        cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
        }, this);
        this.setModified(true);
    }

    expandFold(fold: Fold): void {
        this.removeFold(fold);
        fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
        }, this);
        if (fold.collapseChildren &gt; 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
        }
        fold.subFolds = [];
    }

    expandFolds(folds: Fold[]) {
        folds.forEach(function(fold) {
            this.expandFold(fold);
        }, this);
    }

    unfold(location?: any, expandInner?: boolean): Fold[] {
        var range: Range;
        var folds: Fold[];
        if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
        } else if (typeof location == &quot;number&quot;)
            range = new Range(location, 0, location, this.getLine(location).length);
        else if (&quot;row&quot; in location)
            range = Range.fromPoints(location, location);
        else
            range = location;

        folds = this.getFoldsInRangeList(range);
        if (expandInner) {
            this.removeFolds(folds);
        } else {
            var subFolds = folds;
            // TODO: might be better to remove and add folds in one go instead of using
            // expandFolds several times.
            while (subFolds.length) {
                this.expandFolds(subFolds);
                subFolds = this.getFoldsInRangeList(range);
            }
        }
        if (folds.length)
            return folds;
    }

    /*
     * Checks if a given documentRow is folded. This is true if there are some
     * folded parts such that some parts of the line is still visible.
     **/
    isRowFolded(docRow: number, startFoldRow: FoldLine): boolean {
        return !!this.getFoldLine(docRow, startFoldRow);
    }

    getRowFoldEnd(docRow: number, startFoldRow?: FoldLine): number {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.end.row : docRow;
    }

    getRowFoldStart(docRow: number, startFoldRow?: FoldLine): number {
        var foldLine = this.getFoldLine(docRow, startFoldRow);
        return foldLine ? foldLine.start.row : docRow;
    }

    getFoldDisplayLine(foldLine: FoldLine, endRow?: number, endColumn?: number, startRow?: number, startColumn?: number): string {
        if (startRow == null)
            startRow = foldLine.start.row;
        if (startColumn == null)
            startColumn = 0;
        if (endRow == null)
            endRow = foldLine.end.row;
        if (endColumn == null)
            endColumn = this.getLine(endRow).length;
        

        // Build the textline using the FoldLine walker.
        var self = this;
        var textLine = &quot;&quot;;

        foldLine.walk(function(placeholder: string, row: number, column: number, lastColumn: number) {
            if (row &lt; startRow)
                return;
            if (row == startRow) {
                if (column &lt; startColumn)
                    return;
                lastColumn = Math.max(startColumn, lastColumn);
            }

            if (placeholder != null) {
                textLine += placeholder;
            } else {
                textLine += self.getLine(row).substring(lastColumn, column);
            }
        }, endRow, endColumn);
        return textLine;
    }

    getDisplayLine(row: number, endColumn: number, startRow: number, startColumn: number): string {
        var foldLine = this.getFoldLine(row);

        if (!foldLine) {
            var line: string;
            line = this.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
        } else {
            return this.getFoldDisplayLine(
                foldLine, row, endColumn, startRow, startColumn);
        }
    }

    private $cloneFoldData() {
        var fd = [];
        fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
                return fold.clone();
            });
            return new FoldLine(fd, folds);
        });

        return fd;
    }

    toggleFold(tryToUnfold: boolean): void {
        var selection = this.selection;
        var range: Range = selection.getRange();
        var fold: Fold;
        var bracketPos: { row: number; column: number };

        if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);

            if (fold) {
                this.expandFold(fold);
                return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                if (range.comparePoint(bracketPos) == 1) {
                    range.end = bracketPos;
                } else {
                    range.start = bracketPos;
                    range.start.column++;
                    range.end.column--;
                }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                if (range.comparePoint(bracketPos) === 1)
                    range.end = bracketPos;
                else
                    range.start = bracketPos;

                range.start.column++;
            } else {
                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
        } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold &amp;&amp; folds.length) {
                this.expandFolds(folds);
                return;
            } else if (folds.length == 1) {
                fold = folds[0];
            }
        }

        if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);

        if (fold &amp;&amp; fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
        }

        var placeholder = &quot;...&quot;;
        if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length &lt; 4)
                return;
            placeholder = placeholder.trim().substring(0, 2) + &quot;..&quot;;
        }

        this.addFold(placeholder, range);
    }

    getCommentFoldRange(row: number, column: number, dir?: number): Range {
        var iterator = new TokenIterator(this, row, column);
        var token = iterator.getCurrentToken();
        if (token &amp;&amp; /^comment|string/.test(token.type)) {
            var range = new Range(0, 0, 0, 0);
            var re = new RegExp(token.type.replace(/\..*/, &quot;\\.&quot;));
            if (dir != 1) {
                do {
                    token = iterator.stepBackward();
                } while (token &amp;&amp; re.test(token.type));
                iterator.stepForward();
            }

            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;

            iterator = new TokenIterator(this, row, column);

            if (dir != -1) {
                do {
                    token = iterator.stepForward();
                } while (token &amp;&amp; re.test(token.type));
                token = iterator.stepBackward();
            } else
                token = iterator.getCurrentToken();

            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
        }
    }

    foldAll(startRow: number, endRow: number, depth: number): void {
        if (depth == undefined)
            depth = 100000; // JSON.stringify doesn&#x27;t hanle Infinity
        var foldWidgets = this.foldWidgets;
        if (!foldWidgets)
            return; // mode doesn&#x27;t support folding
        endRow = endRow || this.getLength();
        startRow = startRow || 0;
        for (var row = startRow; row &lt; endRow; row++) {
            if (foldWidgets[row] == null)
                foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != &quot;start&quot;)
                continue;

            var range = this.getFoldWidgetRange(row);
            // sometimes range can be incompatible with existing fold
            // TODO change addFold to return null istead of throwing
            if (range &amp;&amp; range.isMultiLine()
                &amp;&amp; range.end.row &lt;= endRow
                &amp;&amp; range.start.row &gt;= startRow
            ) {
                row = range.end.row;
                try {
                    // addFold can change the range
                    var fold = this.addFold(&quot;...&quot;, range);
                    if (fold)
                        fold.collapseChildren = depth;
                } catch (e) { }
            }
        }
    }

    setFoldStyle(style: string) {
        if (!this.$foldStyles[style])
            throw new Error(&quot;invalid fold style: &quot; + style + &quot;[&quot; + Object.keys(this.$foldStyles).join(&quot;, &quot;) + &quot;]&quot;);

        if (this.$foldStyle === style)
            return;

        this.$foldStyle = style;

        if (style === &quot;manual&quot;)
            this.unfold();
        
        // reset folding
        var mode = this.$foldMode;
        this.$setFolding(null);
        this.$setFolding(mode);
    }

    private $setFolding(foldMode) {
        if (this.$foldMode == foldMode)
            return;

        this.$foldMode = foldMode;

        this.off(&#x27;change&#x27;, this.$updateFoldWidgets);
        this._emit(&quot;changeAnnotation&quot;);

        if (!foldMode || this.$foldStyle == &quot;manual&quot;) {
            this.foldWidgets = null;
            return;
        }

        this.foldWidgets = [];
        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);

        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
        this.on(&#x27;change&#x27;, this.$updateFoldWidgets);

    }

    getParentFoldRangeData(row: number, ignoreCurrent?: boolean): { range?: Range; firstRange?: Range } {
        var fw = this.foldWidgets;
        if (!fw || (ignoreCurrent &amp;&amp; fw[row])) {
            return {};
        }

        var i = row - 1;
        var firstRange: Range;
        while (i &gt;= 0) {
            var c = fw[i];
            if (c == null)
                c = fw[i] = this.getFoldWidget(i);

            if (c == &quot;start&quot;) {
                var range = this.getFoldWidgetRange(i);
                if (!firstRange)
                    firstRange = range;
                if (range &amp;&amp; range.end.row &gt;= row)
                    break;
            }
            i--;
        }

        return {
            range: i !== -1 &amp;&amp; range,
            firstRange: firstRange
        };
    }

    onFoldWidgetClick(row: number, e) {
        e = e.domEvent;
        var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
        };

        var range = this.$toggleFoldWidget(row, options);
        if (!range) {
            var el = (e.target || e.srcElement)
            if (el &amp;&amp; /ace_fold-widget/.test(el.className))
                el.className += &quot; ace_invalid&quot;;
        }
    }

    private $toggleFoldWidget(row: number, options): Range {
        if (!this.getFoldWidget)
            return;
        var type = this.getFoldWidget(row);
        var line = this.getLine(row);

        var dir = type === &quot;end&quot; ? -1 : 1;
        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);

        if (fold) {
            if (options.children || options.all)
                this.removeFold(fold);
            else
                this.expandFold(fold);
            return;
        }

        var range = this.getFoldWidgetRange(row, true);
        // sometimes singleline folds can be missed by the code above
        if (range &amp;&amp; !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold &amp;&amp; range.isEqual(fold.range)) {
                this.removeFold(fold);
                return;
            }
        }

        if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
                var startRow = data.range.start.row + 1;
                var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
        }
        else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
        }
        else if (range) {
            if (options.all) {
                // This is a bit ugly, but it corresponds to some code elsewhere.
                range.collapseChildren = 10000;
            }
            this.addFold(&quot;...&quot;, range);
        }

        return range;
    }



    toggleFoldWidget(toggleParent) {
        var row: number = this.selection.getCursor().row;
        row = this.getRowFoldStart(row);
        var range = this.$toggleFoldWidget(row, {});

        if (range)
            return;
        // handle toggleParent
        var data = this.getParentFoldRangeData(row, true);
        range = data.range || data.firstRange;

        if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);

            if (fold) {
                this.removeFold(fold);
            } else {
                this.addFold(&quot;...&quot;, range);
            }
        }
    }

    updateFoldWidgets(e: { data: { action: string; range: Range } }, editSession: EditSession): void {
        var delta = e.data;
        var range = delta.range;
        var firstRow = range.start.row;
        var len = range.end.row - firstRow;

        if (len === 0) {
            this.foldWidgets[firstRow] = null;
        }
        else if (delta.action == &quot;removeText&quot; || delta.action == &quot;removeLines&quot;) {
            this.foldWidgets.splice(firstRow, len + 1, null);
        }
        else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
        }
    }
}

// FIXME: Restore
// Folding.call(EditSession.prototype);

defineOptions(EditSession.prototype, &quot;session&quot;, {
    wrap: {
        set: function(value) {
            if (!value || value == &quot;off&quot;)
                value = false;
            else if (value == &quot;free&quot;)
                value = true;
            else if (value == &quot;printMargin&quot;)
                value = -1;
            else if (typeof value == &quot;string&quot;)
                value = parseInt(value, 10) || false;

            if (this.$wrap == value)
                return;
            if (!value) {
                this.setUseWrapMode(false);
            } else {
                var col = typeof value == &quot;number&quot; ? value : null;
                this.setWrapLimitRange(col, col);
                this.setUseWrapMode(true);
            }
            this.$wrap = value;
        },
        get: function() {
            if (this.getUseWrapMode()) {
                if (this.$wrap == -1)
                    return &quot;printMargin&quot;;
                if (!this.getWrapLimitRange().min)
                    return &quot;free&quot;;
                return this.$wrap;
            }
            return &quot;off&quot;;
        },
        handlesSet: true
    },
    wrapMethod: {
        // code|text|auto
        set: function(val) {
            val = val == &quot;auto&quot;
                ? this.$mode.type != &quot;text&quot;
                : val != &quot;text&quot;;
            if (val != this.$wrapAsCode) {
                this.$wrapAsCode = val;
                if (this.$useWrapMode) {
                    this.$modified = true;
                    this.$resetRowCache(0);
                    this.$updateWrapData(0, this.getLength() - 1);
                }
            }
        },
        initialValue: &quot;auto&quot;
    },
    firstLineNumber: {
        set: function() { this._signal(&quot;changeBreakpoint&quot;); },
        initialValue: 1
    },
    useWorker: {
        set: function(useWorker) {
            this.$useWorker = useWorker;

            this.$stopWorker();
            if (useWorker)
                this.$startWorker();
        },
        initialValue: true
    },
    useSoftTabs: { initialValue: true },
    tabSize: {
        set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize) return;

            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal(&quot;changeTabSize&quot;);
        },
        initialValue: 4,
        handlesSet: true
    },
    overwrite: {
        set: function(val) { this._signal(&quot;changeOverwrite&quot;); },
        initialValue: false
    },
    newLineMode: {
        set: function(val) { this.doc.setNewLineMode(val) },
        get: function() { return this.doc.getNewLineMode() },
        handlesSet: true
    },
    mode: {
        set: function(val) { this.setMode(val) },
        get: function() { return this.$modeId }
    }
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
