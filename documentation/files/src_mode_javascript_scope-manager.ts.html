<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/mode/javascript/scope-manager.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.15</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Anchor.html">Anchor</a></li>
                                <li><a href="../classes/BackgroundTokenizer.html">BackgroundTokenizer</a></li>
                                <li><a href="../classes/Editor.html">Editor</a></li>
                                <li><a href="../classes/EditorDocument.html">EditorDocument</a></li>
                                <li><a href="../classes/EditSession.html">EditSession</a></li>
                                <li><a href="../classes/Fold.html">Fold</a></li>
                                <li><a href="../classes/FoldLine.html">FoldLine</a></li>
                                <li><a href="../classes/GutterTooltip.html">GutterTooltip</a></li>
                                <li><a href="../classes/HScrollBar.html">HScrollBar</a></li>
                                <li><a href="../classes/HtmlMode.html">HtmlMode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Mode.html">Mode</a></li>
                                <li><a href="../classes/Position.html">Position</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ScrollBar.html">ScrollBar</a></li>
                                <li><a href="../classes/Search.html">Search</a></li>
                                <li><a href="../classes/Selection.html">Selection</a></li>
                                <li><a href="../classes/TokenIterator.html">TokenIterator</a></li>
                                <li><a href="../classes/Tokenizer.html">Tokenizer</a></li>
                                <li><a href="../classes/Tooltip.html">Tooltip</a></li>
                                <li><a href="../classes/UndoManager.html">UndoManager</a></li>
                                <li><a href="../classes/VirtualRenderer.html">VirtualRenderer</a></li>
                                <li><a href="../classes/VScrollBar.html">VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/mode/javascript/scope-manager.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

import EventEmitter from &#x27;./EventEmitter&#x27;;
import has from &quot;../../fp/has&quot;;
import sliceArgs from &quot;../../fp/sliceArgs&quot;;
import findLastIndex from &quot;../../fp/findLastIndex&quot;;

// Used to denote membership in lookup tables (a primitive value such as &#x60;true&#x60;
// would be silently rejected for the property name &quot;__proto__&quot; in some
// environments)
var marker = {};

/**
 * Creates a scope manager that handles variables and labels, storing usages
 * and resolving when variables are used and undefined
 */
export var scopeManager = function(state, predefined, exported, declared) {

    var _current;
    var _scopeStack = [];

    function _newScope(type) {
        _current = {
            &quot;(labels)&quot;: Object.create(null),
            &quot;(usages)&quot;: Object.create(null),
            &quot;(breakLabels)&quot;: Object.create(null),
            &quot;(parent)&quot;: _current,
            &quot;(type)&quot;: type,
            &quot;(params)&quot;: (type === &quot;functionparams&quot; || type === &quot;catchparams&quot;) ? [] : null
        };
        _scopeStack.push(_current);
    }

    _newScope(&quot;global&quot;);
    _current[&quot;(predefined)&quot;] = predefined;

    var _currentFunctBody = _current; // this is the block after the params = function

    var usedPredefinedAndGlobals = Object.create(null);
    var impliedGlobals = Object.create(null);
    var unuseds = [];
    var emitter = new EventEmitter();

    function warning(code: string, token, unused1?, unused2?) {
        emitter.emit(&quot;warning&quot;, {
            code: code,
            token: token,
            data: sliceArgs(arguments, 2)
        });
    }

    function error(code: string, token, unused?) {
        emitter.emit(&quot;warning&quot;, {
            code: code,
            token: token,
            data: sliceArgs(arguments, 2)
        });
    }

    function _setupUsages(labelName) {
        if (!_current[&quot;(usages)&quot;][labelName]) {
            _current[&quot;(usages)&quot;][labelName] = {
                &quot;(modified)&quot;: [],
                &quot;(reassigned)&quot;: [],
                &quot;(tokens)&quot;: []
            };
        }
    }

    var _getUnusedOption = function(unused_opt) {
        if (unused_opt === undefined) {
            unused_opt = state.option.unused;
        }

        if (unused_opt === true) {
            unused_opt = &quot;last-param&quot;;
        }

        return unused_opt;
    };

    var _warnUnused = function(name, tkn, type, unused_opt?) {
        var line = tkn.line;
        var chr = tkn.from;
        var raw_name = tkn.raw_text || name;

        unused_opt = _getUnusedOption(unused_opt);

        var warnable_types = {
            &quot;vars&quot;: [&quot;var&quot;],
            &quot;last-param&quot;: [&quot;var&quot;, &quot;param&quot;],
            &quot;strict&quot;: [&quot;var&quot;, &quot;param&quot;, &quot;last-param&quot;]
        };

        if (unused_opt) {
            if (warnable_types[unused_opt] &amp;&amp; warnable_types[unused_opt].indexOf(type) !== -1) {
                warning(&quot;W098&quot;, { line: line, from: chr }, raw_name);
            }
        }

        // inconsistent - see gh-1894
        if (unused_opt || type === &quot;var&quot;) {
            unuseds.push({
                name: name,
                line: line,
                character: chr
            });
        }
    };

    /**
     * Checks the current scope for unused identifiers
     */
    function _checkForUnused() {
        // function params are handled specially
        // assume that parameters are the only thing declared in the param scope
        if (_current[&quot;(type)&quot;] === &quot;functionparams&quot;) {
            _checkParams();
            return;
        }
        var curentLabels = _current[&quot;(labels)&quot;];
        for (var labelName in curentLabels) {
            if (curentLabels[labelName]) {
                if (curentLabels[labelName][&quot;(type)&quot;] !== &quot;exception&quot; &amp;&amp;
                    curentLabels[labelName][&quot;(unused)&quot;]) {
                    _warnUnused(labelName, curentLabels[labelName][&quot;(token)&quot;], &quot;var&quot;);
                }
            }
        }
    }

    /**
     * Checks the current scope for unused parameters
     * Must be called in a function parameter scope
     */
    function _checkParams() {
        var params = _current[&quot;(params)&quot;];

        if (!params) {
            return;
        }

        var param = params.pop();
        var unused_opt;

        while (param) {
            var label = _current[&quot;(labels)&quot;][param];

            unused_opt = _getUnusedOption(state.funct[&quot;(unusedOption)&quot;]);

            // &#x27;undefined&#x27; is a special case for (function(window, undefined) { ... })();
            // patterns.
            if (param === &quot;undefined&quot;)
                return;

            if (label[&quot;(unused)&quot;]) {
                _warnUnused(param, label[&quot;(token)&quot;], &quot;param&quot;, state.funct[&quot;(unusedOption)&quot;]);
            } else if (unused_opt === &quot;last-param&quot;) {
                return;
            }

            param = params.pop();
        }
    }

    /**
     * Finds the relevant label&#x27;s scope, searching from nearest outwards
     * @returns {Object} the scope the label was found in
     */
    function _getLabel(labelName) {
        for (var i = _scopeStack.length - 1; i &gt;= 0; --i) {
            var scopeLabels = _scopeStack[i][&quot;(labels)&quot;];
            if (scopeLabels[labelName]) {
                return scopeLabels;
            }
        }
    }

    function usedSoFarInCurrentFunction(labelName) {
        // used so far in this whole function and any sub functions
        for (var i = _scopeStack.length - 1; i &gt;= 0; i--) {
            var current = _scopeStack[i];
            if (current[&quot;(usages)&quot;][labelName]) {
                return current[&quot;(usages)&quot;][labelName];
            }
            if (current === _currentFunctBody) {
                break;
            }
        }
        return false;
    }

    function _checkOuterShadow(labelName, token, unused?) {

        // only check if shadow is outer
        if (state.option.shadow !== &quot;outer&quot;) {
            return;
        }

        var isGlobal = _currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;,
            isNewFunction = _current[&quot;(type)&quot;] === &quot;functionparams&quot;;

        var outsideCurrentFunction = !isGlobal;
        for (var i = 0; i &lt; _scopeStack.length; i++) {
            var stackItem = _scopeStack[i];

            if (!isNewFunction &amp;&amp; _scopeStack[i + 1] === _currentFunctBody) {
                outsideCurrentFunction = false;
            }
            if (outsideCurrentFunction &amp;&amp; stackItem[&quot;(labels)&quot;][labelName]) {
                warning(&quot;W123&quot;, token, labelName);
            }
            if (stackItem[&quot;(breakLabels)&quot;][labelName]) {
                warning(&quot;W123&quot;, token, labelName);
            }
        }
    }

    function _latedefWarning(type, labelName, token) {
        if (state.option.latedef) {
            // if either latedef is strict and this is a function
            //    or this is not a function
            if ((state.option.latedef === true &amp;&amp; type === &quot;function&quot;) ||
                type !== &quot;function&quot;) {
                warning(&quot;W003&quot;, token, labelName);
            }
        }
    }

    var scopeManagerInst = {

        on: function(names, listener) {
            names.split(&quot; &quot;).forEach(function(name) {
                emitter.on(name, listener);
            });
        },

        isPredefined: function(labelName) {
            return !this.has(labelName) &amp;&amp; has(_scopeStack[0][&quot;(predefined)&quot;], labelName);
        },

        /**
         * Tell the manager we are entering a new block of code
         * @param {string} [type] - The type of the block. Valid values are
         *                          &quot;functionparams&quot;, &quot;catchparams&quot; and
         *                          &quot;functionouter&quot;
         */
        stack: function(type) {
            var previousScope = _current;
            _newScope(type);

            if (!type &amp;&amp; previousScope[&quot;(type)&quot;] === &quot;functionparams&quot;) {

                _current[&quot;(isFuncBody)&quot;] = true;
                _current[&quot;(context)&quot;] = _currentFunctBody;
                _currentFunctBody = _current;
            }
        },

        unstack: function() {
            // jshint proto: true
            var subScope = _scopeStack.length &gt; 1 ? _scopeStack[_scopeStack.length - 2] : null;
            var isUnstackingFunctionBody = _current === _currentFunctBody,
                isUnstackingFunctionParams = _current[&quot;(type)&quot;] === &quot;functionparams&quot;,
                isUnstackingFunctionOuter = _current[&quot;(type)&quot;] === &quot;functionouter&quot;;

            var i, j;
            var currentUsages = _current[&quot;(usages)&quot;];
            var currentLabels = _current[&quot;(labels)&quot;];
            var usedLabelNameList = Object.keys(currentUsages);

            if (currentUsages.__proto__ &amp;&amp; usedLabelNameList.indexOf(&quot;__proto__&quot;) === -1) {
                usedLabelNameList.push(&quot;__proto__&quot;);
            }

            for (i = 0; i &lt; usedLabelNameList.length; i++) {
                var usedLabelName = usedLabelNameList[i];

                var usage = currentUsages[usedLabelName];
                var usedLabel = currentLabels[usedLabelName];
                if (usedLabel) {
                    var usedLabelType = usedLabel[&quot;(type)&quot;];

                    if (usedLabel[&quot;(useOutsideOfScope)&quot;] &amp;&amp; !state.option.funcscope) {
                        var usedTokens = usage[&quot;(tokens)&quot;];
                        if (usedTokens) {
                            for (j = 0; j &lt; usedTokens.length; j++) {
                                // Keep the consistency of https://github.com/jshint/jshint/issues/2409
                                if (usedLabel[&quot;(function)&quot;] === usedTokens[j][&quot;(function)&quot;]) {
                                    error(&quot;W038&quot;, usedTokens[j], usedLabelName);
                                }
                            }
                        }
                    }

                    // mark the label used
                    _current[&quot;(labels)&quot;][usedLabelName][&quot;(unused)&quot;] = false;

                    // check for modifying a const
                    if (usedLabelType === &quot;const&quot; &amp;&amp; usage[&quot;(modified)&quot;]) {
                        for (j = 0; j &lt; usage[&quot;(modified)&quot;].length; j++) {
                            error(&quot;E013&quot;, usage[&quot;(modified)&quot;][j], usedLabelName);
                        }
                    }

                    // check for re-assigning a function declaration
                    if ((usedLabelType === &quot;function&quot; || usedLabelType === &quot;class&quot;) &amp;&amp;
                        usage[&quot;(reassigned)&quot;]) {
                        for (j = 0; j &lt; usage[&quot;(reassigned)&quot;].length; j++) {
                            if (!usage[&quot;(reassigned)&quot;][j].ignoreW021) {
                                warning(&quot;W021&quot;, usage[&quot;(reassigned)&quot;][j], usedLabelName, usedLabelType);
                            }
                        }
                    }
                    continue;
                }

                if (isUnstackingFunctionOuter) {
                    state.funct[&quot;(isCapturing)&quot;] = true;
                }

                if (subScope) {
                    // not exiting the global scope, so copy the usage down in case its an out of scope usage
                    if (!subScope[&quot;(usages)&quot;][usedLabelName]) {
                        subScope[&quot;(usages)&quot;][usedLabelName] = usage;
                        if (isUnstackingFunctionBody) {
                            subScope[&quot;(usages)&quot;][usedLabelName][&quot;(onlyUsedSubFunction)&quot;] = true;
                        }
                    } else {
                        var subScopeUsage = subScope[&quot;(usages)&quot;][usedLabelName];
                        subScopeUsage[&quot;(modified)&quot;] = subScopeUsage[&quot;(modified)&quot;].concat(usage[&quot;(modified)&quot;]);
                        subScopeUsage[&quot;(tokens)&quot;] = subScopeUsage[&quot;(tokens)&quot;].concat(usage[&quot;(tokens)&quot;]);
                        subScopeUsage[&quot;(reassigned)&quot;] =
                            subScopeUsage[&quot;(reassigned)&quot;].concat(usage[&quot;(reassigned)&quot;]);
                        subScopeUsage[&quot;(onlyUsedSubFunction)&quot;] = false;
                    }
                } else {
                    // this is exiting global scope, so we finalise everything here - we are at the end of the file
                    if (typeof _current[&quot;(predefined)&quot;][usedLabelName] === &quot;boolean&quot;) {

                        // remove the declared token, so we know it is used
                        delete declared[usedLabelName];

                        // note it as used so it can be reported
                        usedPredefinedAndGlobals[usedLabelName] = marker;

                        // check for re-assigning a read-only (set to false) predefined
                        if (_current[&quot;(predefined)&quot;][usedLabelName] === false &amp;&amp; usage[&quot;(reassigned)&quot;]) {
                            for (j = 0; j &lt; usage[&quot;(reassigned)&quot;].length; j++) {
                                if (!usage[&quot;(reassigned)&quot;][j].ignoreW020) {
                                    warning(&quot;W020&quot;, usage[&quot;(reassigned)&quot;][j]);
                                }
                            }
                        }
                    }
                    else {
                        // label usage is not predefined and we have not found a declaration
                        // so report as undeclared
                        if (usage[&quot;(tokens)&quot;]) {
                            for (j = 0; j &lt; usage[&quot;(tokens)&quot;].length; j++) {
                                var undefinedToken = usage[&quot;(tokens)&quot;][j];
                                // if its not a forgiven undefined (e.g. typof x)
                                if (!undefinedToken.forgiveUndef) {
                                    // if undef is on and undef was on when the token was defined
                                    if (state.option.undef &amp;&amp; !undefinedToken.ignoreUndef) {
                                        warning(&quot;W117&quot;, undefinedToken, usedLabelName);
                                    }
                                    if (impliedGlobals[usedLabelName]) {
                                        impliedGlobals[usedLabelName].line.push(undefinedToken.line);
                                    } else {
                                        impliedGlobals[usedLabelName] = {
                                            name: usedLabelName,
                                            line: [undefinedToken.line]
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // if exiting the global scope, we can warn about declared globals that haven&#x27;t been used yet
            if (!subScope) {
                Object.keys(declared)
                    .forEach(function(labelNotUsed) {
                        _warnUnused(labelNotUsed, declared[labelNotUsed], &quot;var&quot;);
                    });
            }

            // If this is not a function boundary, transfer function-scoped labels to
            // the parent block (a rough simulation of variable hoisting). Previously
            // existing labels in the parent block should take precedence so that things and stuff.
            if (subScope &amp;&amp; !isUnstackingFunctionBody &amp;&amp;
                !isUnstackingFunctionParams &amp;&amp; !isUnstackingFunctionOuter) {
                var labelNames = Object.keys(currentLabels);
                for (i = 0; i &lt; labelNames.length; i++) {

                    var defLabelName = labelNames[i];
                    var defLabel = currentLabels[defLabelName];

                    if (!defLabel[&quot;(blockscoped)&quot;] &amp;&amp; defLabel[&quot;(type)&quot;] !== &quot;exception&quot;) {
                        var shadowed = subScope[&quot;(labels)&quot;][defLabelName];

                        // Do not overwrite a label if it exists in the parent scope
                        // because it is shared by adjacent blocks. Copy the &#x60;unused&#x60;
                        // property so that any references found within the current block
                        // are counted toward that higher-level declaration.
                        if (shadowed) {
                            shadowed[&quot;(unused)&quot;] &amp;= defLabel[&quot;(unused)&quot;];

                            // &quot;Hoist&quot; the variable to the parent block, decorating the label
                            // so that future references, though technically valid, can be
                            // reported as &quot;out-of-scope&quot; in the absence of the &#x60;funcscope&#x60;
                            // option.
                        } else {
                            defLabel[&quot;(useOutsideOfScope)&quot;] =
                                // Do not warn about out-of-scope usages in the global scope
                                _currentFunctBody[&quot;(type)&quot;] !== &quot;global&quot; &amp;&amp;
                                // When a higher scope contains a binding for the label, the
                                // label is a re-declaration and should not prompt &quot;used
                                // out-of-scope&quot; warnings.
                                !this.funct.has(defLabelName, { excludeCurrent: true });

                            subScope[&quot;(labels)&quot;][defLabelName] = defLabel;
                        }

                        delete currentLabels[defLabelName];
                    }
                }
            }

            _checkForUnused();

            _scopeStack.pop();
            if (isUnstackingFunctionBody) {
                _currentFunctBody = _scopeStack[findLastIndex(_scopeStack, function(scope) {
                    // if function or if global (which is at the bottom so it will only return true if we call back)
                    return scope[&quot;(isFuncBody)&quot;] || scope[&quot;(type)&quot;] === &quot;global&quot;;
                })];
            }

            _current = subScope;
        },

        /**
         * Add a param to the current scope
         * @param {string} labelName
         * @param {Token} token
         * @param {string} [type=&quot;param&quot;] param type
         */
        addParam: function(labelName, token, type) {
            type = type || &quot;param&quot;;

            if (type === &quot;exception&quot;) {
                // if defined in the current function
                var previouslyDefinedLabelType = this.funct.labeltype(labelName);
                if (previouslyDefinedLabelType &amp;&amp; previouslyDefinedLabelType !== &quot;exception&quot;) {
                    // and has not been used yet in the current function scope
                    if (!state.option.node) {
                        warning(&quot;W002&quot;, state.tokens.next, labelName);
                    }
                }
            }

            // The variable was declared in the current scope
            if (has(_current[&quot;(labels)&quot;], labelName)) {
                _current[&quot;(labels)&quot;][labelName].duplicated = true;

                // The variable was declared in an outer scope
            } else {
                // if this scope has the variable defined, it&#x27;s a re-definition error
                _checkOuterShadow(labelName, token, type);

                _current[&quot;(labels)&quot;][labelName] = {
                    &quot;(type)&quot;: type,
                    &quot;(token)&quot;: token,
                    &quot;(unused)&quot;: true
                };

                _current[&quot;(params)&quot;].push(labelName);
            }

            if (has(_current[&quot;(usages)&quot;], labelName)) {
                var usage = _current[&quot;(usages)&quot;][labelName];
                // if its in a sub function it is not necessarily an error, just latedef
                if (usage[&quot;(onlyUsedSubFunction)&quot;]) {
                    _latedefWarning(type, labelName, token);
                } else {
                    // this is a clear illegal usage for block scoped variables
                    warning(&quot;E056&quot;, token, labelName, type);
                }
            }
        },

        validateParams: function() {
            // This method only concerns errors for function parameters
            if (_currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;) {
                return;
            }

            var isStrict = state.isStrict();
            var currentFunctParamScope = _currentFunctBody[&quot;(parent)&quot;];

            if (!currentFunctParamScope[&quot;(params)&quot;]) {
                return;
            }

            currentFunctParamScope[&quot;(params)&quot;].forEach(function(labelName) {
                var label = currentFunctParamScope[&quot;(labels)&quot;][labelName];

                if (label &amp;&amp; label.duplicated) {
                    if (isStrict) {
                        warning(&quot;E011&quot;, label[&quot;(token)&quot;], labelName);
                    } else if (state.option.shadow !== true) {
                        warning(&quot;W004&quot;, label[&quot;(token)&quot;], labelName);
                    }
                }
            });
        },

        getUsedOrDefinedGlobals: function() {
            // jshint proto: true
            var list = Object.keys(usedPredefinedAndGlobals);

            // If &#x60;__proto__&#x60; is used as a global variable name, its entry in the
            // lookup table may not be enumerated by &#x60;Object.keys&#x60; (depending on the
            // environment).
            if (usedPredefinedAndGlobals.__proto__ === marker &amp;&amp;
                list.indexOf(&quot;__proto__&quot;) === -1) {
                list.push(&quot;__proto__&quot;);
            }

            return list;
        },

        /**
         * Gets an array of implied globals
         * @returns {Array.&lt;{ name: string, line: Array.&lt;number&gt;}&gt;}
         */
        getImpliedGlobals: function() {
            // jshint proto: true
            var values = values(impliedGlobals);
            var hasProto = false;

            // If &#x60;__proto__&#x60; is an implied global variable, its entry in the lookup
            // table may not be enumerated by &#x60;_.values&#x60; (depending on the
            // environment).
            if (impliedGlobals.__proto__) {
                hasProto = values.some(function(value) {
                    return value.name === &quot;__proto__&quot;;
                });

                if (!hasProto) {
                    values.push(impliedGlobals.__proto__);
                }
            }

            return values;
        },

        /**
         * Returns a list of unused variables
         * @returns {Array}
         */
        getUnuseds: function() {
            return unuseds;
        },

        has: function(labelName, unused?) {
            return Boolean(_getLabel(labelName));
        },

        labeltype: function(labelName) {
            // returns a labels type or null if not present
            var scopeLabels = _getLabel(labelName);
            if (scopeLabels) {
                return scopeLabels[labelName][&quot;(type)&quot;];
            }
            return null;
        },

        /**
         * for the exported options, indicating a variable is used outside the file
         */
        addExported: function(labelName) {
            var globalLabels = _scopeStack[0][&quot;(labels)&quot;];
            if (has(declared, labelName)) {
                // remove the declared token, so we know it is used
                delete declared[labelName];
            } else if (has(globalLabels, labelName)) {
                globalLabels[labelName][&quot;(unused)&quot;] = false;
            } else {
                for (var i = 1; i &lt; _scopeStack.length; i++) {
                    var scope = _scopeStack[i];
                    // if &#x60;scope.(type)&#x60; is not defined, it is a block scope
                    if (!scope[&quot;(type)&quot;]) {
                        if (has(scope[&quot;(labels)&quot;], labelName) &amp;&amp;
                            !scope[&quot;(labels)&quot;][labelName][&quot;(blockscoped)&quot;]) {
                            scope[&quot;(labels)&quot;][labelName][&quot;(unused)&quot;] = false;
                            return;
                        }
                    } else {
                        break;
                    }
                }
                exported[labelName] = true;
            }
        },

        /**
         * Mark an indentifier as es6 module exported
         */
        setExported: function(labelName, token) {
            this.block.use(labelName, token);
        },

        /**
         * adds an indentifier to the relevant current scope and creates warnings/errors as necessary
         * @param {string} labelName
         * @param {Object} opts
         * @param {String} opts.type - the type of the label e.g. &quot;param&quot;, &quot;var&quot;, &quot;let, &quot;const&quot;, &quot;function&quot;
         * @param {Token} opts.token - the token pointing at the declaration
         */
        addlabel: function(labelName, opts) {

            var type = opts.type;
            var token = opts.token;
            var isblockscoped = type === &quot;let&quot; || type === &quot;const&quot; || type === &quot;class&quot;;
            var isexported = (isblockscoped ? _current : _currentFunctBody)[&quot;(type)&quot;] === &quot;global&quot; &amp;&amp;
                has(exported, labelName);

            // outer shadow check (inner is only on non-block scoped)
            _checkOuterShadow(labelName, token, type);

            // if is block scoped (let or const)
            if (isblockscoped) {

                var declaredInCurrentScope = _current[&quot;(labels)&quot;][labelName];
                // for block scoped variables, params are seen in the current scope as the root function
                // scope, so check these too.
                if (!declaredInCurrentScope &amp;&amp; _current === _currentFunctBody &amp;&amp;
                    _current[&quot;(type)&quot;] !== &quot;global&quot;) {
                    declaredInCurrentScope = !!_currentFunctBody[&quot;(parent)&quot;][&quot;(labels)&quot;][labelName];
                }

                // if its not already defined (which is an error, so ignore) and is used in TDZ
                if (!declaredInCurrentScope &amp;&amp; _current[&quot;(usages)&quot;][labelName]) {
                    var usage = _current[&quot;(usages)&quot;][labelName];
                    // if its in a sub function it is not necessarily an error, just latedef
                    if (usage[&quot;(onlyUsedSubFunction)&quot;]) {
                        _latedefWarning(type, labelName, token);
                    } else {
                        // this is a clear illegal usage for block scoped variables
                        warning(&quot;E056&quot;, token, labelName, type);
                    }
                }

                // if this scope has the variable defined, its a re-definition error
                if (declaredInCurrentScope) {
                    warning(&quot;E011&quot;, token, labelName);
                }
                else if (state.option.shadow === &quot;outer&quot;) {

                    // if shadow is outer, for block scope we want to detect any shadowing within this function
                    if (scopeManagerInst.funct.has(labelName)) {
                        warning(&quot;W004&quot;, token, labelName);
                    }
                }

                scopeManagerInst.block.add(labelName, type, token, !isexported);

            } else {

                var declaredInCurrentFunctionScope = scopeManagerInst.funct.has(labelName);

                // check for late definition, ignore if already declared
                if (!declaredInCurrentFunctionScope &amp;&amp; usedSoFarInCurrentFunction(labelName)) {
                    _latedefWarning(type, labelName, token);
                }

                // defining with a var or a function when a block scope variable of the same name
                // is in scope is an error
                if (scopeManagerInst.funct.has(labelName, { onlyBlockscoped: true })) {
                    warning(&quot;E011&quot;, token, labelName);
                } else if (state.option.shadow !== true) {
                    // now since we didn&#x27;t get any block scope variables, test for var/function
                    // shadowing
                    if (declaredInCurrentFunctionScope &amp;&amp; labelName !== &quot;__proto__&quot;) {

                        // see https://github.com/jshint/jshint/issues/2400
                        if (_currentFunctBody[&quot;(type)&quot;] !== &quot;global&quot;) {
                            warning(&quot;W004&quot;, token, labelName);
                        }
                    }
                }

                scopeManagerInst.funct.add(labelName, type, token, !isexported);

                if (_currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;) {
                    usedPredefinedAndGlobals[labelName] = marker;
                }
            }
        },

        funct: {
            /**
             * Returns the label type given certain options
             * @param labelName
             * @param {Object=} options
             * @param {Boolean=} options.onlyBlockscoped - only include block scoped labels
             * @param {Boolean=} options.excludeParams - exclude the param scope
             * @param {Boolean=} options.excludeCurrent - exclude the current scope
             * @returns {String}
             */
            labeltype: function(labelName, options) {
                var onlyBlockscoped = options &amp;&amp; options.onlyBlockscoped;
                var excludeParams = options &amp;&amp; options.excludeParams;
                var currentScopeIndex = _scopeStack.length - (options &amp;&amp; options.excludeCurrent ? 2 : 1);
                for (var i = currentScopeIndex; i &gt;= 0; i--) {
                    var current = _scopeStack[i];
                    if (current[&quot;(labels)&quot;][labelName] &amp;&amp;
                        (!onlyBlockscoped || current[&quot;(labels)&quot;][labelName][&quot;(blockscoped)&quot;])) {
                        return current[&quot;(labels)&quot;][labelName][&quot;(type)&quot;];
                    }
                    var scopeCheck = excludeParams ? _scopeStack[i - 1] : current;
                    if (scopeCheck &amp;&amp; scopeCheck[&quot;(type)&quot;] === &quot;functionparams&quot;) {
                        return null;
                    }
                }
                return null;
            },
            /**
             * Returns if a break label exists in the function scope
             * @param {string} labelName
             * @returns {boolean}
             */
            hasBreakLabel: function(labelName) {
                for (var i = _scopeStack.length - 1; i &gt;= 0; i--) {
                    var current = _scopeStack[i];

                    if (current[&quot;(breakLabels)&quot;][labelName]) {
                        return true;
                    }
                    if (current[&quot;(type)&quot;] === &quot;functionparams&quot;) {
                        return false;
                    }
                }
                return false;
            },
            /**
             * Returns if the label is in the current function scope
             * See scopeManager.funct.labelType for options
             */
            has: function(labelName: string, options?) {
                return Boolean(this.labeltype(labelName, options));
            },

            /**
             * Adds a new function scoped variable
             * see block.add for block scoped
             */
            add: function(labelName, type, tok, unused) {
                _current[&quot;(labels)&quot;][labelName] = {
                    &quot;(type)&quot;: type,
                    &quot;(token)&quot;: tok,
                    &quot;(blockscoped)&quot;: false,
                    &quot;(function)&quot;: _currentFunctBody,
                    &quot;(unused)&quot;: unused
                };
            }
        },

        block: {

            /**
             * is the current block global?
             * @returns Boolean
             */
            isGlobal: function() {
                return _current[&quot;(type)&quot;] === &quot;global&quot;;
            },

            use: function(labelName, token) {

                // if resolves to current function params, then do not store usage just resolve
                // this is because function(a) { var a; a = a; } will resolve to the param, not
                // to the unset var
                // first check the param is used
                var paramScope = _currentFunctBody[&quot;(parent)&quot;];
                if (paramScope &amp;&amp; paramScope[&quot;(labels)&quot;][labelName] &amp;&amp;
                    paramScope[&quot;(labels)&quot;][labelName][&quot;(type)&quot;] === &quot;param&quot;) {

                    // then check its not declared by a block scope variable
                    if (!scopeManagerInst.funct.has(labelName,
                        { excludeParams: true, onlyBlockscoped: true })) {
                        paramScope[&quot;(labels)&quot;][labelName][&quot;(unused)&quot;] = false;
                    }
                }

                if (token &amp;&amp; (state.ignored.W117 || state.option.undef === false)) {
                    token.ignoreUndef = true;
                }

                _setupUsages(labelName);

                if (token) {
                    token[&quot;(function)&quot;] = _currentFunctBody;
                    _current[&quot;(usages)&quot;][labelName][&quot;(tokens)&quot;].push(token);
                }
            },

            reassign: function(labelName, token) {
                token.ignoreW020 = state.ignored.W020;
                token.ignoreW021 = state.ignored.W021;

                this.modify(labelName, token);

                _current[&quot;(usages)&quot;][labelName][&quot;(reassigned)&quot;].push(token);
            },

            modify: function(labelName, token) {

                _setupUsages(labelName);

                _current[&quot;(usages)&quot;][labelName][&quot;(modified)&quot;].push(token);
            },

            /**
             * Adds a new variable
             */
            add: function(labelName, type, tok, unused) {
                _current[&quot;(labels)&quot;][labelName] = {
                    &quot;(type)&quot;: type,
                    &quot;(token)&quot;: tok,
                    &quot;(blockscoped)&quot;: true,
                    &quot;(unused)&quot;: unused
                };
            },

            addBreakLabel: function(labelName, opts) {
                var token = opts.token;
                if (scopeManagerInst.funct.hasBreakLabel(labelName)) {
                    warning(&quot;E011&quot;, token, labelName);
                }
                else if (state.option.shadow === &quot;outer&quot;) {
                    if (scopeManagerInst.funct.has(labelName)) {
                        warning(&quot;W004&quot;, token, labelName);
                    } else {
                        _checkOuterShadow(labelName, token);
                    }
                }
                _current[&quot;(breakLabels)&quot;][labelName] = token;
            }
        }
    };
    return scopeManagerInst;
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
