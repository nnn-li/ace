<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Editor.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.16</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Anchor.html">Anchor</a></li>
                                <li><a href="../classes/BackgroundTokenizer.html">BackgroundTokenizer</a></li>
                                <li><a href="../classes/Editor.html">Editor</a></li>
                                <li><a href="../classes/EditorDocument.html">EditorDocument</a></li>
                                <li><a href="../classes/EditSession.html">EditSession</a></li>
                                <li><a href="../classes/Fold.html">Fold</a></li>
                                <li><a href="../classes/FoldLine.html">FoldLine</a></li>
                                <li><a href="../classes/GutterTooltip.html">GutterTooltip</a></li>
                                <li><a href="../classes/HScrollBar.html">HScrollBar</a></li>
                                <li><a href="../classes/HtmlMode.html">HtmlMode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Mode.html">Mode</a></li>
                                <li><a href="../classes/Position.html">Position</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ScrollBar.html">ScrollBar</a></li>
                                <li><a href="../classes/Search.html">Search</a></li>
                                <li><a href="../classes/Selection.html">Selection</a></li>
                                <li><a href="../classes/TokenIterator.html">TokenIterator</a></li>
                                <li><a href="../classes/Tokenizer.html">Tokenizer</a></li>
                                <li><a href="../classes/Tooltip.html">Tooltip</a></li>
                                <li><a href="../classes/UndoManager.html">UndoManager</a></li>
                                <li><a href="../classes/VirtualRenderer.html">VirtualRenderer</a></li>
                                <li><a href="../classes/VScrollBar.html">VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/Editor.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

//require(&quot;./lib/fixoldbrowsers&quot;);

import {mixin} from &quot;./lib/oop&quot;;
import {computedStyle, hasCssClass, setCssClass} from &quot;./lib/dom&quot;;
import {delayedCall, stringRepeat} from &quot;./lib/lang&quot;;
import {isIE, isMac, isMobile, isOldIE, isWebKit} from &quot;./lib/useragent&quot;;
import Gutter from &quot;./layer/Gutter&quot;;
import HashHandler from &quot;./keyboard/HashHandler&quot;;
import KeyBinding from &quot;./keyboard/KeyBinding&quot;;
import TextInput from &quot;./keyboard/TextInput&quot;;
import EditSession from &quot;./EditSession&quot;;
import Search from &quot;./Search&quot;;
import Range from &quot;./Range&quot;;
import CursorRange from &#x27;./CursorRange&#x27;
import EventEmitterClass from &quot;./lib/event_emitter&quot;;
import CommandManager from &quot;./commands/CommandManager&quot;;
import defaultCommands from &quot;./commands/default_commands&quot;;
import {defineOptions, loadModule, resetOptions, _signal} from &quot;./config&quot;;
import TokenIterator from &quot;./TokenIterator&quot;;
import {COMMAND_NAME_AUTO_COMPLETE} from &#x27;./editor_protocol&#x27;;
import VirtualRenderer from &#x27;./VirtualRenderer&#x27;;
import {Completer} from &quot;./autocomplete&quot;;
import Selection from &#x27;./Selection&#x27;;
import {addListener, addMouseWheelListener, addMultiMouseDownListener, capture, getButton, preventDefault, stopEvent, stopPropagation} from &quot;./lib/event&quot;;
import {touchManager} from &#x27;./touch/touch&#x27;;
import Tooltip from &quot;./Tooltip&quot;;

//var DragdropHandler = require(&quot;./mouse/dragdrop_handler&quot;).DragdropHandler;

/**
 * The &#x60;Editor&#x60; acts as a controller, mediating between the editSession and renderer.
 *
 * @class Editor
 * @extends EventEmitterClass
 */
export default class Editor extends EventEmitterClass {

    /**
     * @property renderer
     * @type VirtualRenderer
     */
    public renderer: VirtualRenderer;

    /**
     * @property session
     * @type EditSession
     * @private
     */
    private session: EditSession;

    private $touchHandler: IGestureHandler;
    private $mouseHandler: IGestureHandler;
    public getOption;
    public setOption;
    public setOptions;
    public $isFocused;
    public commands: CommandManager;
    public keyBinding: KeyBinding;
    // FIXME: This is really an optional extension and so does not belong here.
    public completers: Completer[];

    public widgetManager;

    /**
     * The renderer container element.
     */
    public container: HTMLElement;
    public textInput;
    public inMultiSelectMode: boolean;
    public inVirtualSelectionMode;

    private $cursorStyle: string;
    private $keybindingId;
    private $blockScrolling;
    private $highlightActiveLine;
    private $highlightPending;
    private $highlightSelectedWord;
    private $highlightTagPending;
    private $mergeUndoDeltas;
    public $readOnly;
    private $scrollAnchor;
    private $search: Search;
    private _$emitInputEvent;
    private selections;
    private $selectionStyle;
    private $opResetTimer;
    private curOp;
    private prevOp: { command?; args?};
    private previousCommand;
    private $mergeableCommands: string[];
    private mergeNextCommand;
    private $mergeNextCommand;
    private sequenceStartTime: number;
    private $onDocumentChange;
    private $onChangeMode;
    private $onTokenizerUpdate;
    private $onChangeTabSize: (event, editSession: EditSession) =&gt; any;
    private $onChangeWrapLimit;
    private $onChangeWrapMode;
    private $onChangeFold;
    private $onChangeFrontMarker;
    private $onChangeBackMarker;
    private $onChangeBreakpoint;
    private $onChangeAnnotation;
    private $onCursorChange;
    private $onScrollTopChange;
    private $onScrollLeftChange;
    public $onSelectionChange: (event, selection: Selection) =&gt; void;
    public exitMultiSelectMode;
    public forEachSelection;

    /**
     * Creates a new &#x60;Editor&#x60; object.
     *
     * @class
     * @constructor
     * @param renderer {VirtualRenderer} The view.
     * @param session {EditSession} The model.
     */
    constructor(renderer: VirtualRenderer, session: EditSession) {
        super();
        this.curOp = null;
        this.prevOp = {};
        this.$mergeableCommands = [&quot;backspace&quot;, &quot;del&quot;, &quot;insertstring&quot;];
        this.commands = new CommandManager(isMac ? &quot;mac&quot; : &quot;win&quot;, defaultCommands);
        this.container = renderer.getContainerElement();
        this.renderer = renderer;

        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.keyBinding = new KeyBinding(this);

        if (isMobile) {
            this.$touchHandler = touchManager(this);
            this.$mouseHandler = new MouseHandler(this);
        }
        else {
            this.$touchHandler = touchManager(this);
            this.$mouseHandler = new MouseHandler(this);
        }

        new FoldHandler(this);

        this.$blockScrolling = 0;
        this.$search = new Search().set({ wrap: true });

        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on(&quot;exec&quot;, this.$historyTracker);

        this.$initOperationListeners();

        this._$emitInputEvent = delayedCall(function() {
            this._signal(&quot;input&quot;, {});
            this.session.bgTokenizer &amp;&amp; this.session.bgTokenizer.scheduleStart();
        }.bind(this));

        var self = this;
        this.on(&quot;change&quot;, function() {
            self._$emitInputEvent.schedule(31);
        });

        this.setSession(session);
        resetOptions(this);
        _signal(&quot;editor&quot;, this);
    }

    cancelMouseContextMenu() {
        this.$mouseHandler.cancelContextMenu();
    }

    /**
     * @property selection
     * @type Selection
     */
    get selection(): Selection {
        return this.session.getSelection();
    }
    set selection(selection: Selection) {
        this.session.setSelection(selection);
    }

    $initOperationListeners() {
        function last(a) { return a[a.length - 1] }

        this.selections = [];
        this.commands.on(&quot;exec&quot;, function(e) {
            this.startOperation(e);

            var command = e.command;
            if (command.aceCommandGroup == &quot;fileJump&quot;) {
                var prev = this.prevOp;
                if (!prev || prev.command.aceCommandGroup != &quot;fileJump&quot;) {
                    this.lastFileJumpPos = last(this.selections);
                }
            } else {
                this.lastFileJumpPos = null;
            }
        }.bind(this), true);

        this.commands.on(&quot;afterExec&quot;, function(e) {
            var command = e.command;

            if (command.aceCommandGroup == &quot;fileJump&quot;) {
                if (this.lastFileJumpPos &amp;&amp; !this.curOp.selectionChanged) {
                    this.selection.fromJSON(this.lastFileJumpPos);
                }
            }
            this.endOperation(e);
        }.bind(this), true);

        this.$opResetTimer = delayedCall(this.endOperation.bind(this));

        this.on(&quot;change&quot;, function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
        }.bind(this), true);

        this.on(&quot;changeSelection&quot;, function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
        }.bind(this), true);
    }

    startOperation(commadEvent) {
        if (this.curOp) {
            if (!commadEvent || this.curOp.command)
                return;
            this.prevOp = this.curOp;
        }
        if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
        }

        this.$opResetTimer.schedule();
        this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
        };

        var command = this.curOp.command;
        if (command &amp;&amp; command.scrollIntoView)
            this.$blockScrolling++;

        this.selections.push(this.selection.toJSON());
    }

    endOperation() {
        if (this.curOp) {
            var command = this.curOp.command;
            if (command &amp;&amp; command.scrollIntoView) {
                this.$blockScrolling--;
                switch (command.scrollIntoView) {
                    case &quot;center&quot;:
                        this.renderer.scrollCursorIntoView(null, 0.5);
                        break;
                    case &quot;animate&quot;:
                    case &quot;cursor&quot;:
                        this.renderer.scrollCursorIntoView();
                        break;
                    case &quot;selectionPart&quot;:
                        var range = this.selection.getRange();
                        var config = this.renderer.layerConfig;
                        if (range.start.row &gt;= config.lastRow || range.end.row &lt;= config.firstRow) {
                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                        }
                        break;
                    default:
                        break;
                }
                if (command.scrollIntoView == &quot;animate&quot;)
                    this.renderer.animateScrolling(this.curOp.scrollTop);
            }

            this.prevOp = this.curOp;
            this.curOp = null;
        }
    }

    $historyTracker(e: { command; args }) {
        if (!this.$mergeUndoDeltas)
            return;

        var prev = this.prevOp;
        var mergeableCommands = this.$mergeableCommands;
        // previous command was the same
        var shouldMerge = prev.command &amp;&amp; (e.command.name == prev.command.name);
        if (e.command.name == &quot;insertstring&quot;) {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
                this.mergeNextCommand = true;

            shouldMerge = shouldMerge
                &amp;&amp; this.mergeNextCommand // previous command allows to coalesce with
                &amp;&amp; (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type

            this.mergeNextCommand = true;
        } else {
            shouldMerge = shouldMerge
                &amp;&amp; mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
        }

        if (
            this.$mergeUndoDeltas != &quot;always&quot;
            &amp;&amp; Date.now() - this.sequenceStartTime &gt; 2000
        ) {
            shouldMerge = false; // the sequence is too long
        }

        if (shouldMerge)
            this.session.mergeUndoDeltas = true;
        else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
    }

    /**
     * Sets a new key handler, such as &quot;vim&quot; or &quot;windows&quot;.
     *
     * @method setKeyboardHandler
     * @param keyboardHandler {string | HashHandler} The new key handler.
     * @return {void}
     */
    setKeyboardHandler(keyboardHandler: string | HashHandler): void {
        if (!keyboardHandler) {
            this.keyBinding.setKeyboardHandler(null);
        }
        else if (typeof keyboardHandler === &quot;string&quot;) {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            loadModule([&quot;keybinding&quot;, keyboardHandler], function(module) {
                if (_self.$keybindingId == keyboardHandler)
                    _self.keyBinding.setKeyboardHandler(module &amp;&amp; module.handler);
            }, this.container.ownerDocument);
        }
        else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
        }
    }

    /**
     * Returns the keyboard handler, such as &quot;vim&quot; or &quot;windows&quot;.
     *
     * @method getKeyboardHandler
     * @return {HashHandler}
     */
    getKeyboardHandler(): HashHandler {
        return this.keyBinding.getKeyboardHandler();
    }

    /**
     * Sets a new EditSession to use.
     * This method also emits the &#x60;&#x27;changeSession&#x27;&#x60; event.
     *
     * @method setSession
     * @param session {EditSession} The new session to use.
     * @return {void}
     */
    setSession(session: EditSession): void {
        if (this.session === session) {
            return;
        }

        var oldSession = this.session;
        if (oldSession) {
            this.session.off(&quot;change&quot;, this.$onDocumentChange);
            this.session.off(&quot;changeMode&quot;, this.$onChangeMode);
            this.session.off(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);
            this.session.off(&quot;changeTabSize&quot;, this.$onChangeTabSize);
            this.session.off(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);
            this.session.off(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);
            this.session.off(&quot;onChangeFold&quot;, this.$onChangeFold);
            this.session.off(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);
            this.session.off(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);
            this.session.off(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);
            this.session.off(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);
            this.session.off(&quot;changeOverwrite&quot;, this.$onCursorChange);
            this.session.off(&quot;changeScrollTop&quot;, this.$onScrollTopChange);
            this.session.off(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);

            var selection = this.session.getSelection();
            selection.off(&quot;changeCursor&quot;, this.$onCursorChange);
            selection.off(&quot;changeSelection&quot;, this.$onSelectionChange);
        }

        this.session = session;
        if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on(&quot;change&quot;, this.$onDocumentChange);
            this.renderer.setSession(session);

            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on(&quot;changeMode&quot;, this.$onChangeMode);

            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on(&quot;tokenizerUpdate&quot;, this.$onTokenizerUpdate);

            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on(&quot;changeTabSize&quot;, this.$onChangeTabSize);

            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on(&quot;changeWrapLimit&quot;, this.$onChangeWrapLimit);

            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on(&quot;changeWrapMode&quot;, this.$onChangeWrapMode);

            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on(&quot;changeFold&quot;, this.$onChangeFold);

            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            session.on(&quot;changeFrontMarker&quot;, this.$onChangeFrontMarker);

            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            session.on(&quot;changeBackMarker&quot;, this.$onChangeBackMarker);

            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            session.on(&quot;changeBreakpoint&quot;, this.$onChangeBreakpoint);

            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            session.on(&quot;changeAnnotation&quot;, this.$onChangeAnnotation);

            this.$onCursorChange = this.onCursorChange.bind(this);
            session.on(&quot;changeOverwrite&quot;, this.$onCursorChange);

            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            session.on(&quot;changeScrollTop&quot;, this.$onScrollTopChange);

            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            session.on(&quot;changeScrollLeft&quot;, this.$onScrollLeftChange);

            this.selection = session.getSelection();
            this.selection.on(&quot;changeCursor&quot;, this.$onCursorChange);

            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on(&quot;changeSelection&quot;, this.$onSelectionChange);

            this.onChangeMode(void 0, this.session);
            this.$blockScrolling += 1;
            this.onCursorChange(void 0, this.session);
            this.$blockScrolling -= 1;

            this.onScrollTopChange(void 0, this.session);
            this.onScrollLeftChange(void 0, this.session);

            this.onSelectionChange(void 0, this.selection);

            this.onChangeFrontMarker(void 0, this.session);
            this.onChangeBackMarker(void 0, this.session);
            this.onChangeBreakpoint(void 0, this.session);
            this.onChangeAnnotation(void 0, this.session);
            session.getUseWrapMode() &amp;&amp; this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
        }

        this._signal(&quot;changeSession&quot;, {
            session: session,
            oldSession: oldSession
        });

        oldSession &amp;&amp; oldSession._signal(&quot;changeEditor&quot;, { oldEditor: this });
        session &amp;&amp; session._signal(&quot;changeEditor&quot;, { editor: this });
    }

    /**
     * Returns the current session being used.
     *
     * @method getSession
     * @return {EditSession}
     */
    getSession(): EditSession {
        return this.session;
    }

    /**
     * Sets the current document to &#x60;val&#x60;.
     * @param {String} val The new value to set for the document
     * @param {Number} cursorPos Where to set the new value. &#x60;undefined&#x60; or 0 is selectAll, -1 is at the document start, and +1 is at the end
     *
     * @return {String} The current document value
     * @related Document.setValue
     **/
    setValue(val: string, cursorPos?: number): string {
        this.session.doc.setValue(val);

        if (!cursorPos) {
            this.selectAll();
        }
        else if (cursorPos == +1) {
            this.navigateFileEnd();
        }
        else if (cursorPos == -1) {
            this.navigateFileStart();
        }
        // TODO: Rather crazy! Either return this or the former value?
        return val;
    }

    /**
     * Returns the current session&#x27;s content.
     *
     * @return {String}
     * @related EditSession.getValue
     **/
    getValue(): string {
        return this.session.getValue();
    }

    /**
     *
     * Returns the currently highlighted selection.
     * @return {String} The highlighted selection
     **/
    getSelection(): Selection {
        return this.selection;
    }

    /**
     * @method resize
     * @param [force] {boolean} force If &#x60;true&#x60;, recomputes the size, even if the height and width haven&#x27;t changed.
     * @return {void}
     */
    resize(force?: boolean): void {
        this.renderer.onResize(force);
    }

    /**
     * {:VirtualRenderer.setTheme}
     * @param {String} theme The path to a theme
     * @param {Function} cb optional callback called when theme is loaded
     **/
    setTheme(theme: string, cb?: () =&gt; void) {
        this.renderer.setTheme(theme, cb);
    }

    /**
     * {:VirtualRenderer.getTheme}
     *
     * @return {String} The set theme
     * @related VirtualRenderer.getTheme
     **/
    getTheme(): string {
        return this.renderer.getTheme();
    }

    /**
     * {:VirtualRenderer.setStyle}
     * @param {String} style A class name
     *
     * @related VirtualRenderer.setStyle
     **/
    setStyle(style: string) {
        this.renderer.setStyle(style);
    }

    /**
     * {:VirtualRenderer.unsetStyle}
     * @related VirtualRenderer.unsetStyle
     **/
    unsetStyle(style: string) {
        this.renderer.unsetStyle(style);
    }

    /**
     * Gets the current font size of the editor text.
     */
    getFontSize(): string {
        return this.getOption(&quot;fontSize&quot;) || computedStyle(this.container, &quot;fontSize&quot;);
    }

    /**
     * Set a new font size (in pixels) for the editor text.
     * @param {string} fontSize A font size ( _e.g._ &quot;12px&quot;)
     *
     *
     **/
    setFontSize(fontSize: string) {
        this.setOption(&quot;fontSize&quot;, fontSize);
    }

    private $highlightBrackets() {
        if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = void 0;
        }

        if (this.$highlightPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightPending = true;
        setTimeout(function() {
            self.$highlightPending = false;

            var pos = self.session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (self.session.$mode.getMatching) {
                var range: Range = self.session.$mode.getMatching(self.session);
            }
            if (range)
                self.session.$bracketHighlight = self.session.addMarker(range, &quot;ace_bracket&quot;, &quot;text&quot;);
        }, 50);
    }

    // todo: move to mode.getMatching
    private $highlightTags() {
        var session = this.session;

        if (this.$highlightTagPending) {
            return;
        }

        // perform highlight async to not block the browser during navigation
        var self = this;
        this.$highlightTagPending = true;
        setTimeout(function() {
            self.$highlightTagPending = false;

            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();

            if (!token || token.type.indexOf(&#x27;tag-name&#x27;) === -1) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }

            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();

            if (prevToken.value == &#x27;&lt;&#x27;) {
                //find closing tag
                do {
                    prevToken = token;
                    token = iterator.stepForward();

                    if (token &amp;&amp; token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                        if (prevToken.value === &#x27;&lt;&#x27;) {
                            depth++;
                        } else if (prevToken.value === &#x27;&lt;/&#x27;) {
                            depth--;
                        }
                    }

                } while (token &amp;&amp; depth &gt;= 0);
            } else {
                //find opening tag
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();

                    if (token &amp;&amp; token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                        if (prevToken.value === &#x27;&lt;&#x27;) {
                            depth++;
                        } else if (prevToken.value === &#x27;&lt;/&#x27;) {
                            depth--;
                        }
                    }
                } while (prevToken &amp;&amp; depth &lt;= 0);

                //select tag again
                iterator.stepForward();
            }

            if (!token) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
                return;
            }

            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column + token.value.length);

            //remove range if different
            if (session.$tagHighlight &amp;&amp; range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
                session.removeMarker(session.$tagHighlight);
                session.$tagHighlight = null;
            }

            if (range &amp;&amp; !session.$tagHighlight)
                session.$tagHighlight = session.addMarker(range, &quot;ace_bracket&quot;, &quot;text&quot;);
        }, 50);
    }

    /**
     *
     * Brings the current &#x60;textInput&#x60; into focus.
     **/
    focus() {
        // Safari needs the timeout
        // iOS and Firefox need it called immediately
        // to be on the save side we do both
        var _self = this;
        setTimeout(function() {
            _self.textInput.focus();
        });
        this.textInput.focus();
    }

    /**
     * Returns &#x60;true&#x60; if the current &#x60;textInput&#x60; is in focus.
     * @return {Boolean}
     **/
    isFocused(): boolean {
        return this.textInput.isFocused();
    }

    /**
     *
     * Blurs the current &#x60;textInput&#x60;.
     **/
    blur() {
        this.textInput.blur();
    }

    /**
     * Emitted once the editor comes into focus.
     * @event focus
     *
     **/
    onFocus() {
        if (this.$isFocused) {
            return;
        }
        this.$isFocused = true;
        this.renderer.showCursor();
        this.renderer.visualizeFocus();
        this._emit(&quot;focus&quot;);
    }

    /**
     * Emitted once the editor has been blurred.
     * @event blur
     *
     *
     **/
    onBlur() {
        if (!this.$isFocused) {
            return;
        }
        this.$isFocused = false;
        this.renderer.hideCursor();
        this.renderer.visualizeBlur();
        this._emit(&quot;blur&quot;);
    }

    $cursorChange() {
        this.renderer.updateCursor();
    }

    /**
     * Emitted whenever the document is changed.
     * @event change
     * @param {Object} e Contains a single property, &#x60;data&#x60;, which has the delta of changes
     *
     **/
    onDocumentChange(e, editSession: EditSession) {
        var delta = e.data;
        var range = delta.range;
        var lastRow: number;

        if (range.start.row == range.end.row &amp;&amp; delta.action != &quot;insertLines&quot; &amp;&amp; delta.action != &quot;removeLines&quot;)
            lastRow = range.end.row;
        else
            lastRow = Infinity;

        var r: VirtualRenderer = this.renderer;
        r.updateLines(range.start.row, lastRow, this.session.$useWrapMode);

        this._signal(&quot;change&quot;, e);

        // update cursor because tab characters can influence the cursor position
        this.$cursorChange();
        this.$updateHighlightActiveLine();
    }

    onTokenizerUpdate(event, editSession: EditSession) {
        var rows = event.data;
        this.renderer.updateLines(rows.first, rows.last);
    }


    onScrollTopChange(event, editSession: EditSession) {
        this.renderer.scrollToY(this.session.getScrollTop());
    }

    onScrollLeftChange(event, editSession: EditSession) {
        this.renderer.scrollToX(this.session.getScrollLeft());
    }

    /**
     * Handler for cursor or selection changes.
     */
    onCursorChange(event, editSession: EditSession) {
        this.$cursorChange();

        if (!this.$blockScrolling) {
            this.renderer.scrollCursorIntoView();
        }

        this.$highlightBrackets();
        this.$highlightTags();
        this.$updateHighlightActiveLine();
        // TODO; How is signal different from emit?
        this._signal(&quot;changeSelection&quot;);
    }

    public $updateHighlightActiveLine() {

        var session = this.session;
        var renderer = this.renderer;

        var highlight;
        if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != &quot;line&quot; || !this.selection.isMultiLine())) {
                highlight = this.getCursorPosition();
            }
            if (renderer.$maxLines &amp;&amp; session.getLength() === 1 &amp;&amp; !(renderer.$minLines &gt; 1)) {
                highlight = false;
            }
        }

        if (session.$highlightLineMarker &amp;&amp; !highlight) {
            session.removeMarker(session.$highlightLineMarker.markerId);
            session.$highlightLineMarker = null;
        }
        else if (!session.$highlightLineMarker &amp;&amp; highlight) {
            var range: Range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.markerId = session.addMarker(range, &quot;ace_active-line&quot;, &quot;screenLine&quot;);
            session.$highlightLineMarker = range;
        }
        else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal(&quot;changeBackMarker&quot;);
        }
    }

    // This version has not been bound to &#x60;this&#x60;, so don&#x27;t use it directly.
    private onSelectionChange(event, selection: Selection): void {
        var session = this.session;

        if (typeof session.$selectionMarker === &#x27;number&#x27;) {
            session.removeMarker(session.$selectionMarker);
            session.$selectionMarker = null;
        }

        if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, &quot;ace_selection&quot;, style);
        }
        else {
            this.$updateHighlightActiveLine();
        }

        var re = this.$highlightSelectedWord &amp;&amp; this.$getSelectionHighLightRegexp();
        this.session.highlight(re);

        this._signal(&quot;changeSelection&quot;);
    }

    $getSelectionHighLightRegexp() {
        var session = this.session;

        var selection = this.getSelectionRange();
        if (selection.isEmpty() || selection.isMultiLine())
            return;

        var startOuter = selection.start.column - 1;
        var endOuter = selection.end.column + 1;
        var line = session.getLine(selection.start.row);
        var lineCols = line.length;
        var needle = line.substring(Math.max(startOuter, 0),
            Math.min(endOuter, lineCols));

        // Make sure the outer characters are not part of the word.
        if ((startOuter &gt;= 0 &amp;&amp; /^[\w\d]/.test(needle)) ||
            (endOuter &lt;= lineCols &amp;&amp; /[\w\d]$/.test(needle)))
            return;

        needle = line.substring(selection.start.column, selection.end.column);
        if (!/^[\w\d]+$/.test(needle))
            return;

        var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
        });

        return re;
    }


    onChangeFrontMarker(event, editSession: EditSession) {
        this.renderer.updateFrontMarkers();
    }

    onChangeBackMarker(event, editSession: EditSession) {
        this.renderer.updateBackMarkers();
    }


    onChangeBreakpoint(event, editSession: EditSession) {
        this.renderer.updateBreakpoints();
        this._emit(&quot;changeBreakpoint&quot;, event);
    }

    onChangeAnnotation(event, editSession: EditSession) {
        this.renderer.setAnnotations(editSession.getAnnotations());
        this._emit(&quot;changeAnnotation&quot;, event);
    }


    onChangeMode(event, editSession: EditSession) {
        this.renderer.updateText();
        this._emit(&quot;changeMode&quot;, event);
    }


    onChangeWrapLimit(event, editSession: EditSession) {
        this.renderer.updateFull();
    }

    onChangeWrapMode(event, editSession: EditSession) {
        this.renderer.onResize(true);
    }


    onChangeFold(event, editSession: EditSession) {
        // Update the active line marker as due to folding changes the current
        // line range on the screen might have changed.
        this.$updateHighlightActiveLine();
        // TODO: This might be too much updating. Okay for now.
        this.renderer.updateFull();
    }

    /**
     * Returns the string of text currently highlighted.
     * @return {String}
     **/
    getSelectedText() {
        return this.session.getTextRange(this.getSelectionRange());
    }

    /**
     * Emitted when text is copied.
     * @event copy
     * @param {String} text The copied text
     *
     **/
    /**
     * Returns the string of text currently highlighted.
     * @return {String}
     * @deprecated Use getSelectedText instead.
     **/
    getCopyText() {
        var text = this.getSelectedText();
        this._signal(&quot;copy&quot;, text);
        return text;
    }

    /**
     * Called whenever a text &quot;copy&quot; happens.
     **/
    onCopy() {
        this.commands.exec(&quot;copy&quot;, this);
    }

    /**
     * Called whenever a text &quot;cut&quot; happens.
     **/
    onCut() {
        this.commands.exec(&quot;cut&quot;, this);
    }

    /**
     * Emitted when text is pasted.
     * @event paste
     * @param {String} text The pasted text
     *
     *
     **/
    /**
     * Called whenever a text &quot;paste&quot; happens.
     * @param {String} text The pasted text
     *
     *
     **/
    onPaste(text: string) {
        // todo this should change when paste becomes a command
        if (this.$readOnly)
            return;
        var e = { text: text };
        this._signal(&quot;paste&quot;, e);
        this.insert(e.text, true);
    }


    execCommand(command, args?): void {
        this.commands.exec(command, this, args);
    }

    /**
     * Inserts &#x60;text&#x60; into wherever the cursor is pointing.
     * @param {String} text The new text to add
     *
     **/
    insert(text: string, pasted?: boolean): void {
        var session = this.session;
        var mode = session.getMode();
        var cursor = this.getCursorPosition();

        if (this.getBehavioursEnabled() &amp;&amp; !pasted) {
            // Get a transform if the current mode wants one.
            var transform = mode.transformAction(session.getState(cursor.row), &#x27;insertion&#x27;, this, session, text);
            if (transform) {
                if (text !== transform.text) {
                    this.session.mergeUndoDeltas = false;
                    this.$mergeNextCommand = false;
                }
                text = transform.text;

            }
        }

        if (text === &quot;\t&quot;) {
            text = this.session.getTabString();
        }

        // remove selected text
        if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
        }
        else if (this.session.getOverwrite()) {
            var range = Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
        }

        if (text === &quot;\n&quot; || text === &quot;\r\n&quot;) {
            var line = session.getLine(cursor.row);
            if (cursor.column &gt; line.search(/\S|$/)) {
                var d = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
        }
        this.clearSelection();

        var start = cursor.column;
        var lineState = session.getState(cursor.row);
        var line = session.getLine(cursor.row);
        var shouldOutdent = mode.checkOutdent(lineState, line, text);
        var end = session.insert(cursor, text);

        if (transform &amp;&amp; transform.selection) {
            if (transform.selection.length == 2) { // Transform relative to the current column
                this.selection.setSelectionRange(
                    new Range(cursor.row, start + transform.selection[0],
                        cursor.row, start + transform.selection[1]));
            } else { // Transform relative to the current row.
                this.selection.setSelectionRange(
                    new Range(cursor.row + transform.selection[0],
                        transform.selection[1],
                        cursor.row + transform.selection[2],
                        transform.selection[3]));
            }
        }

        if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());

            session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
        }
        if (shouldOutdent) {
            mode.autoOutdent(lineState, session, cursor.row);
        }
    }

    onTextInput(text: string): void {
        this.keyBinding.onTextInput(text);
        // TODO: This should be pluggable.
        if (text === &#x27;.&#x27;) {
            this.commands.exec(COMMAND_NAME_AUTO_COMPLETE);
        }
        else if (this.getSession().getDocument().isNewLine(text)) {
            var lineNumber = this.getCursorPosition().row;
            //            var option = new Services.EditorOptions();
            //            option.NewLineCharacter = &quot;\n&quot;;
            // FIXME: Smart Indenting
            /*
            var indent = languageService.getSmartIndentAtLineNumber(currentFileName, lineNumber, option);
            if(indent &gt; 0)
            {
                editor.commands.exec(&quot;inserttext&quot;, editor, {text:&quot; &quot;, times:indent});
            }
            */
        }
    }

    onCommandKey(e, hashId: number, keyCode: number) {
        this.keyBinding.onCommandKey(e, hashId, keyCode);
    }

    /**
     * Pass in &#x60;true&#x60; to enable overwrites in your session, or &#x60;false&#x60; to disable. If overwrites is enabled, any text you enter will type over any text after it. If the value of &#x60;overwrite&#x60; changes, this function also emites the &#x60;changeOverwrite&#x60; event.
     * @param {Boolean} overwrite Defines wheter or not to set overwrites
     *
     *
     * @related EditSession.setOverwrite
     **/
    setOverwrite(overwrite: boolean) {
        this.session.setOverwrite(overwrite);
    }

    /**
     * Returns &#x60;true&#x60; if overwrites are enabled; &#x60;false&#x60; otherwise.
     * @return {Boolean}
     * @related EditSession.getOverwrite
     **/
    getOverwrite() {
        return this.session.getOverwrite();
    }

    /**
     * Sets the value of overwrite to the opposite of whatever it currently is.
     * @related EditSession.toggleOverwrite
     **/
    toggleOverwrite() {
        this.session.toggleOverwrite();
    }

    /**
     * Sets how fast the mouse scrolling should do.
     * @param {Number} speed A value indicating the new speed (in milliseconds)
     **/
    setScrollSpeed(speed: number) {
        this.setOption(&quot;scrollSpeed&quot;, speed);
    }

    /**
     * Returns the value indicating how fast the mouse scroll speed is (in milliseconds).
     * @return {Number}
     **/
    getScrollSpeed(): number {
        return this.getOption(&quot;scrollSpeed&quot;);
    }

    /**
     * Sets the delay (in milliseconds) of the mouse drag.
     * @param {Number} dragDelay A value indicating the new delay
     **/
    setDragDelay(dragDelay: number) {
        this.setOption(&quot;dragDelay&quot;, dragDelay);
    }

    /**
     * Returns the current mouse drag delay.
     * @return {Number}
     **/
    getDragDelay(): number {
        return this.getOption(&quot;dragDelay&quot;);
    }

    /**
     * Emitted when the selection style changes, via [[Editor.setSelectionStyle]].
     * @event changeSelectionStyle
     * @param {Object} data Contains one property, &#x60;data&#x60;, which indicates the new selection style
     **/
    /**
     * Draw selection markers spanning whole line, or only over selected text. Default value is &quot;line&quot;
     * @param {String} style The new selection style &quot;line&quot;|&quot;text&quot;
     *
     **/
    setSelectionStyle(val: string) {
        this.setOption(&quot;selectionStyle&quot;, val);
    }

    /**
     * Returns the current selection style.
     * @return {String}
     **/
    getSelectionStyle(): string {
        return this.getOption(&quot;selectionStyle&quot;);
    }

    /**
     * Determines whether or not the current line should be highlighted.
     * @param {Boolean} shouldHighlight Set to &#x60;true&#x60; to highlight the current line
     **/
    setHighlightActiveLine(shouldHighlight: boolean) {
        this.setOption(&quot;highlightActiveLine&quot;, shouldHighlight);
    }

    /**
     * Returns &#x60;true&#x60; if current lines are always highlighted.
     * @return {Boolean}
     **/
    getHighlightActiveLine(): boolean {
        return this.getOption(&quot;highlightActiveLine&quot;);
    }

    setHighlightGutterLine(shouldHighlight: boolean) {
        this.setOption(&quot;highlightGutterLine&quot;, shouldHighlight);
    }

    getHighlightGutterLine(): boolean {
        return this.getOption(&quot;highlightGutterLine&quot;);
    }

    /**
     * Determines if the currently selected word should be highlighted.
     * @param {Boolean} shouldHighlight Set to &#x60;true&#x60; to highlight the currently selected word
     *
     **/
    setHighlightSelectedWord(shouldHighlight: boolean): void {
        this.setOption(&quot;highlightSelectedWord&quot;, shouldHighlight);
    }

    /**
     * Returns &#x60;true&#x60; if currently highlighted words are to be highlighted.
     * @return {Boolean}
     **/
    getHighlightSelectedWord(): boolean {
        return this.$highlightSelectedWord;
    }

    setAnimatedScroll(shouldAnimate: boolean) {
        this.renderer.setAnimatedScroll(shouldAnimate);
    }

    getAnimatedScroll(): boolean {
        return this.renderer.getAnimatedScroll();
    }

    /**
     * If &#x60;showInvisibles&#x60; is set to &#x60;true&#x60;, invisible characters&amp;mdash;like spaces or new lines&amp;mdash;are show in the editor.
     * @param {Boolean} showInvisibles Specifies whether or not to show invisible characters
     *
     **/
    setShowInvisibles(showInvisibles: boolean) {
        this.renderer.setShowInvisibles(showInvisibles);
    }

    /**
     * Returns &#x60;true&#x60; if invisible characters are being shown.
     * @return {Boolean}
     **/
    getShowInvisibles(): boolean {
        return this.renderer.getShowInvisibles();
    }

    setDisplayIndentGuides(displayIndentGuides: boolean) {
        this.renderer.setDisplayIndentGuides(displayIndentGuides);
    }

    getDisplayIndentGuides(): boolean {
        return this.renderer.getDisplayIndentGuides();
    }

    /**
     * If &#x60;showPrintMargin&#x60; is set to &#x60;true&#x60;, the print margin is shown in the editor.
     * @param {Boolean} showPrintMargin Specifies whether or not to show the print margin
     **/
    setShowPrintMargin(showPrintMargin: boolean) {
        this.renderer.setShowPrintMargin(showPrintMargin);
    }

    /**
     * Returns &#x60;true&#x60; if the print margin is being shown.
     * @return {Boolean}
     */
    getShowPrintMargin(): boolean {
        return this.renderer.getShowPrintMargin();
    }

    /**
     * Sets the column defining where the print margin should be.
     * @param {Number} showPrintMargin Specifies the new print margin
     */
    setPrintMarginColumn(showPrintMargin: number) {
        this.renderer.setPrintMarginColumn(showPrintMargin);
    }

    /**
     * Returns the column number of where the print margin is.
     * @return {Number}
     */
    getPrintMarginColumn(): number {
        return this.renderer.getPrintMarginColumn();
    }

    /**
     * If &#x60;readOnly&#x60; is true, then the editor is set to read-only mode, and none of the content can change.
     * @param {Boolean} readOnly Specifies whether the editor can be modified or not
     *
     **/
    setReadOnly(readOnly: boolean) {
        this.setOption(&quot;readOnly&quot;, readOnly);
    }

    /**
     * Returns &#x60;true&#x60; if the editor is set to read-only mode.
     * @return {Boolean}
     **/
    getReadOnly(): boolean {
        return this.getOption(&quot;readOnly&quot;);
    }

    /**
     * Specifies whether to use behaviors or not. [&quot;Behaviors&quot; in this case is the auto-pairing of special characters, like quotation marks, parenthesis, or brackets.]{: #BehaviorsDef}
     * @param {Boolean} enabled Enables or disables behaviors
     *
     **/
    setBehavioursEnabled(enabled: boolean) {
        this.setOption(&quot;behavioursEnabled&quot;, enabled);
    }

    /**
     * Returns &#x60;true&#x60; if the behaviors are currently enabled. {:BehaviorsDef}
     *
     * @return {Boolean}
     **/
    getBehavioursEnabled(): boolean {
        return this.getOption(&quot;behavioursEnabled&quot;);
    }

    /**
     * Specifies whether to use wrapping behaviors or not, i.e. automatically wrapping the selection with characters such as brackets
     * when such a character is typed in.
     * @param {Boolean} enabled Enables or disables wrapping behaviors
     *
     **/
    setWrapBehavioursEnabled(enabled: boolean) {
        this.setOption(&quot;wrapBehavioursEnabled&quot;, enabled);
    }

    /**
     * Returns &#x60;true&#x60; if the wrapping behaviors are currently enabled.
     **/
    getWrapBehavioursEnabled(): boolean {
        return this.getOption(&quot;wrapBehavioursEnabled&quot;);
    }

    /**
     * Indicates whether the fold widgets should be shown or not.
     * @param {Boolean} show Specifies whether the fold widgets are shown
     **/
    setShowFoldWidgets(show: boolean) {
        this.setOption(&quot;showFoldWidgets&quot;, show);
    }

    /**
     * Returns &#x60;true&#x60; if the fold widgets are shown.
     * @return {Boolean}
     */
    getShowFoldWidgets() {
        return this.getOption(&quot;showFoldWidgets&quot;);
    }

    setFadeFoldWidgets(fade: boolean) {
        this.setOption(&quot;fadeFoldWidgets&quot;, fade);
    }

    getFadeFoldWidgets(): boolean {
        return this.getOption(&quot;fadeFoldWidgets&quot;);
    }

    /**
     * Removes words of text from the editor. A &quot;word&quot; is defined as a string of characters bookended by whitespace.
     * @param {String} direction The direction of the deletion to occur, either &quot;left&quot; or &quot;right&quot;
     *
     **/
    remove(direction: string): void {
        if (this.selection.isEmpty()) {
            if (direction == &quot;left&quot;)
                this.selection.selectLeft();
            else
                this.selection.selectRight();
        }

        var range = this.getSelectionRange();
        if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, &#x27;deletion&#x27;, this, session, range);

            if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == &quot;\n&quot;) {
                    var line = session.getLine(range.end.row);
                    if (/^\s+$/.test(line)) {
                        range.end.column = line.length;
                    }
                }
            }
            if (new_range)
                range = new_range;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Removes the word directly to the right of the current selection.
     **/
    removeWordRight() {
        if (this.selection.isEmpty())
            this.selection.selectWordRight();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes the word directly to the left of the current selection.
     **/
    removeWordLeft() {
        if (this.selection.isEmpty())
            this.selection.selectWordLeft();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the left of the current selection, until the start of the line.
     **/
    removeToLineStart() {
        if (this.selection.isEmpty())
            this.selection.selectLineStart();

        this.session.remove(this.getSelectionRange());
        this.clearSelection();
    }

    /**
     * Removes all the words to the right of the current selection, until the end of the line.
     **/
    removeToLineEnd() {
        if (this.selection.isEmpty())
            this.selection.selectLineEnd();

        var range = this.getSelectionRange();
        if (range.start.column === range.end.column &amp;&amp; range.start.row === range.end.row) {
            range.end.column = 0;
            range.end.row++;
        }

        this.session.remove(range);
        this.clearSelection();
    }

    /**
     * Splits the line at the current selection (by inserting an &#x60;&#x27;\n&#x27;&#x60;).
     **/
    splitLine() {
        if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        }

        var cursor = this.getCursorPosition();
        this.insert(&quot;\n&quot;);
        this.moveCursorToPosition(cursor);
    }

    /**
     * Transposes current line.
     **/
    transposeLetters() {
        if (!this.selection.isEmpty()) {
            return;
        }

        var cursor = this.getCursorPosition();
        var column = cursor.column;
        if (column === 0)
            return;

        var line = this.session.getLine(cursor.row);
        var swap, range;
        if (column &lt; line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
        }
        else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
        }
        this.session.replace(range, swap);
    }

    /**
     * Converts the current selection entirely into lowercase.
     **/
    toLowerCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toLowerCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Converts the current selection entirely into uppercase.
     **/
    toUpperCase() {
        var originalRange = this.getSelectionRange();
        if (this.selection.isEmpty()) {
            this.selection.selectWord();
        }

        var range = this.getSelectionRange();
        var text = this.session.getTextRange(range);
        this.session.replace(range, text.toUpperCase());
        this.selection.setSelectionRange(originalRange);
    }

    /**
     * Inserts an indentation into the current cursor position or indents the selected lines.
     *
     * @related EditSession.indentRows
     **/
    indent() {
        var session = this.session;
        var range = this.getSelectionRange();

        if (range.start.row &lt; range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, &quot;\t&quot;);
            return;
        } else if (range.start.column &lt; range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, &quot;\t&quot;);
                return;
            }
        }

        var line = session.getLine(range.start.row);
        var position = range.start;
        var size = session.getTabSize();
        var column = session.documentToScreenColumn(position.row, position.column);

        if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = stringRepeat(&quot; &quot;, count);
        } else {
            var count = column % size;
            while (line[range.start.column] == &quot; &quot; &amp;&amp; count) {
                range.start.column--;
                count--;
            }
            this.selection.setSelectionRange(range);
            indentString = &quot;\t&quot;;
        }
        return this.insert(indentString);
    }

    /**
     * Indents the current line.
     * @related EditSession.indentRows
     **/
    blockIndent() {
        var rows = this.$getSelectedRows();
        this.session.indentRows(rows.first, rows.last, &quot;\t&quot;);
    }

    /**
     * Outdents the current line.
     * @related EditSession.outdentRows
     **/
    blockOutdent() {
        var selection = this.session.getSelection();
        this.session.outdentRows(selection.getRange());
    }

    // TODO: move out of core when we have good mechanism for managing extensions
    sortLines() {
        var rows = this.$getSelectedRows();
        var session = this.session;

        var lines = [];
        for (i = rows.first; i &lt;= rows.last; i++)
            lines.push(session.getLine(i));

        lines.sort(function(a, b) {
            if (a.toLowerCase() &lt; b.toLowerCase()) return -1;
            if (a.toLowerCase() &gt; b.toLowerCase()) return 1;
            return 0;
        });

        var deleteRange = new Range(0, 0, 0, 0);
        for (var i = rows.first; i &lt;= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
        }
    }

    /**
     * Given the currently selected range, this function either comments all the lines, or uncomments all of them.
     **/
    toggleCommentLines() {
        var state = this.session.getState(this.getCursorPosition().row);
        var rows = this.$getSelectedRows();
        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
    }

    toggleBlockComment() {
        var cursor = this.getCursorPosition();
        var state = this.session.getState(cursor.row);
        var range = this.getSelectionRange();
        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
    }

    /**
     * Works like [[EditSession.getTokenAt]], except it returns a number.
     * @return {Number}
     **/
    getNumberAt(row: number, column: number): { value: string; start: number; end: number } {
        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
        _numberRx.lastIndex = 0;

        var s = this.session.getLine(row);
        while (_numberRx.lastIndex &lt; column) {
            var m: RegExpExecArray = _numberRx.exec(s);
            if (m.index &lt;= column &amp;&amp; m.index + m[0].length &gt;= column) {
                var retval = {
                    value: m[0],
                    start: m.index,
                    end: m.index + m[0].length
                };
                return retval;
            }
        }
        return null;
    }

    /**
     * If the character before the cursor is a number, this functions changes its value by &#x60;amount&#x60;.
     * @param {Number} amount The value to change the numeral by (can be negative to decrease value)
     */
    modifyNumber(amount: number): void {
        var row = this.selection.getCursor().row;
        var column = this.selection.getCursor().column;

        // get the char before the cursor
        var charRange = new Range(row, column - 1, row, column);

        var c = parseFloat(this.session.getTextRange(charRange));
        // if the char is a digit
        if (!isNaN(c) &amp;&amp; isFinite(c)) {
            // get the whole number the digit is part of
            var nr = this.getNumberAt(row, column);
            // if number found
            if (nr) {
                var fp = nr.value.indexOf(&quot;.&quot;) &gt;= 0 ? nr.start + nr.value.indexOf(&quot;.&quot;) + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;

                var t = parseFloat(nr.value);
                t *= Math.pow(10, decimals);


                if (fp !== nr.end &amp;&amp; column &lt; fp) {
                    amount *= Math.pow(10, nr.end - column - 1);
                } else {
                    amount *= Math.pow(10, nr.end - column);
                }

                t += amount;
                t /= Math.pow(10, decimals);
                var nnr = t.toFixed(decimals);

                //update number
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);

                //reposition the cursor
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));

            }
        }
    }

    /**
     * Removes all the lines in the current selection
     * @related EditSession.remove
     **/
    removeLines() {
        var rows = this.$getSelectedRows();
        var range;
        if (rows.first === 0 || rows.last + 1 &lt; this.session.getLength())
            range = new Range(rows.first, 0, rows.last + 1, 0);
        else
            range = new Range(
                rows.first - 1, this.session.getLine(rows.first - 1).length,
                rows.last, this.session.getLine(rows.last).length
            );
        this.session.remove(range);
        this.clearSelection();
    }

    duplicateSelection() {
        var sel = this.selection;
        var doc = this.session;
        var range = sel.getRange();
        var reverse = sel.isBackwards();
        if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
        } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range));
            range.start = point;
            range.end = endPoint;

            sel.setSelectionRange(range, reverse);
        }
    }

    /**
     * Shifts all the selected lines down one row.
     *
     * @return {Number} On success, it returns -1.
     * @related EditSession.moveLinesUp
     **/
    moveLinesDown() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesDown(firstRow, lastRow);
        });
    }

    /**
     * Shifts all the selected lines up one row.
     * @return {Number} On success, it returns -1.
     * @related EditSession.moveLinesDown
     **/
    moveLinesUp() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.moveLinesUp(firstRow, lastRow);
        });
    }

    /**
     * Moves a range of text from the given range to the given position. &#x60;toPosition&#x60; is an object that looks like this:
     * &#x60;&#x60;&#x60;json
     *    { row: newRowLocation, column: newColumnLocation }
     * &#x60;&#x60;&#x60;
     * @param {Range} fromRange The range of text you want moved within the document
     * @param {Object} toPosition The location (row and column) where you want to move the text to
     *
     * @return {Range} The new range where the text was moved to.
     * @related EditSession.moveText
     **/
    moveText(range, toPosition, copy) {
        return this.session.moveText(range, toPosition, copy);
    }

    /**
     * Copies all the selected lines up one row.
     * @return {Number} On success, returns 0.
     *
     **/
    copyLinesUp() {
        this.$moveLines(function(firstRow, lastRow) {
            this.session.duplicateLines(firstRow, lastRow);
            return 0;
        });
    }

    /**
     * Copies all the selected lines down one row.
     * @return {Number} On success, returns the number of new rows added; in other words, &#x60;lastRow - firstRow + 1&#x60;.
     * @related EditSession.duplicateLines
     *
     **/
    copyLinesDown() {
        this.$moveLines(function(firstRow, lastRow) {
            return this.session.duplicateLines(firstRow, lastRow);
        });
    }

    /**
     * Executes a specific function, which can be anything that manipulates selected lines, such as copying them, duplicating them, or shifting them.
     * @param {Function} mover A method to call on each selected row
     *
     *
     **/
    private $moveLines(mover) {
        var selection = this.selection;
        if (!selection[&#x27;inMultiSelectMode&#x27;] || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            var selectedRows: { first: number; last: number } = this.$getSelectedRows();
            var linesMoved = mover.call(this, selectedRows.first, selectedRows.last);
            range.moveBy(linesMoved, 0);
            selection.fromOrientedRange(range);
        }
        else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach();

            for (var i = ranges.length; i--;) {
                var rangeIndex = i;
                var collapsedRows = ranges[i].collapseRows();
                var last = collapsedRows.end.row;
                var first = collapsedRows.start.row;
                while (i--) {
                    collapsedRows = ranges[i].collapseRows();
                    if (first - collapsedRows.end.row &lt;= 1)
                        first = collapsedRows.end.row;
                    else
                        break;
                }
                i++;

                var linesMoved = mover.call(this, first, last);
                while (rangeIndex &gt;= i) {
                    ranges[rangeIndex].moveBy(linesMoved, 0);
                    rangeIndex--;
                }
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
        }
    }

    /**
     * Returns an object indicating the currently selected rows.
     *
     * @return {Object}
     **/
    private $getSelectedRows(): { first: number; last: number } {
        var range = this.getSelectionRange().collapseRows();

        return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
        };
    }

    onCompositionStart(text?: string) {
        this.renderer.showComposition(this.getCursorPosition());
    }

    onCompositionUpdate(text?: string) {
        this.renderer.setCompositionText(text);
    }

    onCompositionEnd() {
        this.renderer.hideComposition();
    }

    /**
     * {:VirtualRenderer.getFirstVisibleRow}
     *
     * @return {Number}
     * @related VirtualRenderer.getFirstVisibleRow
     **/
    getFirstVisibleRow(): number {
        return this.renderer.getFirstVisibleRow();
    }

    /**
     * {:VirtualRenderer.getLastVisibleRow}
     *
     * @return {Number}
     * @related VirtualRenderer.getLastVisibleRow
     **/
    getLastVisibleRow(): number {
        return this.renderer.getLastVisibleRow();
    }

    /**
     * Indicates if the row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     * @return {Boolean}
     **/
    isRowVisible(row: number): boolean {
        return (row &gt;= this.getFirstVisibleRow() &amp;&amp; row &lt;= this.getLastVisibleRow());
    }

    /**
     * Indicates if the entire row is currently visible on the screen.
     * @param {Number} row The row to check
     *
     *
     * @return {Boolean}
     **/
    isRowFullyVisible(row: number): boolean {
        return (row &gt;= this.renderer.getFirstFullyVisibleRow() &amp;&amp; row &lt;= this.renderer.getLastFullyVisibleRow());
    }

    /**
     * Returns the number of currently visibile rows.
     * @return {Number}
     **/
    private $getVisibleRowCount(): number {
        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
    }

    /**
     * FIXME: The semantics of select are not easily understood. 
     * @param direction +1 for page down, -1 for page up. Maybe N for N pages?
     * @param select true | false | undefined
     */
    private $moveByPage(direction: number, select?: boolean) {
        var renderer = this.renderer;
        var config = this.renderer.layerConfig;
        var rows = direction * Math.floor(config.height / config.lineHeight);

        this.$blockScrolling++;
        if (select === true) {
            this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
            });
        }
        else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
        }
        this.$blockScrolling--;

        var scrollTop = renderer.scrollTop;

        renderer.scrollBy(0, rows * config.lineHeight);
        // Why don&#x27;t we assert our args and do typeof select === &#x27;undefined&#x27;?
        if (select != null) {
            // This is called when select is undefined.
            renderer.scrollCursorIntoView(null, 0.5);
        }

        renderer.animateScrolling(scrollTop);
    }

    /**
     * Selects the text from the current position of the document until where a &quot;page down&quot; finishes.
     **/
    selectPageDown() {
        this.$moveByPage(+1, true);
    }

    /**
     * Selects the text from the current position of the document until where a &quot;page up&quot; finishes.
     **/
    selectPageUp() {
        this.$moveByPage(-1, true);
    }

    /**
     * Shifts the document to wherever &quot;page down&quot; is, as well as moving the cursor position.
     **/
    gotoPageDown() {
        this.$moveByPage(+1, false);
    }

    /**
     * Shifts the document to wherever &quot;page up&quot; is, as well as moving the cursor position.
     **/
    gotoPageUp() {
        this.$moveByPage(-1, false);
    }

    /**
     * Scrolls the document to wherever &quot;page down&quot; is, without changing the cursor position.
     **/
    scrollPageDown() {
        this.$moveByPage(1);
    }

    /**
     * Scrolls the document to wherever &quot;page up&quot; is, without changing the cursor position.
     **/
    scrollPageUp() {
        this.$moveByPage(-1);
    }

    /**
     * Moves the editor to the specified row.
     * @related VirtualRenderer.scrollToRow
     */
    scrollToRow(row: number) {
        this.renderer.scrollToRow(row);
    }

    /**
     * Scrolls to a line. If &#x60;center&#x60; is &#x60;true&#x60;, it puts the line in middle of screen (or attempts to).
     * @param {Number} line The line to scroll to
     * @param {Boolean} center If &#x60;true&#x60;
     * @param {Boolean} animate If &#x60;true&#x60; animates scrolling
     * @param {Function} callback Function to be called when the animation has finished
     *
     *
     * @related VirtualRenderer.scrollToLine
     **/
    scrollToLine(line: number, center: boolean, animate: boolean, callback?: () =&gt; any): void {
        this.renderer.scrollToLine(line, center, animate, callback);
    }

    /**
     * Attempts to center the current selection on the screen.
     **/
    centerSelection(): void {
        var range = this.getSelectionRange();
        var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
        };
        this.renderer.alignCursor(pos, 0.5);
    }

    /**
     * Gets the current position of the cursor.
     * @return {Object} An object that looks something like this:
     *
     * &#x60;&#x60;&#x60;json
     * { row: currRow, column: currCol }
     * &#x60;&#x60;&#x60;
     *
     * @related Selection.getCursor
     **/
    getCursorPosition(): { row: number; column: number } {
        return this.selection.getCursor();
    }

    /**
     * Returns the screen position of the cursor.
     **/
    getCursorPositionScreen(): { row: number; column: number } {
        var cursor = this.getCursorPosition()
        return this.session.documentToScreenPosition(cursor.row, cursor.column);
    }

    /**
     * {:Selection.getRange}
     * @return {Range}
     * @related Selection.getRange
     **/
    getSelectionRange(): Range {
        return this.selection.getRange();
    }

    /**
     * Selects all the text in editor.
     * @related Selection.selectAll
     **/
    selectAll(): void {
        this.$blockScrolling += 1;
        this.selection.selectAll();
        this.$blockScrolling -= 1;
    }

    /**
     * {:Selection.clearSelection}
     * @related Selection.clearSelection
     **/
    clearSelection(): void {
        this.selection.clearSelection();
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does not de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     * @param {boolean} animate
     *
     * @related Selection.moveCursorTo
     **/
    moveCursorTo(row: number, column: number, animate?: boolean): void {
        this.selection.moveCursorTo(row, column, animate);
    }

    /**
     * Moves the cursor to the position indicated by &#x60;pos.row&#x60; and &#x60;pos.column&#x60;.
     * @param {Object} pos An object with two properties, row and column
     *
     *
     * @related Selection.moveCursorToPosition
     **/
    moveCursorToPosition(pos) {
        this.selection.moveCursorToPosition(pos);
    }

    /**
     * Moves the cursor&#x27;s row and column to the next matching bracket or HTML tag.
     *
     **/
    jumpToMatching(select: boolean) {
        var cursor = this.getCursorPosition();
        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
        var prevToken = iterator.getCurrentToken();
        var token = prevToken;

        if (!token)
            token = iterator.stepForward();

        if (!token)
            return;

        //get next closing tag or bracket
        var matchType;
        var found = false;
        var depth = {};
        var i = cursor.column - token.start;
        var bracketType;
        var brackets = {
            &quot;)&quot;: &quot;(&quot;,
            &quot;(&quot;: &quot;(&quot;,
            &quot;]&quot;: &quot;[&quot;,
            &quot;[&quot;: &quot;[&quot;,
            &quot;{&quot;: &quot;{&quot;,
            &quot;}&quot;: &quot;{&quot;
        };

        do {
            if (token.value.match(/[{}()\[\]]/g)) {
                for (; i &lt; token.value.length &amp;&amp; !found; i++) {
                    if (!brackets[token.value[i]]) {
                        continue;
                    }

                    bracketType = brackets[token.value[i]] + &#x27;.&#x27; + token.type.replace(&quot;rparen&quot;, &quot;lparen&quot;);

                    if (isNaN(depth[bracketType])) {
                        depth[bracketType] = 0;
                    }

                    switch (token.value[i]) {
                        case &#x27;(&#x27;:
                        case &#x27;[&#x27;:
                        case &#x27;{&#x27;:
                            depth[bracketType]++;
                            break;
                        case &#x27;)&#x27;:
                        case &#x27;]&#x27;:
                        case &#x27;}&#x27;:
                            depth[bracketType]--;

                            if (depth[bracketType] === -1) {
                                matchType = &#x27;bracket&#x27;;
                                found = true;
                            }
                            break;
                    }
                }
            } else if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                if (isNaN(depth[token.value])) {
                    depth[token.value] = 0;
                }

                if (prevToken.value === &#x27;&lt;&#x27;) {
                    depth[token.value]++;
                } else if (prevToken.value === &#x27;&lt;/&#x27;) {
                    depth[token.value]--;
                }

                if (depth[token.value] === -1) {
                    matchType = &#x27;tag&#x27;;
                    found = true;
                }
            }

            if (!found) {
                prevToken = token;
                token = iterator.stepForward();
                i = 0;
            }
        } while (token &amp;&amp; !found);

        //no match found
        if (!matchType) {
            return;
        }

        var range: Range;
        if (matchType === &#x27;bracket&#x27;) {
            range = this.session.getBracketRange(cursor);
            if (!range) {
                range = new Range(
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1,
                    iterator.getCurrentTokenRow(),
                    iterator.getCurrentTokenColumn() + i - 1
                );
                if (!range)
                    return;
                var pos = range.start;
                if (pos.row === cursor.row &amp;&amp; Math.abs(pos.column - cursor.column) &lt; 2)
                    range = this.session.getBracketRange(pos);
            }
        } else if (matchType === &#x27;tag&#x27;) {
            if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1)
                var tag = token.value;
            else
                return;

            var range = new Range(
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2,
                iterator.getCurrentTokenRow(),
                iterator.getCurrentTokenColumn() - 2
            );

            //find matching tag
            if (range.compare(cursor.row, cursor.column) === 0) {
                found = false;
                do {
                    token = prevToken;
                    prevToken = iterator.stepBackward();

                    if (prevToken) {
                        if (prevToken.type.indexOf(&#x27;tag-close&#x27;) !== -1) {
                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                        }

                        if (token.value === tag &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;) !== -1) {
                            if (prevToken.value === &#x27;&lt;&#x27;) {
                                depth[tag]++;
                            } else if (prevToken.value === &#x27;&lt;/&#x27;) {
                                depth[tag]--;
                            }

                            if (depth[tag] === 0)
                                found = true;
                        }
                    }
                } while (prevToken &amp;&amp; !found);
            }

            //we found it
            if (token &amp;&amp; token.type.indexOf(&#x27;tag-name&#x27;)) {
                var pos = range.start;
                if (pos.row == cursor.row &amp;&amp; Math.abs(pos.column - cursor.column) &lt; 2)
                    pos = range.end;
            }
        }

        pos = range &amp;&amp; range[&#x27;cursor&#x27;] || pos;
        if (pos) {
            if (select) {
                if (range &amp;&amp; range.isEqual(this.getSelectionRange()))
                    this.clearSelection();
                else
                    this.selection.selectTo(pos.row, pos.column);
            } else {
                this.selection.moveTo(pos.row, pos.column);
            }
        }
    }

    /**
     * Moves the cursor to the specified line number, and also into the indiciated column.
     * @param {Number} lineNumber The line number to go to
     * @param {Number} column A column number to go to
     * @param {Boolean} animate If &#x60;true&#x60; animates scolling
     **/
    gotoLine(lineNumber: number, column?: number, animate?: boolean) {
        this.selection.clearSelection();
        this.session.unfold({ row: lineNumber - 1, column: column || 0 });

        this.$blockScrolling += 1;
        // todo: find a way to automatically exit multiselect mode
        this.exitMultiSelectMode &amp;&amp; this.exitMultiSelectMode();
        this.moveCursorTo(lineNumber - 1, column || 0);
        this.$blockScrolling -= 1;

        if (!this.isRowFullyVisible(lineNumber - 1)) {
            this.scrollToLine(lineNumber - 1, true, animate);
        }
    }

    /**
     * Moves the cursor to the specified row and column. Note that this does de-select the current selection.
     * @param {Number} row The new row number
     * @param {Number} column The new column number
     *
     *
     * @related Editor.moveCursorTo
     **/
    navigateTo(row: number, column: number) {
        this.selection.moveTo(row, column);
    }

    /**
     * Moves the cursor up in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    navigateUp(times: number) {
        if (this.selection.isMultiLine() &amp;&amp; !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(-times || -1, 0);
    }

    /**
     * Moves the cursor down in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    navigateDown(times: number) {
        if (this.selection.isMultiLine() &amp;&amp; this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
        }
        this.selection.clearSelection();
        this.selection.moveCursorBy(times || 1, 0);
    }

    /**
     * Moves the cursor left in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    navigateLeft(times: number) {
        if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorLeft();
            }
        }
        this.clearSelection();
    }

    /**
     * Moves the cursor right in the document the specified number of times. Note that this does de-select the current selection.
     * @param {Number} times The number of times to change navigation
     *
     *
     **/
    navigateRight(times: number) {
        if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
        }
        else {
            times = times || 1;
            while (times--) {
                this.selection.moveCursorRight();
            }
        }
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current line. Note that this does de-select the current selection.
     **/
    navigateLineStart() {
        this.selection.moveCursorLineStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current line. Note that this does de-select the current selection.
     **/
    navigateLineEnd() {
        this.selection.moveCursorLineEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the end of the current file. Note that this does de-select the current selection.
     **/
    navigateFileEnd() {
        this.selection.moveCursorFileEnd();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the start of the current file. Note that this does de-select the current selection.
     **/
    navigateFileStart() {
        this.selection.moveCursorFileStart();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the right of the current position. Note that this does de-select the current selection.
     **/
    navigateWordRight() {
        this.selection.moveCursorWordRight();
        this.clearSelection();
    }

    /**
     *
     * Moves the cursor to the word immediately to the left of the current position. Note that this does de-select the current selection.
     **/
    navigateWordLeft() {
        this.selection.moveCursorWordLeft();
        this.clearSelection();
    }

    /**
     * Replaces the first occurance of &#x60;options.needle&#x60; with the value in &#x60;replacement&#x60;.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search &#x60;Search&#x60;]] options to use
     *
     *
     **/
    replace(replacement: string, options): number {
        if (options)
            this.$search.set(options);

        var range = this.$search.find(this.session);
        var replaced = 0;
        if (!range)
            return replaced;

        if (this.$tryReplace(range, replacement)) {
            replaced = 1;
        }
        if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
        }

        return replaced;
    }

    /**
     * Replaces all occurances of &#x60;options.needle&#x60; with the value in &#x60;replacement&#x60;.
     * @param {String} replacement The text to replace with
     * @param {Object} options The [[Search &#x60;Search&#x60;]] options to use
     *
     *
     **/
    replaceAll(replacement: string, options): number {
        if (options) {
            this.$search.set(options);
        }

        var ranges = this.$search.findAll(this.session);
        var replaced = 0;
        if (!ranges.length)
            return replaced;

        this.$blockScrolling += 1;

        var selection = this.getSelectionRange();
        this.selection.moveTo(0, 0);

        for (var i = ranges.length - 1; i &gt;= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
                replaced++;
            }
        }

        this.selection.setSelectionRange(selection);
        this.$blockScrolling -= 1;

        return replaced;
    }

    private $tryReplace(range: Range, replacement: string): Range {
        var input = this.session.getTextRange(range);
        replacement = this.$search.replace(input, replacement);
        if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
        } else {
            return null;
        }
    }

    /**
     * {:Search.getOptions} For more information on &#x60;options&#x60;, see [[Search &#x60;Search&#x60;]].
     * @related Search.getOptions
     * @return {Object}
     **/
    getLastSearchOptions() {
        return this.$search.getOptions();
    }

    /**
     * Attempts to find &#x60;needle&#x60; within the document. For more information on &#x60;options&#x60;, see [[Search &#x60;Search&#x60;]].
     * @param {String} needle The text to search for (optional)
     * @param {Object} options An object defining various search properties
     * @param {Boolean} animate If &#x60;true&#x60; animate scrolling
     *
     *
     * @related Search.find
     **/
    find(needle: (string | RegExp), options, animate?: boolean): Range {
        if (!options)
            options = {};

        if (typeof needle == &quot;string&quot; || needle instanceof RegExp)
            options.needle = needle;
        else if (typeof needle == &quot;object&quot;)
            mixin(options, needle);

        var range = this.selection.getRange();
        if (options.needle == null) {
            needle = this.session.getTextRange(range) || this.$search.$options.needle;
            if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
            }
            this.$search.set({ needle: needle });
        }

        this.$search.set(options);
        if (!options.start)
            this.$search.set({ start: range });

        var newRange = this.$search.find(this.session);
        if (options.preventScroll)
            return newRange;
        if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
        }
        // clear selection if nothing is found
        if (options.backwards)
            range.start = range.end;
        else
            range.end = range.start;
        this.selection.setRange(range);
    }

    /**
     * Performs another search for &#x60;needle&#x60; in the document. For more information on &#x60;options&#x60;, see [[Search &#x60;Search&#x60;]].
     * @param {Object} options search options
     * @param {Boolean} animate If &#x60;true&#x60; animate scrolling
     *
     *
     * @related Editor.find
     **/
    findNext(needle?: (string | RegExp), animate?: boolean) {
        // FIXME: This looks flipped compared to findPrevious. 
        this.find(needle, { skipCurrent: true, backwards: false }, animate);
    }

    /**
     * Performs a search for &#x60;needle&#x60; backwards. For more information on &#x60;options&#x60;, see [[Search &#x60;Search&#x60;]].
     * @param {Object} options search options
     * @param {Boolean} animate If &#x60;true&#x60; animate scrolling
     *
     *
     * @related Editor.find
     **/
    findPrevious(needle?: (string | RegExp), animate?: boolean) {
        this.find(needle, { skipCurrent: true, backwards: true }, animate);
    }

    revealRange(range: Range, animate: boolean): void {
        this.$blockScrolling += 1;
        this.session.unfold(range);
        this.selection.setSelectionRange(range);
        this.$blockScrolling -= 1;

        var scrollTop = this.renderer.scrollTop;
        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
        if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
    }

    /**
     * {:UndoManager.undo}
     * @related UndoManager.undo
     **/
    undo() {
        this.$blockScrolling++;
        this.session.getUndoManager().undo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     * {:UndoManager.redo}
     * @related UndoManager.redo
     **/
    redo() {
        this.$blockScrolling++;
        this.session.getUndoManager().redo();
        this.$blockScrolling--;
        this.renderer.scrollCursorIntoView(null, 0.5);
    }

    /**
     *
     * Cleans up the entire editor.
     **/
    destroy() {
        this.renderer.destroy();
        this._signal(&quot;destroy&quot;, this);
    }

    /**
     * Enables automatic scrolling of the cursor into view when editor itself is inside scrollable element
     * @param {Boolean} enable default true
     **/
    setAutoScrollEditorIntoView(enable: boolean) {
        if (!enable)
            return;
        var rect;
        var self = this;
        var shouldScroll = false;
        if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement(&quot;div&quot;);
        var scrollAnchor = this.$scrollAnchor;
        scrollAnchor.style.cssText = &quot;position:absolute&quot;;
        this.container.insertBefore(scrollAnchor, this.container.firstChild);
        var onChangeSelection = this.on(&quot;changeSelection&quot;, function() {
            shouldScroll = true;
        });
        // needed to not trigger sync reflow
        var onBeforeRender = this.renderer.on(&quot;beforeRender&quot;, function() {
            if (shouldScroll)
                rect = self.renderer.container.getBoundingClientRect();
        });
        var onAfterRender = this.renderer.on(&quot;afterRender&quot;, function() {
            if (shouldScroll &amp;&amp; rect &amp;&amp; self.isFocused()) {
                var renderer = self.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config = renderer.layerConfig;
                var top = pos.top - config.offset;
                if (pos.top &gt;= 0 &amp;&amp; top + rect.top &lt; 0) {
                    shouldScroll = true;
                }
                else if (pos.top &lt; config.height &amp;&amp;
                    pos.top + rect.top + config.lineHeight &gt; window.innerHeight) {
                    shouldScroll = false;
                }
                else {
                    shouldScroll = null;
                }
                if (shouldScroll != null) {
                    scrollAnchor.style.top = top + &quot;px&quot;;
                    scrollAnchor.style.left = pos.left + &quot;px&quot;;
                    scrollAnchor.style.height = config.lineHeight + &quot;px&quot;;
                    scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
            }
        });
        this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
                return;
            delete this.setAutoScrollEditorIntoView;
            this.removeEventListener(&quot;changeSelection&quot;, onChangeSelection);
            this.renderer.removeEventListener(&quot;afterRender&quot;, onAfterRender);
            this.renderer.removeEventListener(&quot;beforeRender&quot;, onBeforeRender);
        };
    }

    public $resetCursorStyle() {
        var style = this.$cursorStyle || &quot;ace&quot;;
        var cursorLayer = this.renderer.$cursorLayer;
        if (!cursorLayer) {
            return;
        }
        cursorLayer.setSmoothBlinking(/smooth/.test(style));
        cursorLayer.isBlinking = !this.$readOnly &amp;&amp; style != &quot;wide&quot;;
        setCssClass(cursorLayer.element, &quot;ace_slim-cursors&quot;, /slim/.test(style));
    }
}

defineOptions(Editor.prototype, &quot;editor&quot;, {
    selectionStyle: {
        set: function(style) {
            var that: Editor = this;
            that.$onSelectionChange(void 0, that.selection);
            that._signal(&quot;changeSelectionStyle&quot;, { data: style });
        },
        initialValue: &quot;line&quot;
    },
    highlightActiveLine: {
        set: function() {
            var that: Editor = this;
            that.$updateHighlightActiveLine();
        },
        initialValue: true
    },
    highlightSelectedWord: {
        set: function(shouldHighlight) {
            var that: Editor = this;
            that.$onSelectionChange(void 0, that.selection);
        },
        initialValue: true
    },
    readOnly: {
        set: function(readOnly) {
            // disabled to not break vim mode!
            // this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
        },
        initialValue: false
    },
    cursorStyle: {
        set: function(val) {
            var that: Editor = this;
            that.$resetCursorStyle();
        },
        values: [&quot;ace&quot;, &quot;slim&quot;, &quot;smooth&quot;, &quot;wide&quot;],
        initialValue: &quot;ace&quot;
    },
    mergeUndoDeltas: {
        values: [false, true, &quot;always&quot;],
        initialValue: true
    },
    behavioursEnabled: { initialValue: true },
    wrapBehavioursEnabled: { initialValue: true },
    autoScrollEditorIntoView: {
        set: function(enable: boolean) {
            var that: Editor = this;
            that.setAutoScrollEditorIntoView(enable);
        }
    },

    hScrollBarAlwaysVisible: &quot;renderer&quot;,
    vScrollBarAlwaysVisible: &quot;renderer&quot;,
    highlightGutterLine: &quot;renderer&quot;,
    animatedScroll: &quot;renderer&quot;,
    showInvisibles: &quot;renderer&quot;,
    showPrintMargin: &quot;renderer&quot;,
    printMarginColumn: &quot;renderer&quot;,
    printMargin: &quot;renderer&quot;,
    fadeFoldWidgets: &quot;renderer&quot;,
    showFoldWidgets: &quot;renderer&quot;,
    showLineNumbers: &quot;renderer&quot;,
    showGutter: &quot;renderer&quot;,
    displayIndentGuides: &quot;renderer&quot;,
    fontSize: &quot;renderer&quot;,
    fontFamily: &quot;renderer&quot;,
    maxLines: &quot;renderer&quot;,
    minLines: &quot;renderer&quot;,
    scrollPastEnd: &quot;renderer&quot;,
    fixedWidthGutter: &quot;renderer&quot;,
    theme: &quot;renderer&quot;,

    scrollSpeed: &quot;$mouseHandler&quot;,
    dragDelay: &quot;$mouseHandler&quot;,
    dragEnabled: &quot;$mouseHandler&quot;,
    focusTimout: &quot;$mouseHandler&quot;,
    tooltipFollowsMouse: &quot;$mouseHandler&quot;,

    firstLineNumber: &quot;session&quot;,
    overwrite: &quot;session&quot;,
    newLineMode: &quot;session&quot;,
    useWorker: &quot;session&quot;,
    useSoftTabs: &quot;session&quot;,
    tabSize: &quot;session&quot;,
    wrap: &quot;session&quot;,
    foldStyle: &quot;session&quot;,
    mode: &quot;session&quot;
});

class FoldHandler {
    constructor(editor: Editor) {

        // The following handler detects clicks in the editor (not gutter) region
        // to determine whether to remove or expand a fold.
        editor.on(&quot;click&quot;, function(e: EditorMouseEvent) {
            var position = e.getDocumentPosition();
            var session = editor.getSession();

            // If the user clicked on a fold, then expand it.
            var fold = session.getFoldAt(position.row, position.column, 1);
            if (fold) {
                if (e.getAccelKey()) {
                    session.removeFold(fold);
                }
                else {
                    session.expandFold(fold);
                }
                e.stop();
            }
            else {
            }
        });

        // The following handler detects clicks on the gutter.
        editor.on(&#x27;gutterclick&#x27;, function(e: EditorMouseEvent) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
            if (gutterRegion === &#x27;foldWidgets&#x27;) {
                var row = e.getDocumentPosition().row;
                var session = editor.getSession();
                if (session[&#x27;foldWidgets&#x27;] &amp;&amp; session[&#x27;foldWidgets&#x27;][row]) {
                    session[&#x27;onFoldWidgetClick&#x27;](row, e);
                }
                if (!editor.isFocused()) {
                    editor.focus();
                }
                e.stop();
            }
        });

        editor.on(&#x27;gutterdblclick&#x27;, function(e: EditorMouseEvent) {
            var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);

            if (gutterRegion == &#x27;foldWidgets&#x27;) {
                var row = e.getDocumentPosition().row;
                var session = editor.getSession();
                var data = session[&#x27;getParentFoldRangeData&#x27;](row, true);
                var range = data.range || data.firstRange;

                if (range) {
                    row = range.start.row;
                    var fold = session.getFoldAt(row, session.getLine(row).length, 1);

                    if (fold) {
                        session.removeFold(fold);
                    }
                    else {
                        session[&#x27;addFold&#x27;](&quot;...&quot;, range);
                        editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                    }
                }
                e.stop();
            }
        });
    }
}

interface IGestureHandler {
    cancelContextMenu(): void;
}

class MouseHandler {
    public editor: Editor;
    private $scrollSpeed: number = 2;
    private $dragDelay: number = 0;
    private $dragEnabled: boolean = true;
    public $focusTimout: number = 0;
    public $tooltipFollowsMouse: boolean = true;
    private state: string;
    private clientX: number;
    private clientY: number;
    public isMousePressed: boolean;
    /**
     * The function to call to release a captured mouse.
     */
    private releaseMouse: (event: MouseEvent) =&gt; void;
    private mouseEvent: EditorMouseEvent;
    public mousedownEvent: EditorMouseEvent;
    private $mouseMoved;
    private $onCaptureMouseMove;
    public $clickSelection: Range = null;
    public $lastScrollTime: number;
    public selectByLines: () =&gt; void;
    public selectByWords: () =&gt; void;
    constructor(editor: Editor) {
        // FIXME: Did I mention that &#x60;this&#x60;, &#x60;new&#x60;, &#x60;class&#x60;, &#x60;bind&#x60; are the 4 horsemen?
        // FIXME: Function Scoping is the answer.
        var _self = this;
        this.editor = editor;

        // FIXME: We should be cleaning up these handlers in a dispose method...
        editor.setDefaultHandler(&#x27;mousedown&#x27;, makeMouseDownHandler(editor, this));
        editor.setDefaultHandler(&#x27;mousewheel&#x27;, makeMouseWheelHandler(editor, this));
        editor.setDefaultHandler(&quot;dblclick&quot;, makeDoubleClickHandler(editor, this));
        editor.setDefaultHandler(&quot;tripleclick&quot;, makeTripleClickHandler(editor, this));
        editor.setDefaultHandler(&quot;quadclick&quot;, makeQuadClickHandler(editor, this));

        this.selectByLines = makeExtendSelectionBy(editor, this, &quot;getLineRange&quot;);
        this.selectByWords = makeExtendSelectionBy(editor, this, &quot;getWordRange&quot;);

        new GutterHandler(this);
        //      FIXME: new DragdropHandler(this);

        var onMouseDown = function(e) {
            if (!editor.isFocused() &amp;&amp; editor.textInput) {
                editor.textInput.moveToMouse(e);
            }
            editor.focus()
        };

        var mouseTarget: HTMLDivElement = editor.renderer.getMouseEventTarget();
        addListener(mouseTarget, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;click&quot;));
        addListener(mouseTarget, &quot;mousemove&quot;, this.onMouseMove.bind(this, &quot;mousemove&quot;));
        addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, &quot;onMouseEvent&quot;);
        if (editor.renderer.scrollBarV) {
            addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, &quot;onMouseEvent&quot;);
            addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, &quot;onMouseEvent&quot;);
            if (isIE) {
                addListener(editor.renderer.scrollBarV.element, &quot;mousedown&quot;, onMouseDown);
                // TODO: I wonder if we should be responding to mousedown (by symmetry)?
                addListener(editor.renderer.scrollBarH.element, &quot;mousemove&quot;, onMouseDown);
            }
        }

        // We hook &#x27;mousewheel&#x27; using the portable 
        addMouseWheelListener(editor.container, this.emitEditorMouseWheelEvent.bind(this, &quot;mousewheel&quot;));

        var gutterEl = editor.renderer.$gutter;
        addListener(gutterEl, &quot;mousedown&quot;, this.onMouseEvent.bind(this, &quot;guttermousedown&quot;));
        addListener(gutterEl, &quot;click&quot;, this.onMouseEvent.bind(this, &quot;gutterclick&quot;));
        addListener(gutterEl, &quot;dblclick&quot;, this.onMouseEvent.bind(this, &quot;gutterdblclick&quot;));
        addListener(gutterEl, &quot;mousemove&quot;, this.onMouseEvent.bind(this, &quot;guttermousemove&quot;));

        addListener(mouseTarget, &quot;mousedown&quot;, onMouseDown);

        addListener(gutterEl, &quot;mousedown&quot;, function(e) {
            editor.focus();
            return preventDefault(e);
        });

        // Handle &#x60;mousemove&#x60; while the mouse is over the editing area (and not the gutter).
        editor.on(&#x27;mousemove&#x27;, function(e: MouseEvent) {
            if (_self.state || _self.$dragDelay || !_self.$dragEnabled) {
                return;
            }
            // FIXME: Probably s/b clientXY
            var char = editor.renderer.screenToTextCoordinates(e.x, e.y);
            var range = editor.getSession().getSelection().getRange();
            var renderer = editor.renderer;

            if (!range.isEmpty() &amp;&amp; range.insideStart(char.row, char.column)) {
                renderer.setCursorStyle(&#x27;default&#x27;);
            }
            else {
                renderer.setCursorStyle(&quot;&quot;);
            }
        });
    }

    onMouseEvent(name: string, e: MouseEvent) {
        this.editor._emit(name, new EditorMouseEvent(e, this.editor));
    }

    onMouseMove(name: string, e: MouseEvent) {
        // If nobody is listening, avoid the creation of the temporary wrapper.
        // optimization, because mousemove doesn&#x27;t have a default handler.
        var listeners = this.editor._eventRegistry &amp;&amp; this.editor._eventRegistry[&#x27;mousemove&#x27;];
        if (!listeners || !listeners.length) {
            return;
        }

        this.editor._emit(name, new EditorMouseEvent(e, this.editor));
    }

    emitEditorMouseWheelEvent(name: string, e: MouseWheelEvent) {
        var mouseEvent = new EditorMouseEvent(e, this.editor);
        mouseEvent.speed = this.$scrollSpeed * 2;
        mouseEvent.wheelX = e[&#x27;wheelX&#x27;];
        mouseEvent.wheelY = e[&#x27;wheelY&#x27;];
        this.editor._emit(name, mouseEvent);
    }

    setState(state: string) {
        this.state = state;
    }

    textCoordinates(): { row: number; column: number } {
        return this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
    }

    captureMouse(ev: EditorMouseEvent, mouseMoveHandler?: (mouseEvent: MouseEvent) =&gt; void) {
        this.clientX = ev.clientX;
        this.clientY = ev.clientY;

        this.isMousePressed = true;

        // do not move textarea during selection
        var renderer = this.editor.renderer;
        if (renderer.$keepTextAreaAtCursor) {
            renderer.$keepTextAreaAtCursor = null;
        }

        var onMouseMove = (function(editor: Editor, mouseHandler: MouseHandler) {
            return function(mouseEvent: MouseEvent) {
                if (!mouseEvent) return;
                // if editor is loaded inside iframe, and mouseup event is outside
                // we won&#x27;t recieve it, so we cancel on first mousemove without button
                if (isWebKit &amp;&amp; !mouseEvent.which &amp;&amp; mouseHandler.releaseMouse) {
                    // TODO: For backwards compatibility I&#x27;m passing undefined,
                    // but it would probably make more sense to pass the mouse event
                    // since that is the final event.
                    return mouseHandler.releaseMouse(undefined);
                }

                mouseHandler.clientX = mouseEvent.clientX;
                mouseHandler.clientY = mouseEvent.clientY;
                mouseMoveHandler &amp;&amp; mouseMoveHandler(mouseEvent);
                mouseHandler.mouseEvent = new EditorMouseEvent(mouseEvent, editor);
                mouseHandler.$mouseMoved = true;
            }
        })(this.editor, this);

        var onCaptureEnd = (function(mouseHandler: MouseHandler) {
            return function(e) {
                clearInterval(timerId);
                onCaptureInterval();
                mouseHandler[mouseHandler.state + &quot;End&quot;] &amp;&amp; mouseHandler[mouseHandler.state + &quot;End&quot;](e);
                mouseHandler.state = &quot;&quot;;
                if (renderer.$keepTextAreaAtCursor == null) {
                    renderer.$keepTextAreaAtCursor = true;
                    renderer.$moveTextAreaToCursor();
                }
                mouseHandler.isMousePressed = false;
                mouseHandler.$onCaptureMouseMove = mouseHandler.releaseMouse = null;
                e &amp;&amp; mouseHandler.onMouseEvent(&quot;mouseup&quot;, e);
            }
        })(this);

        var onCaptureInterval = (function(mouseHandler: MouseHandler) {
            return function() {
                mouseHandler[mouseHandler.state] &amp;&amp; mouseHandler[mouseHandler.state]();
                mouseHandler.$mouseMoved = false;
            }
        })(this);

        if (isOldIE &amp;&amp; ev.domEvent.type == &quot;dblclick&quot;) {
            return setTimeout(function() { onCaptureEnd(ev); });
        }

        this.$onCaptureMouseMove = onMouseMove;
        this.releaseMouse = capture(this.editor.container, onMouseMove, onCaptureEnd);
        var timerId = setInterval(onCaptureInterval, 20);
    }

    cancelContextMenu(): void {
        var stop = function(e) {
            if (e &amp;&amp; e.domEvent &amp;&amp; e.domEvent.type != &quot;contextmenu&quot;) {
                return;
            }
            this.editor.off(&quot;nativecontextmenu&quot;, stop);
            if (e &amp;&amp; e.domEvent) {
                stopEvent(e.domEvent);
            }
        }.bind(this);
        setTimeout(stop, 10);
        this.editor.on(&quot;nativecontextmenu&quot;, stop);
    }

    select() {
        var anchor: { row: number; column: number };
        var cursor = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);

        if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);

            if (cmp == -1) {
                anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
            } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            this.editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        this.editor.selection.selectToPosition(cursor);

        this.editor.renderer.scrollCursorIntoView();
    }

    selectByLinesEnd() {
        this.$clickSelection = null;
        this.editor.unsetStyle(&quot;ace_selecting&quot;);
        if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
        }
    }

    startSelect(pos: { row: number; column: number }, waitForClickSelection?: boolean) {
        pos = pos || this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        var editor = this.editor;
        // allow double/triple click handlers to change selection
    
        if (this.mousedownEvent.getShiftKey()) {
            editor.selection.selectToPosition(pos);
        }
        else if (!waitForClickSelection) {
            editor.selection.moveToPosition(pos);
        }

        if (!waitForClickSelection) {
            this.select();
        }

        if (this.editor.renderer.scroller.setCapture) {
            this.editor.renderer.scroller.setCapture();
        }
        editor.setStyle(&quot;ace_selecting&quot;);
        this.setState(&quot;select&quot;);
    }

    selectEnd() {
        this.selectByLinesEnd();
    }

    selectAllEnd() {
        this.selectByLinesEnd();
    }

    selectByWordsEnd() {
        this.selectByLinesEnd();
    }

    focusWait() {
        var distance = calcDistance(this.mousedownEvent.clientX, this.mousedownEvent.clientY, this.clientX, this.clientY);
        var time = Date.now();

        if (distance &gt; DRAG_OFFSET || time - this.mousedownEvent.time &gt; this.$focusTimout) {
            this.startSelect(this.mousedownEvent.getDocumentPosition());
        }
    }

}

defineOptions(MouseHandler.prototype, &quot;mouseHandler&quot;, {
    scrollSpeed: { initialValue: 2 },
    dragDelay: { initialValue: (isMac ? 150 : 0) },
    dragEnabled: { initialValue: true },
    focusTimout: { initialValue: 0 },
    tooltipFollowsMouse: { initialValue: true }
});

/*
 * Custom Ace mouse event
 */
class EditorMouseEvent {
    // We keep the original DOM event
    public domEvent: MouseEvent;
    private editor: Editor;
    public clientX: number;
    public clientY: number;
    /**
     * Cached text coordinates following getDocumentPosition()
     */
    private $pos: { row: number; column: number };
    private $inSelection;
    private propagationStopped = false;
    private defaultPrevented = false;
    public time: number;
    // wheelY, wheelY and speed are for &#x27;mousewheel&#x27; events.
    public wheelX: number;
    public wheelY: number;
    public speed: number;
    constructor(domEvent: MouseEvent, editor: Editor) {
        this.domEvent = domEvent;
        this.editor = editor;

        this.clientX = domEvent.clientX;
        this.clientY = domEvent.clientY;

        this.$pos = null;
        this.$inSelection = null;
    }

    get toElement() {
        return this.domEvent.toElement;
    }

    stopPropagation() {
        stopPropagation(this.domEvent);
        this.propagationStopped = true;
    }

    preventDefault() {
        preventDefault(this.domEvent);
        this.defaultPrevented = true;
    }

    stop() {
        this.stopPropagation();
        this.preventDefault();
    }

    /*
     * Get the document position below the mouse cursor
     * 
     * @return {Object} &#x27;row&#x27; and &#x27;column&#x27; of the document position
     */
    getDocumentPosition(): { row: number; column: number } {
        if (!this.$pos) {
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
        }
        return this.$pos;
    }
    
    /*
     * Check if the mouse cursor is inside of the text selection
     * 
     * @return {Boolean} whether the mouse cursor is inside of the selection
     */
    inSelection() {
        if (this.$inSelection !== null)
            return this.$inSelection;

        var editor = this.editor;


        var selectionRange = editor.getSelectionRange();
        if (selectionRange.isEmpty())
            this.$inSelection = false;
        else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
        }

        return this.$inSelection;
    }
    
    /*
     * Get the clicked mouse button
     * 
     * @return {Number} 0 for left button, 1 for middle button, 2 for right button
     */
    getButton() {
        return getButton(this.domEvent);
    }
    
    /*
     * @return {Boolean} whether the shift key was pressed when the event was emitted
     */
    getShiftKey() {
        return this.domEvent.shiftKey;
    }

    getAccelKey = isMac ? function() { return this.domEvent.metaKey; } : function() { return this.domEvent.ctrlKey; };
}

var DRAG_OFFSET = 0; // pixels

function makeMouseDownHandler(editor: Editor, mouseHandler: MouseHandler) {
    return function(ev: EditorMouseEvent) {
        var inSelection = ev.inSelection();
        var pos = ev.getDocumentPosition();
        mouseHandler.mousedownEvent = ev;

        var button = ev.getButton();
        if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();

            if (selectionEmpty)
                editor.selection.moveToPosition(pos);

            // 2: contextmenu, 1: linux paste
            editor.textInput.onContextMenu(ev.domEvent);
            return; // stopping event here breaks contextmenu on ff mac
        }

        mouseHandler.mousedownEvent.time = Date.now();
        // if this click caused the editor to be focused should not clear the
        // selection
        if (inSelection &amp;&amp; !editor.isFocused()) {
            editor.focus();
            if (mouseHandler.$focusTimout &amp;&amp; !mouseHandler.$clickSelection &amp;&amp; !editor.inMultiSelectMode) {
                mouseHandler.setState(&quot;focusWait&quot;);
                mouseHandler.captureMouse(ev);
                return;
            }
        }

        mouseHandler.captureMouse(ev);
        // TODO: _clicks is a custom property added in event.ts by the &#x27;mousedown&#x27; listener.
        mouseHandler.startSelect(pos, ev.domEvent[&#x27;_clicks&#x27;] &gt; 1);
        return ev.preventDefault();
    }
}

function makeMouseWheelHandler(editor: Editor, mouseHandler: MouseHandler) {
    return function(ev: EditorMouseEvent) {
        if (ev.getAccelKey()) {
            return;
        }

        //shift wheel to horiz scroll
        if (ev.getShiftKey() &amp;&amp; ev.wheelY &amp;&amp; !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
        }

        var t = ev.domEvent.timeStamp;
        var dt = t - (mouseHandler.$lastScrollTime || 0);

        var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
        if (isScrolable || dt &lt; 200) {
            mouseHandler.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
        }
    }
}

function makeDoubleClickHandler(editor: Editor, mouseHandler: MouseHandler) {
    return function(editorMouseEvent: EditorMouseEvent) {
        var pos = editorMouseEvent.getDocumentPosition();
        var session = editor.getSession();

        var range = session.getBracketRange(pos);
        if (range) {
            if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
            }
            mouseHandler.setState(&quot;select&quot;);
        }
        else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            mouseHandler.setState(&quot;selectByWords&quot;);
        }
        mouseHandler.$clickSelection = range;
        mouseHandler.select();
    }
}

function makeTripleClickHandler(editor: Editor, mouseHandler: MouseHandler) {
    return function(editorMouseEvent: EditorMouseEvent) {
        var pos = editorMouseEvent.getDocumentPosition();

        mouseHandler.setState(&quot;selectByLines&quot;);
        var range = editor.getSelectionRange();
        if (range.isMultiLine() &amp;&amp; range.contains(pos.row, pos.column)) {
            mouseHandler.$clickSelection = editor.selection.getLineRange(range.start.row);
            mouseHandler.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
        }
        else {
            mouseHandler.$clickSelection = editor.selection.getLineRange(pos.row);
        }
        mouseHandler.select();
    }
}

function makeQuadClickHandler(editor: Editor, mouseHandler: MouseHandler) {
    return function(editorMouseEvent: EditorMouseEvent) {
        editor.selectAll();
        mouseHandler.$clickSelection = editor.getSelectionRange();
        mouseHandler.setState(&quot;selectAll&quot;);
    }
}

function makeExtendSelectionBy(editor: Editor, mouseHandler: MouseHandler, unitName: string) {
    return function() {
        var anchor;
        var cursor = mouseHandler.textCoordinates();
        var range = editor.selection[unitName](cursor.row, cursor.column);

        if (mouseHandler.$clickSelection) {
            var cmpStart = mouseHandler.$clickSelection.comparePoint(range.start);
            var cmpEnd = mouseHandler.$clickSelection.comparePoint(range.end);

            if (cmpStart == -1 &amp;&amp; cmpEnd &lt;= 0) {
                anchor = mouseHandler.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                    cursor = range.start;
            }
            else if (cmpEnd == 1 &amp;&amp; cmpStart &gt;= 0) {
                anchor = mouseHandler.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                    cursor = range.end;
            }
            else if (cmpStart == -1 &amp;&amp; cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
            }
            else {
                var orientedRange = calcRangeOrientation(mouseHandler.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
        }
        editor.selection.selectToPosition(cursor);

        editor.renderer.scrollCursorIntoView();
    }
}

function calcDistance(ax: number, ay: number, bx: number, by: number) {
    return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
}

function calcRangeOrientation(range: Range, cursor: { row: number; column: number }): { cursor: { row: number; column: number }; anchor: { row: number; column: number } } {
    if (range.start.row == range.end.row) {
        var cmp = 2 * cursor.column - range.start.column - range.end.column;
    }
    else if (range.start.row == range.end.row - 1 &amp;&amp; !range.start.column &amp;&amp; !range.end.column) {
        var cmp = cursor.column - 4;
    }
    else {
        var cmp = 2 * cursor.row - range.start.row - range.end.row;
    }

    if (cmp &lt; 0) {
        return { cursor: range.start, anchor: range.end };
    }
    else {
        return { cursor: range.end, anchor: range.start };
    }
}

class GutterHandler {
    constructor(mouseHandler: MouseHandler) {
        var editor: Editor = mouseHandler.editor;
        var gutter: Gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);

        mouseHandler.editor.setDefaultHandler(&quot;guttermousedown&quot;, function(e: EditorMouseEvent) {
            if (!editor.isFocused() || e.getButton() != 0) {
                return;
            }

            var gutterRegion = gutter.getRegion(e);

            if (gutterRegion === &quot;foldWidgets&quot;) {
                return;
            }

            var row = e.getDocumentPosition().row;
            var selection = editor.getSession().getSelection();

            if (e.getShiftKey()) {
                selection.selectTo(row, 0);
            }
            else {
                if (e.domEvent.detail == 2) {
                    editor.selectAll();
                    return e.preventDefault();
                }
                mouseHandler.$clickSelection = editor.selection.getLineRange(row);
            }
            mouseHandler.setState(&quot;selectByLines&quot;);
            mouseHandler.captureMouse(e);
            return e.preventDefault();
        });


        var tooltipTimeout: number;
        var mouseEvent: EditorMouseEvent;
        var tooltipAnnotation;

        function showTooltip() {
            var row = mouseEvent.getDocumentPosition().row;
            var annotation = gutter.$annotations[row];
            if (!annotation) {
                return hideTooltip(void 0, editor);
            }

            var session = editor.getSession();
            var maxRow = session.getLength();
            if (row == maxRow) {
                var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.clientY).row;
                var pos = mouseEvent.getDocumentPosition();
                if (screenRow &gt; session.documentToScreenRow(pos.row, pos.column)) {
                    return hideTooltip(void 0, editor);
                }
            }

            if (tooltipAnnotation == annotation) {
                return;
            }
            tooltipAnnotation = annotation.text.join(&quot;&lt;br/&gt;&quot;);

            tooltip.setHtml(tooltipAnnotation);

            tooltip.show();

            editor.on(&quot;mousewheel&quot;, hideTooltip);

            if (mouseHandler.$tooltipFollowsMouse) {
                moveTooltip(mouseEvent);
            }
            else {
                var gutterElement = gutter.$cells[editor.getSession().documentToScreenRow(row, 0)].element;
                var rect = gutterElement.getBoundingClientRect();
                var style = tooltip.getElement().style;
                style.left = rect.right + &quot;px&quot;;
                style.top = rect.bottom + &quot;px&quot;;
            }
        }

        function hideTooltip(event, editor: Editor) {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = undefined;
            }
            if (tooltipAnnotation) {
                tooltip.hide();
                tooltipAnnotation = null;
                editor.off(&quot;mousewheel&quot;, hideTooltip);
            }
        }

        function moveTooltip(event: EditorMouseEvent) {
            tooltip.setPosition(event.clientX, event.clientY);
        }

        mouseHandler.editor.setDefaultHandler(&quot;guttermousemove&quot;, function(e: EditorMouseEvent) {
            // FIXME: Obfuscating the type of target to thwart compiler.
            var target: any = e.domEvent.target || e.domEvent.srcElement;
            if (hasCssClass(target, &quot;ace_fold-widget&quot;)) {
                return hideTooltip(void 0, editor);
            }

            if (tooltipAnnotation &amp;&amp; mouseHandler.$tooltipFollowsMouse) {
                moveTooltip(e);
            }

            mouseEvent = e;
            if (tooltipTimeout) {
                return;
            }
            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                if (mouseEvent &amp;&amp; !mouseHandler.isMousePressed)
                    showTooltip();
                else
                    hideTooltip(void 0, editor);
            }, 50);
        });

        addListener(editor.renderer.$gutter, &quot;mouseout&quot;, function(e: MouseEvent) {
            mouseEvent = null;
            if (!tooltipAnnotation || tooltipTimeout)
                return;

            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                hideTooltip(void 0, editor);
            }, 50);
        });

        editor.on(&quot;changeSession&quot;, hideTooltip);
    }
}

/**
 * @class GutterTooltip
 * @extends Tooltip
 */
class GutterTooltip extends Tooltip {
    constructor(parentNode: HTMLElement) {
        super(parentNode);
    }
    /**
     * @method setPosition
     * @param x {number}
     * @param y {number}
     * @return {void}
     */
    setPosition(x: number, y: number): void {
        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
        var width = this.getWidth();
        var height = this.getHeight();
        x += 15;
        y += 15;
        if (x + width &gt; windowWidth) {
            x -= (x + width) - windowWidth;
        }
        if (y + height &gt; windowHeight) {
            y -= 20 + height;
        }
        super.setPosition(x, y);
    }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
