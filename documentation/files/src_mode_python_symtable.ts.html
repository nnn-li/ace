<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/mode/python/symtable.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.16</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Anchor.html">Anchor</a></li>
                                <li><a href="../classes/BackgroundTokenizer.html">BackgroundTokenizer</a></li>
                                <li><a href="../classes/Editor.html">Editor</a></li>
                                <li><a href="../classes/EditorDocument.html">EditorDocument</a></li>
                                <li><a href="../classes/EditSession.html">EditSession</a></li>
                                <li><a href="../classes/Fold.html">Fold</a></li>
                                <li><a href="../classes/FoldLine.html">FoldLine</a></li>
                                <li><a href="../classes/GutterTooltip.html">GutterTooltip</a></li>
                                <li><a href="../classes/HScrollBar.html">HScrollBar</a></li>
                                <li><a href="../classes/HtmlMode.html">HtmlMode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Mode.html">Mode</a></li>
                                <li><a href="../classes/Position.html">Position</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ScrollBar.html">ScrollBar</a></li>
                                <li><a href="../classes/Search.html">Search</a></li>
                                <li><a href="../classes/Selection.html">Selection</a></li>
                                <li><a href="../classes/TokenIterator.html">TokenIterator</a></li>
                                <li><a href="../classes/Tokenizer.html">Tokenizer</a></li>
                                <li><a href="../classes/Tooltip.html">Tooltip</a></li>
                                <li><a href="../classes/UndoManager.html">UndoManager</a></li>
                                <li><a href="../classes/VirtualRenderer.html">VirtualRenderer</a></li>
                                <li><a href="../classes/VScrollBar.html">VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/mode/python/symtable.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import astnodes = require(&#x27;./astnodes&#x27;);
import base = require(&#x27;./base&#x27;);
import asserts = require(&#x27;./asserts&#x27;);

/* Flags for def-use information */

var DEF_GLOBAL = 1;           /* global stmt */
var DEF_LOCAL = 2;            /* assignment in code block */
var DEF_PARAM = 2 &lt;&lt; 1;       /* formal parameter */
var USE = 2 &lt;&lt; 2;             /* name is used */
var DEF_STAR = 2 &lt;&lt; 3;        /* parameter is star arg */
var DEF_DOUBLESTAR = 2 &lt;&lt; 4;  /* parameter is star-star arg */
var DEF_INTUPLE = 2 &lt;&lt; 5;     /* name defined in tuple in parameters */
var DEF_FREE = 2 &lt;&lt; 6;        /* name used but not defined in nested block */
var DEF_FREE_GLOBAL = 2 &lt;&lt; 7; /* free variable is actually implicit global */
var DEF_FREE_CLASS = 2 &lt;&lt; 8;  /* free variable from class&#x27;s method */
var DEF_IMPORT = 2 &lt;&lt; 9;      /* assignment occurred via import */

var DEF_BOUND = (DEF_LOCAL | DEF_PARAM | DEF_IMPORT);

/* GLOBAL_EXPLICIT and GLOBAL_IMPLICIT are used internally by the symbol
   table.  GLOBAL is returned from PyST_GetScope() for either of them.
   It is stored in ste_symbols at bits 12-14.
*/
var SCOPE_OFF = 11;
var SCOPE_MASK = 7;

export var LOCAL = 1;
export var GLOBAL_EXPLICIT = 2;
export var GLOBAL_IMPLICIT = 3;
export var FREE = 4;
export var CELL = 5;

/* The following three names are used for the ste_unoptimized bit field */
var OPT_IMPORT_STAR = 1;
var OPT_EXEC = 2;
var OPT_BARE_EXEC = 4;
var OPT_TOPLEVEL = 8;  /* top-level names, including eval and exec */

var GENERATOR = 2;
var GENERATOR_EXPRESSION = 2;

var ModuleBlock = &#x27;module&#x27;;
export var FunctionBlock = &#x27;function&#x27;;
var ClassBlock = &#x27;class&#x27;;

/**
 * @param {string} message
 * @param {string} fileName
 * @param {number=} lineNumber
 */
function syntaxError(message: string, fileName: string, lineNumber?: number) {
    asserts.assert(base.isString(message), &quot;message must be a string&quot;);
    asserts.assert(base.isString(fileName), &quot;fileName must be a string&quot;);
    if (base.isDef(lineNumber)) {
        asserts.assert(base.isNumber(lineNumber), &quot;lineNumber must be a number&quot;);
    }
    var e = new SyntaxError(message);
    e[&#x27;fileName&#x27;] = fileName;
    if (typeof lineNumber === &#x27;number&#x27;) {
        e[&#x27;lineNumber&#x27;] = lineNumber;
    }
    return e;
}

/**
 * @param {string|null} priv
 * @param {string} name
 */
export function mangleName(priv: string, name: string): string {
    var strpriv: string = null;

    if (priv === null || name === null || name.charAt(0) !== &#x27;_&#x27; || name.charAt(1) !== &#x27;_&#x27;)
        return name;
    // don&#x27;t mangle __id__
    if (name.charAt(name.length - 1) === &#x27;_&#x27; &amp;&amp; name.charAt(name.length - 2) === &#x27;_&#x27;)
        return name;
    // don&#x27;t mangle classes that are all _ (obscure much?)
    strpriv = priv;
    strpriv.replace(/_/g, &#x27;&#x27;);
    if (strpriv === &#x27;&#x27;)
        return name;

    strpriv = priv;
    strpriv.replace(/^_*/, &#x27;&#x27;);
    strpriv = &#x27;_&#x27; + strpriv + name;
    return strpriv;
}

class Symbol {
    private __name;
    private __flags;
    private __scope;
    private __namespaces;
    constructor(name, flags, namespaces) {
        this.__name = name;
        this.__flags = flags;
        this.__scope = (flags &gt;&gt; SCOPE_OFF) &amp; SCOPE_MASK;
        this.__namespaces = namespaces || [];
    }

    get_name() {
        return this.__name;
        
    }

    is_referenced() {
        return !!(this.__flags &amp; USE);
        
    }

    is_parameter() {
        return !!(this.__flags &amp; DEF_PARAM);
    }

    is_global() {
        return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
    }

    is_declared_global() {
        return this.__scope == GLOBAL_EXPLICIT;
    }

    is_local() {
        return !!(this.__flags &amp; DEF_BOUND);
    }

    is_free() {
        return this.__scope == FREE;
    }

    is_imported() {
        return !!(this.__flags &amp; DEF_IMPORT);
    }

    is_assigned() {
        return !!(this.__flags &amp; DEF_LOCAL);
    }

    is_namespace() {
        return this.__namespaces &amp;&amp; this.__namespaces.length &gt; 0;
    }
    
    get_namespaces() {
        return this.__namespaces;
    }
}

var astScopeCounter = 0;

export class SymbolTableScope {
    public symFlags;
    private name: string;
    public varnames: string[];
    public children: SymbolTableScope[];
    public blockType: string;
    public isNested: boolean;
    public hasFree: boolean;
    public childHasFree: boolean;
    public generator: boolean;
    public varargs: boolean;
    public varkeywords: boolean;
    public returnsValue: boolean;
    public lineno: number;
    private table: SymbolTable;
    private symbols;
    private _funcParams;
    private _funcLocals;
    private _funcGlobals;
    private _funcFrees;
    private _classMethods;
    /**
     * @constructor
     * @param {Object} table
     * @param {string} name
     * @param {string} type
     * @param {number} lineno
     */
    constructor(table: SymbolTable, name: string, type: string, ast, lineno: number) {
        this.symFlags = {};
        this.name = name;
        this.varnames = [];
        /**
         * @type Array.&lt;SymbolTableScope&gt;
         */
        this.children = [];
        this.blockType = type;
    
        this.isNested = false;
        this.hasFree = false;
        this.childHasFree = false;  // true if child block has free vars including free refs to globals
        this.generator = false;
        this.varargs = false;
        this.varkeywords = false;
        this.returnsValue = false;
    
        this.lineno = lineno;
    
        this.table = table;
    
        if (table.cur &amp;&amp; (table.cur.is_nested() || table.cur.blockType === FunctionBlock))
            this.isNested = true;
    
        ast.scopeId = astScopeCounter++;
        table.stss[ast.scopeId] = this;
    
        // cache of Symbols for returning to other parts of code
        this.symbols = {};
    }

    get_type() {
        return this.blockType;
        
    }

    get_name() {
        return this.name;
        
    }

    get_lineno() {
        return this.lineno;
        
    }

    is_nested() {
        return this.isNested;
        
    }

    has_children() {
        return this.children.length &gt; 0;
    }

    get_identifiers() {
        return this._identsMatching(function(x) { return true; });
    }

    lookup(name: string) {
        var sym;
        if (!this.symbols.hasOwnProperty(name)) {
            var flags = this.symFlags[name];
            var namespaces = this.__check_children(name);
            sym = this.symbols[name] = new Symbol(name, flags, namespaces);
        }
        else {
            sym = this.symbols[name];
        }
        return sym;
    }
    
    __check_children(name) {
        var ret = [];
        for (var i = 0; i &lt; this.children.length; ++i) {
            var child = this.children[i];
            if (child.name === name)
                ret.push(child);
        }
        return ret;
    }
    
    _identsMatching(f) {
        var ret = [];
        for (var k in this.symFlags) {
            if (this.symFlags.hasOwnProperty(k)) {
                if (f(this.symFlags[k]))
                    ret.push(k);
            }
        }
        ret.sort();
        return ret;
    }
    
    get_parameters() {
        asserts.assert(this.get_type() == &#x27;function&#x27;, &quot;get_parameters only valid for function scopes&quot;);
        if (!this._funcParams)
            this._funcParams = this._identsMatching(function(x) { return x &amp; DEF_PARAM; });
        return this._funcParams;
    }
    
    get_locals() {
        asserts.assert(this.get_type() == &#x27;function&#x27;, &quot;get_locals only valid for function scopes&quot;);
        if (!this._funcLocals)
            this._funcLocals = this._identsMatching(function(x) { return x &amp; DEF_BOUND; });
        return this._funcLocals;
    }
    
    get_globals() {
        asserts.assert(this.get_type() == &#x27;function&#x27;, &quot;get_globals only valid for function scopes&quot;);
        if (!this._funcGlobals) {
            this._funcGlobals = this._identsMatching(function(x) {
                var masked = (x &gt;&gt; SCOPE_OFF) &amp; SCOPE_MASK;
                return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;
            });
        }
        return this._funcGlobals;
    }
    
    get_frees() {
        asserts.assert(this.get_type() == &#x27;function&#x27;, &quot;get_frees only valid for function scopes&quot;);
        if (!this._funcFrees) {
            this._funcFrees = this._identsMatching(function(x) {
                var masked = (x &gt;&gt; SCOPE_OFF) &amp; SCOPE_MASK;
                return masked == FREE;
            });
        }
        return this._funcFrees;
    }
    
    get_methods() {
        asserts.assert(this.get_type() == &#x27;class&#x27;, &quot;get_methods only valid for class scopes&quot;);
        if (!this._classMethods) {
            // todo; uniq?
            var all = [];
            for (var i = 0; i &lt; this.children.length; ++i)
                all.push(this.children[i].name);
            all.sort();
            this._classMethods = all;
        }
        return this._classMethods;
    }
    
    getScope(name) {
        var v = this.symFlags[name];
        if (v === undefined) return 0;
        return (v &gt;&gt; SCOPE_OFF) &amp; SCOPE_MASK;
    }
}

export class SymbolTable {
    private fileName: string;
    public cur: SymbolTableScope = null;
    public top: SymbolTableScope = null;
    private stack: SymbolTableScope[] = [];
    /**
     * points at top level module symFlags
     */
    private global = null;
    /**
     * The current class or null.
     */
    private curClass: string = null;
    /**
     * Temporary variable used to generate names of definitions.
     */
    private tmpname: number = 0;
    /**
     * mapping from ast nodes to their scope if they have one. we add an
     * id to the ast node when a scope is created for it, and store it in
     * here for the compiler to lookup later.
     */
    public stss = {};
    constructor(fileName: string) {
        this.fileName = fileName;
    }

    /**
     * Lookup the SymbolTableScope for a scopeId of the AST.
     */
    getStsForAst(ast) {
        asserts.assert(ast.scopeId !== undefined, &quot;ast wasn&#x27;t added to st?&quot;);
        var v = this.stss[ast.scopeId];
        asserts.assert(v !== undefined, &quot;unknown sym tab entry&quot;);
        return v;
    }

    SEQStmt(nodes) {
        var len = nodes.length;
        for (var i = 0; i &lt; len; ++i) {
            var val = nodes[i];
            if (val) this.visitStmt(val);
        }
    }

    SEQExpr(nodes) {
        var len = nodes.length;
        for (var i = 0; i &lt; len; ++i) {
            var val = nodes[i];
            if (val) this.visitExpr(val);
        }
    }

    enterBlock(name: string, blockType: string, ast, lineno: number) {
        //  name = fixReservedNames(name);
        var prev: SymbolTableScope = null;
        if (this.cur) {
            prev = this.cur;
            this.stack.push(this.cur);
        }
        this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);
        if (name === &#x27;top&#x27;) {
            this.global = this.cur.symFlags;
        }
        if (prev) {
            prev.children.push(this.cur);
        }
    }
    
    exitBlock() {
        this.cur = null;
        if (this.stack.length &gt; 0)
            this.cur = this.stack.pop();
    }

    visitParams(args, toplevel) {
        for (var i = 0; i &lt; args.length; ++i) {
            var arg = args[i];
            if (arg.constructor === astnodes.Name) {
                asserts.assert(arg.ctx === astnodes.Param || (arg.ctx === astnodes.Store &amp;&amp; !toplevel));
                this.addDef(arg.id, DEF_PARAM, arg.lineno);
            }
            else {
                // Tuple isn&#x27;t supported
                throw syntaxError(&quot;invalid expression in parameter list&quot;, this.fileName);
            }
        }
    }
    
    /**
     * This method is called for a Function Definition or a Lambda expression.
     */
    visitArguments(a, lineno: number) {
        if (a.args) this.visitParams(a.args, true);
        if (a.vararg) {
            this.addDef(a.vararg, DEF_PARAM, lineno);
            this.cur.varargs = true;
        }
        if (a.kwarg) {
            this.addDef(a.kwarg, DEF_PARAM, lineno);
            this.cur.varkeywords = true;
        }
    }

    /**
     * @param {number} lineno
     */
    newTmpname(lineno: number) {
        this.addDef(&quot;_[&quot; + (++this.tmpname) + &quot;]&quot;, DEF_LOCAL, lineno);
    }

    /**
     * @param {string} name
     * @param {number} flag
     * @param {number} lineno
     */
    addDef(name: string, flag: number, lineno: number) {
        var mangled = mangleName(this.curClass, name);
        //  mangled = fixReservedNames(mangled);
        var val = this.cur.symFlags[mangled];
        if (val !== undefined) {
            if ((flag &amp; DEF_PARAM) &amp;&amp; (val &amp; DEF_PARAM)) {
                throw syntaxError(&quot;duplicate argument &#x27;&quot; + name + &quot;&#x27; in function definition&quot;, this.fileName, lineno);
            }
            val |= flag;
        }
        else {
            val = flag;
        }
        this.cur.symFlags[mangled] = val;
        if (flag &amp; DEF_PARAM) {
            this.cur.varnames.push(mangled);
        }
        else if (flag &amp; DEF_GLOBAL) {
            val = flag;
            var fromGlobal = this.global[mangled];
            if (fromGlobal !== undefined) val |= fromGlobal;
            this.global[mangled] = val;
        }
    }
    
    visitSlice(s) {
        switch (s.constructor) {
            case astnodes.Slice:
                if (s.lower) this.visitExpr(s.lower);
                if (s.upper) this.visitExpr(s.upper);
                if (s.step) this.visitExpr(s.step);
                break;
            case astnodes.ExtSlice:
                for (var i = 0; i &lt; s.dims.length; ++i)
                    this.visitSlice(s.dims[i]);
                break;
            case astnodes.Index:
                this.visitExpr(s.value);
                break;
            case astnodes.Ellipsis:
                break;
        }
    }

    /**
     * @param {Object} s
     */
    visitStmt(s) {
        asserts.assert(s !== undefined, &quot;visitStmt called with undefined&quot;);
        switch (s.constructor) {
            case astnodes.FunctionDef:
                this.addDef(s.name, DEF_LOCAL, s.lineno);
                if (s.args.defaults) this.SEQExpr(s.args.defaults);
                if (s.decorator_list) this.SEQExpr(s.decorator_list);
                this.enterBlock(s.name, FunctionBlock, s, s.lineno);
                this.visitArguments(s.args, s.lineno);
                this.SEQStmt(s.body);
                this.exitBlock();
                break;
            case astnodes.ClassDef:
                this.addDef(s.name, DEF_LOCAL, s.lineno);
                this.SEQExpr(s.bases);
                if (s.decorator_list) this.SEQExpr(s.decorator_list);
                this.enterBlock(s.name, ClassBlock, s, s.lineno);
                var tmp = this.curClass;
                this.curClass = s.name;
                this.SEQStmt(s.body);
                this.curClass = tmp;
                this.exitBlock();
                break;
            case astnodes.Return_:
                if (s.value) {
                    this.visitExpr(s.value);
                    this.cur.returnsValue = true;
                    if (this.cur.generator) {
                        throw syntaxError(&quot;&#x27;return&#x27; with argument inside generator&quot;, this.fileName);
                    }
                }
                break;
            case astnodes.Delete_:
                this.SEQExpr(s.targets);
                break;
            case astnodes.Assign:
                this.SEQExpr(s.targets);
                this.visitExpr(s.value);
                break;
            case astnodes.AugAssign:
                this.visitExpr(s.target);
                this.visitExpr(s.value);
                break;
            case astnodes.Print:
                if (s.dest) this.visitExpr(s.dest);
                this.SEQExpr(s.values);
                break;
            case astnodes.For_:
                this.visitExpr(s.target);
                this.visitExpr(s.iter);
                this.SEQStmt(s.body);
                if (s.orelse) this.SEQStmt(s.orelse);
                break;
            case astnodes.While_:
                this.visitExpr(s.test);
                this.SEQStmt(s.body);
                if (s.orelse) this.SEQStmt(s.orelse);
                break;
            case astnodes.If_:
                this.visitExpr(s.test);
                this.SEQStmt(s.body);
                if (s.orelse)
                    this.SEQStmt(s.orelse);
                break;
            case astnodes.Raise:
                if (s.type) {
                    this.visitExpr(s.type);
                    if (s.inst) {
                        this.visitExpr(s.inst);
                        if (s.tback)
                            this.visitExpr(s.tback);
                    }
                }
                break;
            case astnodes.TryExcept:
                this.SEQStmt(s.body);
                this.SEQStmt(s.orelse);
                this.visitExcepthandlers(s.handlers);
                break;
            case astnodes.TryFinally:
                this.SEQStmt(s.body);
                this.SEQStmt(s.finalbody);
                break;
            case astnodes.Assert:
                this.visitExpr(s.test);
                if (s.msg) this.visitExpr(s.msg);
                break;
            case astnodes.Import_:
            case astnodes.ImportFrom:
                this.visitAlias(s.names, s.lineno);
                break;
            case astnodes.Exec:
                this.visitExpr(s.body);
                if (s.globals) {
                    this.visitExpr(s.globals);
                    if (s.locals)
                        this.visitExpr(s.locals);
                }
                break;
            case astnodes.Global:
                var nameslen = s.names.length;
                for (var i = 0; i &lt; nameslen; ++i) {
                    var name = mangleName(this.curClass, s.names[i]);
                    //              name = fixReservedNames(name);
                    var cur = this.cur.symFlags[name];
                    if (cur &amp; (DEF_LOCAL | USE)) {
                        if (cur &amp; DEF_LOCAL) {
                            throw syntaxError(&quot;name &#x27;&quot; + name + &quot;&#x27; is assigned to before global declaration&quot;, this.fileName, s.lineno);
                        }
                        else {
                            throw syntaxError(&quot;name &#x27;&quot; + name + &quot;&#x27; is used prior to global declaration&quot;, this.fileName, s.lineno);
                        }
                    }
                    this.addDef(name, DEF_GLOBAL, s.lineno);
                }
                break;
            case astnodes.Expr:
                this.visitExpr(s.value);
                break;
            case astnodes.Pass:
            case astnodes.Break_:
            case astnodes.Continue_:
                // nothing
                break;
            case astnodes.With_:
                this.newTmpname(s.lineno);
                this.visitExpr(s.context_expr);
                if (s.optional_vars) {
                    this.newTmpname(s.lineno);
                    this.visitExpr(s.optional_vars);
                }
                this.SEQStmt(s.body);
                break;
    
            default:
                asserts.fail(&quot;Unhandled type &quot; + s.constructor.name + &quot; in visitStmt&quot;);
        }
    }

    visitExpr(e) {
        asserts.assert(e !== undefined, &quot;visitExpr called with undefined&quot;);
        //print(&quot;  e: &quot;, e.constructor.name);
        switch (e.constructor) {
            case astnodes.BoolOp:
                this.SEQExpr(e.values);
                break;
            case astnodes.BinOp:
                this.visitExpr(e.left);
                this.visitExpr(e.right);
                break;
            case astnodes.UnaryOp:
                this.visitExpr(e.operand);
                break;
            case astnodes.Lambda:
                this.addDef(&quot;lambda&quot;, DEF_LOCAL, e.lineno);
                if (e.args.defaults)
                    this.SEQExpr(e.args.defaults);
                this.enterBlock(&quot;lambda&quot;, FunctionBlock, e, e.lineno);
                this.visitArguments(e.args, e.lineno);
                this.visitExpr(e.body);
                this.exitBlock();
                break;
            case astnodes.IfExp:
                this.visitExpr(e.test);
                this.visitExpr(e.body);
                this.visitExpr(e.orelse);
                break;
            case astnodes.Dict:
                this.SEQExpr(e.keys);
                this.SEQExpr(e.values);
                break;
            case astnodes.ListComp:
                this.newTmpname(e.lineno);
                this.visitExpr(e.elt);
                this.visitComprehension(e.generators, 0);
                break;
            case astnodes.GeneratorExp:
                this.visitGenexp(e);
                break;
            case astnodes.Yield:
                if (e.value) this.visitExpr(e.value);
                this.cur.generator = true;
                if (this.cur.returnsValue) {
                    throw syntaxError(&quot;&#x27;return&#x27; with argument inside generator&quot;, this.fileName);
                }
                break;
            case astnodes.Compare:
                this.visitExpr(e.left);
                this.SEQExpr(e.comparators);
                break;
            case astnodes.Call:
                this.visitExpr(e.func);
                this.SEQExpr(e.args);
                for (var i = 0; i &lt; e.keywords.length; ++i)
                    this.visitExpr(e.keywords[i].value);
                //print(JSON.stringify(e.starargs, null, 2));
                //print(JSON.stringify(e.kwargs, null,2));
                if (e.starargs) this.visitExpr(e.starargs);
                if (e.kwargs) this.visitExpr(e.kwargs);
                break;
            case astnodes.Num:
            case astnodes.Str:
                break;
            case astnodes.Attribute:
                this.visitExpr(e.value);
                break;
            case astnodes.Subscript:
                this.visitExpr(e.value);
                this.visitSlice(e.slice);
                break;
            case astnodes.Name:
                this.addDef(e.id, e.ctx === astnodes.Load ? USE : DEF_LOCAL, e.lineno);
                break;
            case astnodes.List:
            case astnodes.Tuple:
                this.SEQExpr(e.elts);
                break;
            default:
                asserts.fail(&quot;Unhandled type &quot; + e.constructor.name + &quot; in visitExpr&quot;);
        }
    }

    visitComprehension(lcs, startAt) {
        var len = lcs.length;
        for (var i = startAt; i &lt; len; ++i) {
            var lc = lcs[i];
            this.visitExpr(lc.target);
            this.visitExpr(lc.iter);
            this.SEQExpr(lc.ifs);
        }
    }

    /**
     * This is probably not correct for names. What are they?
     * @param {Array.&lt;Object&gt;} names
     * @param {number} lineno
     */
    visitAlias(names, lineno) {
        /* Compute store_name, the name actually bound by the import
            operation.  It is diferent than a-&gt;name when a-&gt;name is a
            dotted package name (e.g. spam.eggs)
        */
        for (var i = 0; i &lt; names.length; ++i) {
            var a = names[i];
            // DGH: The RHS used to be Python strings.
            var name = a.asname === null ? a.name : a.asname;
            var storename = name;
            var dot = name.indexOf(&#x27;.&#x27;);
            if (dot !== -1)
                storename = name.substr(0, dot);
            if (name !== &quot;*&quot;) {
                this.addDef(storename, DEF_IMPORT, lineno);
            }
            else {
                if (this.cur.blockType !== ModuleBlock) {
                    throw syntaxError(&quot;import * only allowed at module level&quot;, this.fileName);
                }
            }
        }
    }

    /**
     * @param {Object} e
     */
    visitGenexp(e) {
        var outermost = e.generators[0];
        // outermost is evaled in current scope
        this.visitExpr(outermost.iter);
        this.enterBlock(&quot;genexpr&quot;, FunctionBlock, e, e.lineno);
        this.cur.generator = true;
        this.addDef(&quot;.0&quot;, DEF_PARAM, e.lineno);
        this.visitExpr(outermost.target);
        this.SEQExpr(outermost.ifs);
        this.visitComprehension(e.generators, 1);
        this.visitExpr(e.elt);
        this.exitBlock();
    }

    visitExcepthandlers(handlers) {
        for (var i = 0, eh; eh = handlers[i]; ++i) {
            if (eh.type) this.visitExpr(eh.type);
            if (eh.name) this.visitExpr(eh.name);
            this.SEQStmt(eh.body);
        }
    }

    /**
     * @param {Object} ste The Symbol Table Scope.
     */
    analyzeBlock(ste: SymbolTableScope, bound, free, global) {
        var local = {};
        var scope = {};
        var newglobal = {};
        var newbound = {};
        var newfree = {};
    
        if (ste.blockType == ClassBlock) {
            _dictUpdate(newglobal, global);
            if (bound)
                _dictUpdate(newbound, bound);
        }
    
        for (var name in ste.symFlags) {
            var flags = ste.symFlags[name];
            this.analyzeName(ste, scope, name, flags, bound, local, free, global);
        }
    
        if (ste.blockType !== ClassBlock) {
            if (ste.blockType === FunctionBlock)
                _dictUpdate(newbound, local);
            if (bound)
                _dictUpdate(newbound, bound);
            _dictUpdate(newglobal, global);
        }
    
        var allfree = {};
        var childlen = ste.children.length;
        for (var i = 0; i &lt; childlen; ++i) {
            var c = ste.children[i];
            this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
            if (c.hasFree || c.childHasFree)
                ste.childHasFree = true;
        }
    
        _dictUpdate(newfree, allfree);

        if (ste.blockType === FunctionBlock) this.analyzeCells(scope, newfree);

        this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);
    
        _dictUpdate(free, newfree);
    }
    
    analyzeChildBlock(entry, bound, free, global, childFree) {
        var tempBound = {};
        _dictUpdate(tempBound, bound);
        var tempFree = {};
        _dictUpdate(tempFree, free);
        var tempGlobal = {};
        _dictUpdate(tempGlobal, global);
    
        this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
        _dictUpdate(childFree, tempFree);
    }

    analyzeCells(scope, free) {
        for (var name in scope) {
            var flags = scope[name];
            if (flags !== LOCAL) continue;
            if (free[name] === undefined) continue;
            scope[name] = CELL;
            delete free[name];
        }
    }

    /**
     * store scope info back into the st symbols dict. symbols is modified,
     * others are not.
     */
    updateSymbols(symbols, scope, bound, free, classflag) {

        for (var name in symbols) {
            var flags = symbols[name];
            var w = scope[name];
            flags |= w &lt;&lt; SCOPE_OFF;
            symbols[name] = flags;
        }
    
        var freeValue = FREE &lt;&lt; SCOPE_OFF;
        var pos = 0;
        for (var name in free) {
            var o = symbols[name];
            if (o !== undefined) {
                // it could be a free variable in a method of the class that has
                // the same name as a local or global in the class scope
                if (classflag &amp;&amp; (o &amp; (DEF_BOUND | DEF_GLOBAL))) {
                    var i = o | DEF_FREE_CLASS;
                    symbols[name] = i;
                }
                // else it&#x27;s not free, probably a cell
                continue;
            }
            if (bound[name] === undefined) continue;
            symbols[name] = freeValue;
        }
    }

    /**
     * @param {Object} ste The Symbol Table Scope.
     * @param {string} name
     */
    analyzeName(ste: SymbolTableScope, dict, name, flags, bound, local, free, global) {
        if (flags &amp; DEF_GLOBAL) {
            if (flags &amp; DEF_PARAM) throw syntaxError(&quot;name &#x27;&quot; + name + &quot;&#x27; is local and global&quot;, this.fileName, ste.lineno);
            dict[name] = GLOBAL_EXPLICIT;
            global[name] = null;
            if (bound &amp;&amp; bound[name] !== undefined) delete bound[name];
            return;
        }
        if (flags &amp; DEF_BOUND) {
            dict[name] = LOCAL;
            local[name] = null;
            delete global[name];
            return;
        }
    
        if (bound &amp;&amp; bound[name] !== undefined) {
            dict[name] = FREE;
            ste.hasFree = true;
            free[name] = null;
        }
        else if (global &amp;&amp; global[name] !== undefined) {
            dict[name] = GLOBAL_IMPLICIT;
        }
        else {
            if (ste.isNested)
                ste.hasFree = true;
            dict[name] = GLOBAL_IMPLICIT;
        }
    }

    analyze() {
        var free = {};
        var global = {};
        this.analyzeBlock(this.top, null, free, global);
    }
    
}

function _dictUpdate(a, b) {
    for (var kb in b) {
        a[kb] = b[kb];
    }
}

/**
 * Computes the symbol table for the AST module.
 * @param {Object} module
 * @param {string} fileName
 */
export function symbolTable(module: astnodes.Module, fileName: string): SymbolTable {
    var ret = new SymbolTable(fileName);

    ret.enterBlock(&quot;top&quot;, ModuleBlock, module, 0);

    ret.top = ret.cur;

    for (var i = 0; i &lt; module.body.length; ++i) {
        ret.visitStmt(module.body[i]);
    }

    ret.exitBlock();

    ret.analyze();

    return ret;
}

export function dumpSymbolTable(st: SymbolTable) {

    var pyBoolStr = function(b: boolean) {
        return b ? &quot;True&quot; : &quot;False&quot;;
    };

    var pyList = function(l) {
        var ret = [];
        for (var i = 0; i &lt; l.length; ++i) {
            // TODO: Originally, this computed the Python repr().
            ret.push(l[i]);
        }
        return &#x27;[&#x27; + ret.join(&#x27;, &#x27;) + &#x27;]&#x27;;
    };

    var getIdents = function(obj: SymbolTableScope, indent: string) {
        if (indent === undefined) indent = &quot;&quot;;
        var ret = &quot;&quot;;
        ret += indent + &quot;Sym_type: &quot; + obj.get_type() + &quot;\n&quot;;
        ret += indent + &quot;Sym_name: &quot; + obj.get_name() + &quot;\n&quot;;
        ret += indent + &quot;Sym_lineno: &quot; + obj.get_lineno() + &quot;\n&quot;;
        ret += indent + &quot;Sym_nested: &quot; + pyBoolStr(obj.is_nested()) + &quot;\n&quot;;
        ret += indent + &quot;Sym_haschildren: &quot; + pyBoolStr(obj.has_children()) + &quot;\n&quot;;
        if (obj.get_type() === &quot;class&quot;) {
            ret += indent + &quot;Class_methods: &quot; + pyList(obj.get_methods()) + &quot;\n&quot;;
        }
        else if (obj.get_type() === &quot;function&quot;) {
            ret += indent + &quot;Func_params: &quot; + pyList(obj.get_parameters()) + &quot;\n&quot;;
            ret += indent + &quot;Func_locals: &quot; + pyList(obj.get_locals()) + &quot;\n&quot;;
            ret += indent + &quot;Func_globals: &quot; + pyList(obj.get_globals()) + &quot;\n&quot;;
            ret += indent + &quot;Func_frees: &quot; + pyList(obj.get_frees()) + &quot;\n&quot;;
        }
        ret += indent + &quot;-- Identifiers --\n&quot;;
        var objidents = obj.get_identifiers();
        var objidentslen = objidents.length;
        for (var i = 0; i &lt; objidentslen; ++i) {
            var info = obj.lookup(objidents[i]);
            ret += indent + &quot;name: &quot; + info.get_name() + &quot;\n&quot;;
            ret += indent + &quot;  is_referenced: &quot; + pyBoolStr(info.is_referenced()) + &quot;\n&quot;;
            ret += indent + &quot;  is_imported: &quot; + pyBoolStr(info.is_imported()) + &quot;\n&quot;;
            ret += indent + &quot;  is_parameter: &quot; + pyBoolStr(info.is_parameter()) + &quot;\n&quot;;
            ret += indent + &quot;  is_global: &quot; + pyBoolStr(info.is_global()) + &quot;\n&quot;;
            ret += indent + &quot;  is_declared_global: &quot; + pyBoolStr(info.is_declared_global()) + &quot;\n&quot;;
            ret += indent + &quot;  is_local: &quot; + pyBoolStr(info.is_local()) + &quot;\n&quot;;
            ret += indent + &quot;  is_free: &quot; + pyBoolStr(info.is_free()) + &quot;\n&quot;;
            ret += indent + &quot;  is_assigned: &quot; + pyBoolStr(info.is_assigned()) + &quot;\n&quot;;
            ret += indent + &quot;  is_namespace: &quot; + pyBoolStr(info.is_namespace()) + &quot;\n&quot;;
            var nss = info.get_namespaces();
            var nsslen = nss.length;
            ret += indent + &quot;  namespaces: [\n&quot;;
            var sub = [];
            for (var j = 0; j &lt; nsslen; ++j) {
                var ns = nss[j];
                sub.push(getIdents(ns, indent + &quot;    &quot;));
            }
            ret += sub.join(&#x27;\n&#x27;);
            ret += indent + &#x27;  ]\n&#x27;;
        }
        return ret;
    };
    return getIdents(st.top, &#x27;&#x27;);
};

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
