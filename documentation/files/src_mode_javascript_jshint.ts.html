<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/mode/javascript/jshint.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.17</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/parserlib.css.Combinator.html">parserlib.css.Combinator</a></li>
                                <li><a href="../classes/parserlib.css.MediaFeature.html">parserlib.css.MediaFeature</a></li>
                                <li><a href="../classes/parserlib.css.MediaQuery.html">parserlib.css.MediaQuery</a></li>
                                <li><a href="../classes/parserlib.css.Parser.html">parserlib.css.Parser</a></li>
                                <li><a href="../classes/parserlib.css.PropertyName.html">parserlib.css.PropertyName</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValue.html">parserlib.css.PropertyValue</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValueIterator.html">parserlib.css.PropertyValueIterator</a></li>
                                <li><a href="../classes/parserlib.css.PropertyValuePart.html">parserlib.css.PropertyValuePart</a></li>
                                <li><a href="../classes/parserlib.css.Selector.html">parserlib.css.Selector</a></li>
                                <li><a href="../classes/parserlib.css.SelectorPart.html">parserlib.css.SelectorPart</a></li>
                                <li><a href="../classes/parserlib.css.SelectorSubPart.html">parserlib.css.SelectorSubPart</a></li>
                                <li><a href="../classes/parserlib.css.Specificity.html">parserlib.css.Specificity</a></li>
                                <li><a href="../classes/parserlib.css.TokenStream.html">parserlib.css.TokenStream</a></li>
                                <li><a href="../classes/parserlib.css.TokenStreamBase.html">parserlib.css.TokenStreamBase</a></li>
                                <li><a href="../classes/parserlib.util.Anchor.html">parserlib.util.Anchor</a></li>
                                <li><a href="../classes/parserlib.util.BackgroundTokenizer.html">parserlib.util.BackgroundTokenizer</a></li>
                                <li><a href="../classes/parserlib.util.CSSLint.html">parserlib.util.CSSLint</a></li>
                                <li><a href="../classes/parserlib.util.Editor.html">parserlib.util.Editor</a></li>
                                <li><a href="../classes/parserlib.util.EditorDocument.html">parserlib.util.EditorDocument</a></li>
                                <li><a href="../classes/parserlib.util.EditSession.html">parserlib.util.EditSession</a></li>
                                <li><a href="../classes/parserlib.util.EventTarget.html">parserlib.util.EventTarget</a></li>
                                <li><a href="../classes/parserlib.util.Fold.html">parserlib.util.Fold</a></li>
                                <li><a href="../classes/parserlib.util.FoldLine.html">parserlib.util.FoldLine</a></li>
                                <li><a href="../classes/parserlib.util.GutterTooltip.html">parserlib.util.GutterTooltip</a></li>
                                <li><a href="../classes/parserlib.util.HScrollBar.html">parserlib.util.HScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.HtmlMode.html">parserlib.util.HtmlMode</a></li>
                                <li><a href="../classes/parserlib.util.Mode.html">parserlib.util.Mode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/parserlib.util.Position.html">parserlib.util.Position</a></li>
                                <li><a href="../classes/parserlib.util.Range.html">parserlib.util.Range</a></li>
                                <li><a href="../classes/parserlib.util.Reporter.html">parserlib.util.Reporter</a></li>
                                <li><a href="../classes/parserlib.util.ScrollBar.html">parserlib.util.ScrollBar</a></li>
                                <li><a href="../classes/parserlib.util.Search.html">parserlib.util.Search</a></li>
                                <li><a href="../classes/parserlib.util.Selection.html">parserlib.util.Selection</a></li>
                                <li><a href="../classes/parserlib.util.StringReader.html">parserlib.util.StringReader</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxError.html">parserlib.util.SyntaxError</a></li>
                                <li><a href="../classes/parserlib.util.SyntaxUnit.html">parserlib.util.SyntaxUnit</a></li>
                                <li><a href="../classes/parserlib.util.TokenIterator.html">parserlib.util.TokenIterator</a></li>
                                <li><a href="../classes/parserlib.util.Tokenizer.html">parserlib.util.Tokenizer</a></li>
                                <li><a href="../classes/parserlib.util.Tooltip.html">parserlib.util.Tooltip</a></li>
                                <li><a href="../classes/parserlib.util.TypeScriptWorker.html">parserlib.util.TypeScriptWorker</a></li>
                                <li><a href="../classes/parserlib.util.UndoManager.html">parserlib.util.UndoManager</a></li>
                                <li><a href="../classes/parserlib.util.ValidationError.html">parserlib.util.ValidationError</a></li>
                                <li><a href="../classes/parserlib.util.VirtualRenderer.html">parserlib.util.VirtualRenderer</a></li>
                                <li><a href="../classes/parserlib.util.VScrollBar.html">parserlib.util.VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/mode/javascript/jshint.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
 * JSHint, by JSHint Community.
 *
 * This file (and this file only) is licensed under the same slightly modified
 * MIT license that JSLint is. It stops evil-doers everywhere:
 *
 *   Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *   Permission is hereby granted, free of charge, to any person obtaining
 *   a copy of this software and associated documentation files (the &quot;Software&quot;),
 *   to deal in the Software without restriction, including without limitation
 *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *   and/or sell copies of the Software, and to permit persons to whom
 *   the Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included
 *   in all copies or substantial portions of the Software.
 *
 *   The Software shall be used for Good, not Evil.
 *
 *   THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 */

/*jshint quotmark:double */
/*global console:true */
/*exported console */
import JSHintOptions from &#x27;./JSHintOptions&#x27;;
import EventEmitter from &quot;./EventEmitter&quot;;
import {browser, browserify, couch, devel, dojo, ecmaIdentifiers, jasmine, jquery, mocha, mootools, node, nonstandard, phantom, prototypejs, qunit, reservedVars, rhino, shelljs, typed, worker, wsh, yui} from &quot;./vars&quot;;
import {errors, info, warnings} from &quot;./messages&quot;;
import Lexer from &quot;./lex&quot;;
import {identifierRegExp, javascriptURL} from &quot;./reg&quot;;
import {state} from &quot;./state&quot;;
import {register} from &quot;./style&quot;;
import {bool, inverted, noenforceall, removed, renamed, validNames} from &quot;./options&quot;;
import {scopeManager} from &quot;./scope-manager&quot;;
import contains from &quot;../../fp/contains&quot;;
import clone from &quot;../../fp/clone&quot;;
import each from &quot;../../fp/each&quot;;
import extend from &quot;../../fp/extend&quot;;
import has from &quot;../../fp/has&quot;;
import isEmpty from &quot;../../fp/isEmpty&quot;;
import isNumber from &quot;../../fp/isNumber&quot;;
import reject from &quot;../../fp/reject&quot;;
import zip from &quot;../../fp/zip&quot;;

// We need this module here because environments such as IE and Rhino
// don&#x27;t necessarilly expose the &#x27;console&#x27; API and browserify uses
// it to log things. It&#x27;s a sad state of affair, really.
// var console = require(&quot;console-browserify&quot;);

// We build the application inside a function so that we produce only a singleton
// variable. That function will be invoked immediately, and its return value is
// the JSHINT function itself.

// Throw away the type information because JSHINT is both a function with attributes!
export var JSHINT: any = (function() {
    &quot;use strict&quot;;

    var api, // Extension API

        // These are operators that should not be used with the ! operator.
        bang = {
            &quot;&lt;&quot;: true,
            &quot;&lt;=&quot;: true,
            &quot;==&quot;: true,
            &quot;===&quot;: true,
            &quot;!==&quot;: true,
            &quot;!=&quot;: true,
            &quot;&gt;&quot;: true,
            &quot;&gt;=&quot;: true,
            &quot;+&quot;: true,
            &quot;-&quot;: true,
            &quot;*&quot;: true,
            &quot;/&quot;: true,
            &quot;%&quot;: true
        },

        declared, // Globals that were declared using /*global ... */ syntax.

        functionicity = [
            &quot;closure&quot;, &quot;exception&quot;, &quot;global&quot;, &quot;label&quot;,
            &quot;outer&quot;, &quot;unused&quot;, &quot;var&quot;
        ],

        functions, // All of the functions

        inblock,
        indent,
        lookahead,
        lex,
        member,
        membersOnly,
        predefined,    // Global variables defined by option

        stack,
        urls,

        extraModules = [],
        emitter = new EventEmitter();

    function checkOption(name, t) {
        name = name.trim();

        if (/^[+-]W\d{3}$/g.test(name)) {
            return true;
        }

        if (validNames.indexOf(name) === -1) {
            if (t.type !== &quot;jslint&quot; &amp;&amp; !has(removed, name)) {
                error(&quot;E001&quot;, t, name);
                return false;
            }
        }

        return true;
    }

    function isString(obj) {
        return Object.prototype.toString.call(obj) === &quot;[object String]&quot;;
    }

    function isIdentifier(tkn, value) {
        if (!tkn)
            return false;

        if (!tkn.identifier || tkn.value !== value)
            return false;

        return true;
    }

    function isReserved(token) {
        if (!token.reserved) {
            return false;
        }
        var meta = token.meta;

        if (meta &amp;&amp; meta.isFutureReservedWord &amp;&amp; state.inES5()) {
            // ES3 FutureReservedWord in an ES5 environment.
            if (!meta.es5) {
                return false;
            }

            // Some ES5 FutureReservedWord identifiers are active only
            // within a strict mode environment.
            if (meta.strictOnly) {
                if (!state.option.strict &amp;&amp; !state.isStrict()) {
                    return false;
                }
            }

            if (token.isProperty) {
                return false;
            }
        }

        return true;
    }

    function supplant(str, data) {
        return str.replace(/\{([^{}]*)\}/g, function(a, b) {
            var r = data[b];
            return typeof r === &quot;string&quot; || typeof r === &quot;number&quot; ? r : a;
        });
    }

    function combine(dest, src) {
        Object.keys(src).forEach(function(name) {
            if (has(JSHINT.blacklist, name)) return;
            dest[name] = src[name];
        });
    }

    function processenforceall() {
        if (state.option.enforceall) {
            for (var enforceopt in bool.enforcing) {
                if (state.option[enforceopt] === void 0 &amp;&amp;
                    !noenforceall[enforceopt]) {
                    state.option[enforceopt] = true;
                }
            }
            for (var relaxopt in bool.relaxing) {
                if (state.option[relaxopt] === void 0) {
                    state.option[relaxopt] = false;
                }
            }
        }
    }

    function assume() {
        processenforceall();

        /**
         * TODO: Remove in JSHint 3
         */
        if (!state.option.esversion &amp;&amp; !state.option.moz) {
            if (state.option.es3) {
                state.option.esversion = 3;
            } else if (state.option.esnext) {
                state.option.esversion = 6;
            } else {
                state.option.esversion = 5;
            }
        }

        if (state.inES5()) {
            combine(predefined, ecmaIdentifiers[5]);
        }

        if (state.inES6()) {
            combine(predefined, ecmaIdentifiers[6]);
        }

        /**
         * Use &#x60;in&#x60; to check for the presence of any explicitly-specified value for
         * &#x60;globalstrict&#x60; because both &#x60;true&#x60; and &#x60;false&#x60; should trigger an error.
         */
        if (state.option.strict === &quot;global&quot; &amp;&amp; &quot;globalstrict&quot; in state.option) {
            quit(&quot;E059&quot;, state.tokens.next, &quot;strict&quot;, &quot;globalstrict&quot;);
        }

        if (state.option.module) {
            if (state.option.strict === true) {
                state.option.strict = &quot;global&quot;;
            }
            /**
             * TODO: Extend this restriction to *all* ES6-specific options.
             */
            if (!state.inES6()) {
                warning(&quot;W134&quot;, state.tokens.next, &quot;module&quot;, 6);
            }
        }

        if (state.option.couch) {
            combine(predefined, couch);
        }

        if (state.option.qunit) {
            combine(predefined, qunit);
        }

        if (state.option.rhino) {
            combine(predefined, rhino);
        }

        if (state.option.shelljs) {
            combine(predefined, shelljs);
            combine(predefined, node);
        }
        if (state.option.typed) {
            combine(predefined, typed);
        }

        if (state.option.phantom) {
            combine(predefined, phantom);
            if (state.option.strict === true) {
                state.option.strict = &quot;global&quot;;
            }
        }

        if (state.option.prototypejs) {
            combine(predefined, prototypejs);
        }

        if (state.option.node) {
            combine(predefined, node);
            combine(predefined, typed);
            if (state.option.strict === true) {
                state.option.strict = &quot;global&quot;;
            }
        }

        if (state.option.devel) {
            combine(predefined, devel);
        }

        if (state.option.dojo) {
            combine(predefined, dojo);
        }

        if (state.option.browser) {
            combine(predefined, browser);
            combine(predefined, typed);
        }

        if (state.option.browserify) {
            combine(predefined, browser);
            combine(predefined, typed);
            combine(predefined, browserify);
            if (state.option.strict === true) {
                state.option.strict = &quot;global&quot;;
            }
        }

        if (state.option.nonstandard) {
            combine(predefined, nonstandard);
        }

        if (state.option.jasmine) {
            combine(predefined, jasmine);
        }

        if (state.option.jquery) {
            combine(predefined, jquery);
        }

        if (state.option.mootools) {
            combine(predefined, mootools);
        }

        if (state.option.worker) {
            combine(predefined, worker);
        }

        if (state.option.wsh) {
            combine(predefined, wsh);
        }

        if (state.option.globalstrict &amp;&amp; state.option.strict !== false) {
            state.option.strict = &quot;global&quot;;
        }

        if (state.option.yui) {
            combine(predefined, yui);
        }

        if (state.option.mocha) {
            combine(predefined, mocha);
        }
    }

    // Produce an error warning.
    function quit(code: string, token, a?, b?) {
        var percentage = Math.floor((token.line / state.lines.length) * 100);
        var message = errors[code].desc;

        var exception = {
            name: &quot;JSHintError&quot;,
            line: token.line,
            character: token.from,
            message: message + &quot; (&quot; + percentage + &quot;% scanned).&quot;,
            raw: message,
            code: code,
            a: a,
            b: b,
            reason: void 0
        };

        exception.reason = supplant(message, exception) + &quot; (&quot; + percentage +
            &quot;% scanned).&quot;;

        throw exception;
    }

    function removeIgnoredMessages() {
        var ignored: { [line: string]: boolean } = state.ignoredLines;

        if (isEmpty(ignored)) {
            return;
        }
        var errors: {}[] = JSHINT.errors;
        JSHINT.errors = reject(errors, function(err: { line: string }) { return ignored[err.line] });
    }

    function warning(code: string, t?, a?, b?, c?, d?) {
        var ch, l, w, msg;

        if (/^W\d{3}$/.test(code)) {
            if (state.ignored[code])
                return;

            msg = warnings[code];
        } else if (/E\d{3}/.test(code)) {
            msg = errors[code];
        } else if (/I\d{3}/.test(code)) {
            msg = info[code];
        }

        t = t || state.tokens.next || {};
        if (t.id === &quot;(end)&quot;) {  // &#x60;~
            t = state.tokens.curr;
        }

        l = t.line;
        ch = t.from;

        w = {
            id: &quot;(error)&quot;,
            raw: msg.desc,
            code: msg.code,
            evidence: state.lines[l - 1] || &quot;&quot;,
            line: l,
            character: ch,
            scope: JSHINT.scope,
            a: a,
            b: b,
            c: c,
            d: d
        };

        w.reason = supplant(msg.desc, w);
        JSHINT.errors.push(w);

        removeIgnoredMessages();

        if (JSHINT.errors.length &gt;= state.option.maxerr)
            quit(&quot;E043&quot;, t);

        return w;
    }

    function warningAt(m, l, ch, a?, b?, c?, d?) {
        return warning(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    function error(m: string, t?, a?, b?, c?, d?) {
        warning(m, t, a, b, c, d);
    }

    function errorAt(m, l, ch?, a?, b?, c?, d?) {
        return error(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    // Tracking of &quot;internal&quot; scripts, like eval containing a static string
    function addInternalSrc(elem, src) {
        var i;
        i = {
            id: &quot;(internal)&quot;,
            elem: elem,
            value: src
        };
        JSHINT.internals.push(i);
        return i;
    }

    function doOption() {
        var nt = state.tokens.next;
        var body = nt.body.split(&quot;,&quot;).map(function(s) { return s.trim(); });

        var predef = {};
        if (nt.type === &quot;globals&quot;) {
            body.forEach(function(g, idx) {
                g = g.split(&quot;:&quot;);
                var key: string = (g[0] || &quot;&quot;).trim();
                var val = (g[1] || &quot;&quot;).trim();

                if (key === &quot;-&quot; || !key.length) {
                    // Ignore trailing comma
                    if (idx &gt; 0 &amp;&amp; idx === body.length - 1) {
                        return;
                    }
                    error(&quot;E002&quot;, nt);
                    return;
                }

                if (key.charAt(0) === &quot;-&quot;) {
                    key = key.slice(1);
                    val = false;

                    JSHINT.blacklist[key] = key;
                    delete predefined[key];
                } else {
                    predef[key] = (val === &quot;true&quot;);
                }
            });

            combine(predefined, predef);

            for (var key in predef) {
                if (has(predef, key)) {
                    declared[key] = nt;
                }
            }
        }

        if (nt.type === &quot;exported&quot;) {
            body.forEach(function(e, idx) {
                if (!e.length) {
                    // Ignore trailing comma
                    if (idx &gt; 0 &amp;&amp; idx === body.length - 1) {
                        return;
                    }
                    error(&quot;E002&quot;, nt);
                    return;
                }

                state.funct[&quot;(scope)&quot;].addExported(e);
            });
        }

        if (nt.type === &quot;members&quot;) {
            membersOnly = membersOnly || {};

            body.forEach(function(m) {
                var ch1 = m.charAt(0);
                var ch2 = m.charAt(m.length - 1);

                if (ch1 === ch2 &amp;&amp; (ch1 === &quot;\&quot;&quot; || ch1 === &quot;&#x27;&quot;)) {
                    m = m
                        .substr(1, m.length - 2)
                        .replace(&quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
                }

                membersOnly[m] = false;
            });
        }

        var numvals = [
            &quot;maxstatements&quot;,
            &quot;maxparams&quot;,
            &quot;maxdepth&quot;,
            &quot;maxcomplexity&quot;,
            &quot;maxerr&quot;,
            &quot;maxlen&quot;,
            &quot;indent&quot;
        ];

        if (nt.type === &quot;jshint&quot; || nt.type === &quot;jslint&quot;) {
            body.forEach(function(g) {
                g = g.split(&quot;:&quot;);
                var key = (g[0] || &quot;&quot;).trim();
                var val = (g[1] || &quot;&quot;).trim();

                if (!checkOption(key, nt)) {
                    return;
                }

                if (numvals.indexOf(key) &gt;= 0) {
                    // GH988 - numeric options can be disabled by setting them to &#x60;false&#x60;
                    if (val !== &quot;false&quot;) {
                        val = +val;

                        if (typeof val !== &quot;number&quot; || !isFinite(val) || val &lt;= 0 || Math.floor(val) !== val) {
                            error(&quot;E032&quot;, nt, g[1].trim());
                            return;
                        }

                        state.option[key] = val;
                    } else {
                        state.option[key] = key === &quot;indent&quot; ? 4 : false;
                    }

                    return;
                }

                /**
                 * TODO: Remove in JSHint 3
                 */
                if (key === &quot;es5&quot;) {
                    if (val === &quot;true&quot; &amp;&amp; state.option.es5) {
                        warning(&quot;I003&quot;);
                    }
                }

                if (key === &quot;validthis&quot;) {
                    // &#x60;validthis&#x60; is valid only within a function scope.

                    if (state.funct[&quot;(global)&quot;])
                        return void error(&quot;E009&quot;);

                    if (val !== &quot;true&quot; &amp;&amp; val !== &quot;false&quot;)
                        return void error(&quot;E002&quot;, nt);

                    state.option.validthis = (val === &quot;true&quot;);
                    return;
                }

                if (key === &quot;quotmark&quot;) {
                    switch (val) {
                        case &quot;true&quot;:
                        case &quot;false&quot;:
                            state.option.quotmark = (val === &quot;true&quot;);
                            break;
                        case &quot;double&quot;:
                        case &quot;single&quot;:
                            state.option.quotmark = val;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;shadow&quot;) {
                    switch (val) {
                        case &quot;true&quot;:
                            state.option.shadow = true;
                            break;
                        case &quot;outer&quot;:
                            state.option.shadow = &quot;outer&quot;;
                            break;
                        case &quot;false&quot;:
                        case &quot;inner&quot;:
                            state.option.shadow = &quot;inner&quot;;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;unused&quot;) {
                    switch (val) {
                        case &quot;true&quot;:
                            state.option.unused = true;
                            break;
                        case &quot;false&quot;:
                            state.option.unused = false;
                            break;
                        case &quot;vars&quot;:
                        case &quot;strict&quot;:
                            state.option.unused = val;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;latedef&quot;) {
                    switch (val) {
                        case &quot;true&quot;:
                            state.option.latedef = true;
                            break;
                        case &quot;false&quot;:
                            state.option.latedef = false;
                            break;
                        case &quot;nofunc&quot;:
                            state.option.latedef = &quot;nofunc&quot;;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;ignore&quot;) {
                    switch (val) {
                        case &quot;line&quot;:
                            state.ignoredLines[nt.line] = true;
                            removeIgnoredMessages();
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;strict&quot;) {
                    switch (val) {
                        case &quot;true&quot;:
                            state.option.strict = true;
                            break;
                        case &quot;false&quot;:
                            state.option.strict = false;
                            break;
                        case &quot;func&quot;:
                        case &quot;global&quot;:
                        case &quot;implied&quot;:
                            state.option.strict = val;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;module&quot;) {
                    /**
                     * TODO: Extend this restriction to *all* &quot;environmental&quot; options.
                     */
                    if (!hasParsedCode(state.funct)) {
                        error(&quot;E055&quot;, state.tokens.next, &quot;module&quot;);
                    }
                }

                /**
                 * TODO: Remove in JSHint 3
                 */
                var esversions = {
                    es3: 3,
                    es5: 5,
                    esnext: 6
                };
                if (has(esversions, key)) {
                    switch (val) {
                        case &quot;true&quot;:
                            state.option.moz = false;
                            state.option.esversion = esversions[key];
                            break;
                        case &quot;false&quot;:
                            if (!state.option.moz) {
                                state.option.esversion = 5;
                            }
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    return;
                }

                if (key === &quot;esversion&quot;) {
                    switch (val) {
                        case &quot;5&quot;:
                            if (state.inES5(true)) {
                                warning(&quot;I003&quot;);
                            }
                        /* falls through */
                        case &quot;3&quot;:
                        case &quot;6&quot;:
                            state.option.moz = false;
                            state.option.esversion = +val;
                            break;
                        case &quot;2015&quot;:
                            state.option.moz = false;
                            state.option.esversion = 6;
                            break;
                        default:
                            error(&quot;E002&quot;, nt);
                    }
                    if (!hasParsedCode(state.funct)) {
                        error(&quot;E055&quot;, state.tokens.next, &quot;esversion&quot;);
                    }
                    return;
                }

                var match = /^([+-])(W\d{3})$/g.exec(key);
                if (match) {
                    // ignore for -W..., unignore for +W...
                    state.ignored[match[2]] = (match[1] === &quot;-&quot;);
                    return;
                }

                var tn;
                if (val === &quot;true&quot; || val === &quot;false&quot;) {
                    if (nt.type === &quot;jslint&quot;) {
                        tn = renamed[key] || key;
                        state.option[tn] = (val === &quot;true&quot;);

                        if (inverted[tn] !== void 0) {
                            state.option[tn] = !state.option[tn];
                        }
                    } else {
                        state.option[key] = (val === &quot;true&quot;);
                    }

                    return;
                }

                error(&quot;E002&quot;, nt);
            });

            assume();
        }
    }

    // We need a peek function. If it has an argument, it peeks that much farther
    // ahead. It is used to distinguish
    //     for ( var i in ...
    // from
    //     for ( var i = ...

    function peek(p?) {
        var i = p || 0, j = lookahead.length, t;

        if (i &lt; j) {
            return lookahead[i];
        }

        while (j &lt;= i) {
            t = lookahead[j];
            if (!t) {
                t = lookahead[j] = lex.token();
            }
            j += 1;
        }

        // Peeking past the end of the program should produce the &quot;(end)&quot; token.
        if (!t &amp;&amp; state.tokens.next.id === &quot;(end)&quot;) {
            return state.tokens.next;
        }

        return t;
    }

    function peekIgnoreEOL() {
        var i = 0;
        var t;
        do {
            t = peek(i++);
        } while (t.id === &quot;(endline)&quot;);
        return t;
    }

    // Produce the next token. It looks for programming errors.

    function advance(id?, t?) {

        switch (state.tokens.curr.id) {
            case &quot;(number)&quot;:
                if (state.tokens.next.id === &quot;.&quot;) {
                    warning(&quot;W005&quot;, state.tokens.curr);
                }
                break;
            case &quot;-&quot;:
                if (state.tokens.next.id === &quot;-&quot; || state.tokens.next.id === &quot;--&quot;) {
                    warning(&quot;W006&quot;);
                }
                break;
            case &quot;+&quot;:
                if (state.tokens.next.id === &quot;+&quot; || state.tokens.next.id === &quot;++&quot;) {
                    warning(&quot;W007&quot;);
                }
                break;
        }

        if (id &amp;&amp; state.tokens.next.id !== id) {
            if (t) {
                if (state.tokens.next.id === &quot;(end)&quot;) {
                    error(&quot;E019&quot;, t, t.id);
                } else {
                    error(&quot;E020&quot;, state.tokens.next, id, t.id, t.line, state.tokens.next.value);
                }
            } else if (state.tokens.next.type !== &quot;(identifier)&quot; || state.tokens.next.value !== id) {
                warning(&quot;W116&quot;, state.tokens.next, id, state.tokens.next.value);
            }
        }

        state.tokens.prev = state.tokens.curr;
        state.tokens.curr = state.tokens.next;
        for (; ;) {
            state.tokens.next = lookahead.shift() || lex.token();

            if (!state.tokens.next) { // No more tokens left, give up
                quit(&quot;E041&quot;, state.tokens.curr);
            }

            if (state.tokens.next.id === &quot;(end)&quot; || state.tokens.next.id === &quot;(error)&quot;) {
                return;
            }

            if (state.tokens.next.check) {
                state.tokens.next.check();
            }

            if (state.tokens.next.isSpecial) {
                if (state.tokens.next.type === &quot;falls through&quot;) {
                    state.tokens.curr.caseFallsThrough = true;
                } else {
                    doOption();
                }
            } else {
                if (state.tokens.next.id !== &quot;(endline)&quot;) {
                    break;
                }
            }
        }
    }

    function isInfix(token) {
        return token.infix || (!token.identifier &amp;&amp; !token.template &amp;&amp; !!token.led);
    }

    function isEndOfExpr() {
        var curr = state.tokens.curr;
        var next = state.tokens.next;
        if (next.id === &quot;;&quot; || next.id === &quot;}&quot; || next.id === &quot;:&quot;) {
            return true;
        }
        if (isInfix(next) === isInfix(curr) || (curr.id === &quot;yield&quot; &amp;&amp; state.inMoz())) {
            return curr.line !== startLine(next);
        }
        return false;
    }

    function isBeginOfExpr(prev) {
        return !prev.left &amp;&amp; prev.arity !== &quot;unary&quot;;
    }

    // This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
    // is looking for ad hoc lint patterns. We add .fud to Pratt&#x27;s model, which is
    // like .nud except that it is only used on the first token of a statement.
    // Having .fud makes it much easier to define statement-oriented languages like
    // JavaScript. I retained Pratt&#x27;s nomenclature.

    // .nud  Null denotation
    // .fud  First null denotation
    // .led  Left denotation
    //  lbp  Left binding power
    //  rbp  Right binding power

    // They are elements of the parsing method called Top Down Operator Precedence.

    function expression(rbp, initial?) {
        var left, isArray = false, isObject = false, isLetExpr = false;

        state.nameStack.push();

        // if current expression is a let expression
        if (!initial &amp;&amp; state.tokens.next.value === &quot;let&quot; &amp;&amp; peek(0).value === &quot;(&quot;) {
            if (!state.inMoz()) {
                warning(&quot;W118&quot;, state.tokens.next, &quot;let expressions&quot;);
            }
            isLetExpr = true;
            // create a new block scope we use only for the current expression
            state.funct[&quot;(scope)&quot;].stack();
            advance(&quot;let&quot;);
            advance(&quot;(&quot;);
            state.tokens.prev.fud();
            advance(&quot;)&quot;);
        }

        if (state.tokens.next.id === &quot;(end)&quot;)
            error(&quot;E006&quot;, state.tokens.curr);

        var isDangerous =
            state.option.asi &amp;&amp;
            state.tokens.prev.line !== startLine(state.tokens.curr) &amp;&amp;
            contains([&quot;]&quot;, &quot;)&quot;], state.tokens.prev.id) &amp;&amp;
            contains([&quot;[&quot;, &quot;(&quot;], state.tokens.curr.id);

        if (isDangerous)
            warning(&quot;W014&quot;, state.tokens.curr, state.tokens.curr.id);

        advance();

        if (initial) {
            state.funct[&quot;(verb)&quot;] = state.tokens.curr.value;
            state.tokens.curr.beginsStmt = true;
        }

        if (initial === true &amp;&amp; state.tokens.curr.fud) {
            left = state.tokens.curr.fud();
        } else {
            if (state.tokens.curr.nud) {
                left = state.tokens.curr.nud();
            } else {
                error(&quot;E030&quot;, state.tokens.curr, state.tokens.curr.id);
            }

            // TODO: use pratt mechanics rather than special casing template tokens
            while ((rbp &lt; state.tokens.next.lbp || state.tokens.next.type === &quot;(template)&quot;) &amp;&amp;
                !isEndOfExpr()) {
                isArray = state.tokens.curr.value === &quot;Array&quot;;
                isObject = state.tokens.curr.value === &quot;Object&quot;;

                // #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
                // Line breaks in IfStatement heads exist to satisfy the checkJSHint
                // &quot;Line too long.&quot; error.
                if (left &amp;&amp; (left.value || (left.first &amp;&amp; left.first.value))) {
                    // If the left.value is not &quot;new&quot;, or the left.first.value is a &quot;.&quot;
                    // then safely assume that this is not &quot;new Array()&quot; and possibly
                    // not &quot;new Object()&quot;...
                    if (left.value !== &quot;new&quot; ||
                        (left.first &amp;&amp; left.first.value &amp;&amp; left.first.value === &quot;.&quot;)) {
                        isArray = false;
                        // ...In the case of Object, if the left.value and state.tokens.curr.value
                        // are not equal, then safely assume that this not &quot;new Object()&quot;
                        if (left.value !== state.tokens.curr.value) {
                            isObject = false;
                        }
                    }
                }

                advance();

                if (isArray &amp;&amp; state.tokens.curr.id === &quot;(&quot; &amp;&amp; state.tokens.next.id === &quot;)&quot;) {
                    warning(&quot;W009&quot;, state.tokens.curr);
                }

                if (isObject &amp;&amp; state.tokens.curr.id === &quot;(&quot; &amp;&amp; state.tokens.next.id === &quot;)&quot;) {
                    warning(&quot;W010&quot;, state.tokens.curr);
                }

                if (left &amp;&amp; state.tokens.curr.led) {
                    left = state.tokens.curr.led(left);
                } else {
                    error(&quot;E033&quot;, state.tokens.curr, state.tokens.curr.id);
                }
            }
        }
        if (isLetExpr) {
            state.funct[&quot;(scope)&quot;].unstack();
        }

        state.nameStack.pop();

        return left;
    }


    // Functions for conformance of style.

    function startLine(token) {
        return token.startLine || token.line;
    }

    function nobreaknonadjacent(left, right) {
        left = left || state.tokens.curr;
        right = right || state.tokens.next;
        if (!state.option.laxbreak &amp;&amp; left.line !== startLine(right)) {
            warning(&quot;W014&quot;, right, right.value);
        }
    }

    function nolinebreak(t) {
        t = t || state.tokens.curr;
        if (t.line !== startLine(state.tokens.next)) {
            warning(&quot;E022&quot;, t, t.value);
        }
    }

    function nobreakcomma(left, right) {
        if (left.line !== startLine(right)) {
            if (!state.option.laxcomma) {
                if (comma[&#x27;first&#x27;]) {
                    warning(&quot;I001&quot;);
                    comma[&#x27;first&#x27;] = false;
                }
                warning(&quot;W014&quot;, left, right.value);
            }
        }
    }

    function comma(opts?) {
        opts = opts || {};

        if (!opts.peek) {
            nobreakcomma(state.tokens.curr, state.tokens.next);
            advance(&quot;,&quot;);
        } else {
            nobreakcomma(state.tokens.prev, state.tokens.curr);
        }

        if (state.tokens.next.identifier &amp;&amp; !(opts.property &amp;&amp; state.inES5())) {
            // Keywords that cannot follow a comma operator.
            switch (state.tokens.next.value) {
                case &quot;break&quot;:
                case &quot;case&quot;:
                case &quot;catch&quot;:
                case &quot;continue&quot;:
                case &quot;default&quot;:
                case &quot;do&quot;:
                case &quot;else&quot;:
                case &quot;finally&quot;:
                case &quot;for&quot;:
                case &quot;if&quot;:
                case &quot;in&quot;:
                case &quot;instanceof&quot;:
                case &quot;return&quot;:
                case &quot;switch&quot;:
                case &quot;throw&quot;:
                case &quot;try&quot;:
                case &quot;var&quot;:
                case &quot;let&quot;:
                case &quot;while&quot;:
                case &quot;with&quot;:
                    error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
                    return false;
            }
        }

        if (state.tokens.next.type === &quot;(punctuator)&quot;) {
            switch (state.tokens.next.value) {
                case &quot;}&quot;:
                case &quot;]&quot;:
                case &quot;,&quot;:
                    if (opts.allowTrailing) {
                        return true;
                    }

                /* falls through */
                case &quot;)&quot;:
                    error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
                    return false;
            }
        }
        return true;
    }

    // Functional constructors for making the symbols that will be inherited by
    // tokens.

    function symbol(s: string, p) {
        var x = state.syntax[s];
        if (!x || typeof x !== &quot;object&quot;) {
            state.syntax[s] = x = {
                id: s,
                lbp: p,
                value: s
            };
        }
        return x;
    }

    function delim(s: string) {
        var x = symbol(s, 0);
        x.delim = true;
        return x;
    }

    function stmt(s: string, f) {
        var x = delim(s);
        x.identifier = x.reserved = true;
        x.fud = f;
        return x;
    }

    function blockstmt(s: string, f) {
        var x = stmt(s, f);
        x.block = true;
        return x;
    }

    function reserveName(x: { id: string; identifier?; reserved?}) {
        var c = x.id.charAt(0);
        if ((c &gt;= &quot;a&quot; &amp;&amp; c &lt;= &quot;z&quot;) || (c &gt;= &quot;A&quot; &amp;&amp; c &lt;= &quot;Z&quot;)) {
            x.identifier = x.reserved = true;
        }
        return x;
    }

    function prefix(s: string, f?) {
        var x = symbol(s, 150);
        reserveName(x);

        x.nud = (typeof f === &quot;function&quot;) ? f : function() {
            this.arity = &quot;unary&quot;;
            this.right = expression(150);

            if (this.id === &quot;++&quot; || this.id === &quot;--&quot;) {
                if (state.option.plusplus) {
                    warning(&quot;W016&quot;, this, this.id);
                } else if (this.right &amp;&amp; (!this.right.identifier || isReserved(this.right)) &amp;&amp;
                    this.right.id !== &quot;.&quot; &amp;&amp; this.right.id !== &quot;[&quot;) {
                    warning(&quot;W017&quot;, this);
                }

                if (this.right &amp;&amp; this.right.isMetaProperty) {
                    error(&quot;E031&quot;, this);
                    // detect increment/decrement of a const
                    // in the case of a.b, right will be the &quot;.&quot; punctuator
                } else if (this.right &amp;&amp; this.right.identifier) {
                    state.funct[&quot;(scope)&quot;].block.modify(this.right.value, this);
                }
            }

            return this;
        };

        return x;
    }

    function type(s: string, func) {
        var x = delim(s);
        x.type = s;
        x.nud = func;
        return x;
    }

    function reserve(name: string, func?) {
        var x = type(name, func);
        x.identifier = true;
        x.reserved = true;
        return x;
    }

    function FutureReservedWord(name: string, meta?) {
        var x = type(name, (meta &amp;&amp; meta.nud) || function() {
            return this;
        });

        meta = meta || {};
        meta.isFutureReservedWord = true;

        x.value = name;
        x.identifier = true;
        x.reserved = true;
        x.meta = meta;

        return x;
    }

    function reservevar(s: string, v?) {
        return reserve(s, function() {
            if (typeof v === &quot;function&quot;) {
                v(this);
            }
            return this;
        });
    }

    function infix(s: string, f, p, w?) {
        var x = symbol(s, p);
        reserveName(x);
        x.infix = true;
        x.led = function(left) {
            if (!w) {
                nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
            }
            if ((s === &quot;in&quot; || s === &quot;instanceof&quot;) &amp;&amp; left.id === &quot;!&quot;) {
                warning(&quot;W018&quot;, left, &quot;!&quot;);
            }
            if (typeof f === &quot;function&quot;) {
                return f(left, this);
            }
            else {
                this.left = left;
                this.right = expression(p);
                return this;
            }
        };
        return x;
    }

    function application(s: string) {
        var x = symbol(s, 42);

        x.led = function(left) {
            nobreaknonadjacent(state.tokens.prev, state.tokens.curr);

            this.left = left;
            this.right = doFunction({ type: &quot;arrow&quot;, loneArg: left });
            return this;
        };
        return x;
    }

    function relation(s: string, f?) {
        var x = symbol(s, 100);

        x.led = function(left) {
            nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
            this.left = left;
            var right = this.right = expression(100);

            if (isIdentifier(left, &quot;NaN&quot;) || isIdentifier(right, &quot;NaN&quot;)) {
                warning(&quot;W019&quot;, this);
            } else if (f) {
                f.apply(this, [left, right]);
            }

            if (!left || !right) {
                quit(&quot;E041&quot;, state.tokens.curr);
            }

            if (left.id === &quot;!&quot;) {
                warning(&quot;W018&quot;, left, &quot;!&quot;);
            }

            if (right.id === &quot;!&quot;) {
                warning(&quot;W018&quot;, right, &quot;!&quot;);
            }

            return this;
        };
        return x;
    }

    function isPoorRelation(node) {
        return node &amp;&amp;
            ((node.type === &quot;(number)&quot; &amp;&amp; +node.value === 0) ||
                (node.type === &quot;(string)&quot; &amp;&amp; node.value === &quot;&quot;) ||
                (node.type === &quot;null&quot; &amp;&amp; !state.option.eqnull) ||
                node.type === &quot;true&quot; ||
                node.type === &quot;false&quot; ||
                node.type === &quot;undefined&quot;);
    }

    var typeofValues: { legacy?: string[]; es3?: string[]; es6?: string[] } = {};
    typeofValues.legacy = [
        // E4X extended the &#x60;typeof&#x60; operator to return &quot;xml&quot; for the XML and
        // XMLList types it introduced.
        // Ref: 11.3.2 The typeof Operator
        // http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-357.pdf
        &quot;xml&quot;,
        // IE&lt;9 reports &quot;unknown&quot; when the &#x60;typeof&#x60; operator is applied to an
        // object existing across a COM+ bridge. In lieu of official documentation
        // (which does not exist), see:
        // http://robertnyman.com/2005/12/21/what-is-typeof-unknown/
        &quot;unknown&quot;
    ];
    typeofValues.es3 = [
        &quot;undefined&quot;, &quot;boolean&quot;, &quot;number&quot;, &quot;string&quot;, &quot;function&quot;, &quot;object&quot;,
    ];
    typeofValues.es3 = typeofValues.es3.concat(typeofValues.legacy);
    typeofValues.es6 = typeofValues.es3.concat(&quot;symbol&quot;);

    // Checks whether the &#x27;typeof&#x27; operator is used with the correct
    // value. For docs on &#x27;typeof&#x27; see:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
    function isTypoTypeof(left: { type: string; value: string }, right, state) {
        var values: string[];

        if (state.option.notypeof)
            return false;

        if (!left || !right)
            return false;

        values = state.inES6() ? typeofValues.es6 : typeofValues.es3;

        if (right.type === &quot;(identifier)&quot; &amp;&amp; right.value === &quot;typeof&quot; &amp;&amp; left.type === &quot;(string)&quot;)
            return !contains(values, left.value);

        return false;
    }

    function isGlobalEval(left, state) {
        var isGlobal = false;

        // permit methods to refer to an &quot;eval&quot; key in their own context
        if (left.type === &quot;this&quot; &amp;&amp; state.funct[&quot;(context)&quot;] === null) {
            isGlobal = true;
        }
        // permit use of &quot;eval&quot; members of objects
        else if (left.type === &quot;(identifier)&quot;) {
            if (state.option.node &amp;&amp; left.value === &quot;global&quot;) {
                isGlobal = true;
            }

            else if (state.option.browser &amp;&amp; (left.value === &quot;window&quot; || left.value === &quot;document&quot;)) {
                isGlobal = true;
            }
        }

        return isGlobal;
    }

    function findNativePrototype(left) {
        var natives = [
            &quot;Array&quot;, &quot;ArrayBuffer&quot;, &quot;Boolean&quot;, &quot;Collator&quot;, &quot;DataView&quot;, &quot;Date&quot;,
            &quot;DateTimeFormat&quot;, &quot;Error&quot;, &quot;EvalError&quot;, &quot;Float32Array&quot;, &quot;Float64Array&quot;,
            &quot;Function&quot;, &quot;Infinity&quot;, &quot;Intl&quot;, &quot;Int16Array&quot;, &quot;Int32Array&quot;, &quot;Int8Array&quot;,
            &quot;Iterator&quot;, &quot;Number&quot;, &quot;NumberFormat&quot;, &quot;Object&quot;, &quot;RangeError&quot;,
            &quot;ReferenceError&quot;, &quot;RegExp&quot;, &quot;StopIteration&quot;, &quot;String&quot;, &quot;SyntaxError&quot;,
            &quot;TypeError&quot;, &quot;Uint16Array&quot;, &quot;Uint32Array&quot;, &quot;Uint8Array&quot;, &quot;Uint8ClampedArray&quot;,
            &quot;URIError&quot;
        ];

        function walkPrototype(obj) {
            if (typeof obj !== &quot;object&quot;) return;
            return obj.right === &quot;prototype&quot; ? obj : walkPrototype(obj.left);
        }

        function walkNative(obj) {
            while (!obj.identifier &amp;&amp; typeof obj.left === &quot;object&quot;)
                obj = obj.left;

            if (obj.identifier &amp;&amp; natives.indexOf(obj.value) &gt;= 0)
                return obj.value;
        }

        var prototype = walkPrototype(left);
        if (prototype) return walkNative(prototype);
    }

    /**
     * Checks the left hand side of an assignment for issues, returns if ok
     * @param {token} left - the left hand side of the assignment
     * @param {token=} assignToken - the token for the assignment, used for reporting
     * @param {object=} options - optional object
     * @param {boolean} options.allowDestructuring - whether to allow destructuting binding
     * @returns {boolean} Whether the left hand side is OK
     */
    function checkLeftSideAssign(left, assignToken?, options?: { allowDestructuring?: boolean }) {

        var allowDestructuring = options &amp;&amp; options.allowDestructuring;

        assignToken = assignToken || left;

        if (state.option.freeze) {
            var nativeObject = findNativePrototype(left);
            if (nativeObject)
                warning(&quot;W121&quot;, left, nativeObject);
        }

        if (left.identifier &amp;&amp; !left.isMetaProperty) {
            // reassign also calls modify
            // but we are specific in order to catch function re-assignment
            // and globals re-assignment
            state.funct[&quot;(scope)&quot;].block.reassign(left.value, left);
        }

        if (left.id === &quot;.&quot;) {
            if (!left.left || left.left.value === &quot;arguments&quot; &amp;&amp; !state.isStrict()) {
                warning(&quot;E031&quot;, assignToken);
            }

            state.nameStack.set(state.tokens.prev);
            return true;
        } else if (left.id === &quot;{&quot; || left.id === &quot;[&quot;) {
            if (allowDestructuring &amp;&amp; state.tokens.curr.left.destructAssign) {
                state.tokens.curr.left.destructAssign.forEach(function(t) {
                    if (t.id) {
                        state.funct[&quot;(scope)&quot;].block.modify(t.id, t.token);
                    }
                });
            } else {
                if (left.id === &quot;{&quot; || !left.left) {
                    warning(&quot;E031&quot;, assignToken);
                } else if (left.left.value === &quot;arguments&quot; &amp;&amp; !state.isStrict()) {
                    warning(&quot;E031&quot;, assignToken);
                }
            }

            if (left.id === &quot;[&quot;) {
                state.nameStack.set(left.right);
            }

            return true;
        } else if (left.isMetaProperty) {
            error(&quot;E031&quot;, assignToken);
            return true;
        } else if (left.identifier &amp;&amp; !isReserved(left)) {
            if (state.funct[&quot;(scope)&quot;].labeltype(left.value) === &quot;exception&quot;) {
                warning(&quot;W022&quot;, left);
            }
            state.nameStack.set(left);
            return true;
        }

        if (left === state.syntax[&quot;function&quot;]) {
            warning(&quot;W023&quot;, state.tokens.curr);
        }

        return false;
    }

    function assignop(s, f, p) {
        var x = infix(s, typeof f === &quot;function&quot; ? f : function(left, that) {
            that.left = left;

            if (left &amp;&amp; checkLeftSideAssign(left, that, { allowDestructuring: true })) {
                that.right = expression(10);
                return that;
            }

            error(&quot;E031&quot;, that);
        }, p);

        x.exps = true;
        x.assign = true;
        return x;
    }


    function bitwise(s, f, p) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = (typeof f === &quot;function&quot;) ? f : function(left) {
            if (state.option.bitwise) {
                warning(&quot;W016&quot;, this, this.id);
            }
            this.left = left;
            this.right = expression(p);
            return this;
        };
        return x;
    }

    function bitwiseassignop(s) {
        return assignop(s, function(left, that) {
            if (state.option.bitwise) {
                warning(&quot;W016&quot;, that, that.id);
            }

            if (left &amp;&amp; checkLeftSideAssign(left, that)) {
                that.right = expression(10);
                return that;
            }
            error(&quot;E031&quot;, that);
        }, 20);
    }

    function suffix(s) {
        var x = symbol(s, 150);

        x.led = function(left) {
            // this = suffix e.g. &quot;++&quot; punctuator
            // left = symbol operated e.g. &quot;a&quot; identifier or &quot;a.b&quot; punctuator
            if (state.option.plusplus) {
                warning(&quot;W016&quot;, this, this.id);
            } else if ((!left.identifier || isReserved(left)) &amp;&amp; left.id !== &quot;.&quot; &amp;&amp; left.id !== &quot;[&quot;) {
                warning(&quot;W017&quot;, this);
            }

            if (left.isMetaProperty) {
                error(&quot;E031&quot;, this);
                // detect increment/decrement of a const
                // in the case of a.b, left will be the &quot;.&quot; punctuator
            } else if (left &amp;&amp; left.identifier) {
                state.funct[&quot;(scope)&quot;].block.modify(left.value, left);
            }

            this.left = left;
            return this;
        };
        return x;
    }

    // fnparam means that this identifier is being defined as a function
    // argument (see identifier())
    // prop means that this identifier is that of an object property

    function optionalidentifier(fnparam?, prop?, preserve?) {
        if (!state.tokens.next.identifier) {
            return;
        }

        if (!preserve) {
            advance();
        }

        var curr = state.tokens.curr;
        var val = state.tokens.curr.value;

        if (!isReserved(curr)) {
            return val;
        }

        if (prop) {
            if (state.inES5()) {
                return val;
            }
        }

        if (fnparam &amp;&amp; val === &quot;undefined&quot;) {
            return val;
        }

        warning(&quot;W024&quot;, state.tokens.curr, state.tokens.curr.id);
        return val;
    }

    // fnparam means that this identifier is being defined as a function
    // argument
    // prop means that this identifier is that of an object property
    function identifier(fnparam?, prop?) {
        var i = optionalidentifier(fnparam, prop, false);
        if (i) {
            return i;
        }

        // parameter destructuring with rest operator
        if (state.tokens.next.value === &quot;...&quot;) {
            if (!state.inES6(true)) {
                warning(&quot;W119&quot;, state.tokens.next, &quot;spread/rest operator&quot;, &quot;6&quot;);
            }
            advance();

            if (checkPunctuator(state.tokens.next, &quot;...&quot;)) {
                warning(&quot;E024&quot;, state.tokens.next, &quot;...&quot;);
                while (checkPunctuator(state.tokens.next, &quot;...&quot;)) {
                    advance();
                }
            }

            if (!state.tokens.next.identifier) {
                warning(&quot;E024&quot;, state.tokens.curr, &quot;...&quot;);
                return;
            }

            return identifier(fnparam, prop);
        } else {
            error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);

            // The token should be consumed after a warning is issued so the parser
            // can continue as though an identifier were found. The semicolon token
            // should not be consumed in this way so that the parser interprets it as
            // a statement delimeter;
            if (state.tokens.next.id !== &quot;;&quot;) {
                advance();
            }
        }
    }


    function reachable(controlToken) {
        var i = 0, t;
        if (state.tokens.next.id !== &quot;;&quot; || controlToken.inBracelessBlock) {
            return;
        }
        for (; ;) {
            do {
                t = peek(i);
                i += 1;
            } while (t.id !== &quot;(end)&quot; &amp;&amp; t.id === &quot;(comment)&quot;);

            if (t.reach) {
                return;
            }
            if (t.id !== &quot;(endline)&quot;) {
                if (t.id === &quot;function&quot;) {
                    if (state.option.latedef === true) {
                        warning(&quot;W026&quot;, t);
                    }
                    break;
                }

                warning(&quot;W027&quot;, t, t.value, controlToken.value);
                break;
            }
        }
    }

    function parseFinalSemicolon() {
        if (state.tokens.next.id !== &quot;;&quot;) {
            // don&#x27;t complain about unclosed templates / strings
            if (state.tokens.next.isUnclosed) return advance();

            var sameLine = startLine(state.tokens.next) === state.tokens.curr.line &amp;&amp;
                state.tokens.next.id !== &quot;(end)&quot;;
            var blockEnd = checkPunctuator(state.tokens.next, &quot;}&quot;);

            if (sameLine &amp;&amp; !blockEnd) {
                errorAt(&quot;E058&quot;, state.tokens.curr.line, state.tokens.curr.character);
            } else if (!state.option.asi) {
                // If this is the last statement in a block that ends on
                // the same line *and* option lastsemic is on, ignore the warning.
                // Otherwise, complain about missing semicolon.
                if ((blockEnd &amp;&amp; !state.option.lastsemic) || !sameLine) {
                    warningAt(&quot;W033&quot;, state.tokens.curr.line, state.tokens.curr.character);
                }
            }
        } else {
            advance(&quot;;&quot;);
        }
    }

    function statement() {
        var i = indent, r, t = state.tokens.next, hasOwnScope = false;

        if (t.id === &quot;;&quot;) {
            advance(&quot;;&quot;);
            return;
        }

        // Is this a labelled statement?
        var res = isReserved(t);

        // We&#x27;re being more tolerant here: if someone uses
        // a FutureReservedWord as a label, we warn but proceed
        // anyway.

        if (res &amp;&amp; t.meta &amp;&amp; t.meta.isFutureReservedWord &amp;&amp; peek().id === &quot;:&quot;) {
            warning(&quot;W024&quot;, t, t.id);
            res = false;
        }

        if (t.identifier &amp;&amp; !res &amp;&amp; peek().id === &quot;:&quot;) {
            advance();
            advance(&quot;:&quot;);

            hasOwnScope = true;
            state.funct[&quot;(scope)&quot;].stack();
            state.funct[&quot;(scope)&quot;].block.addBreakLabel(t.value, { token: state.tokens.curr });

            if (!state.tokens.next.labelled &amp;&amp; state.tokens.next.value !== &quot;{&quot;) {
                warning(&quot;W028&quot;, state.tokens.next, t.value, state.tokens.next.value);
            }

            state.tokens.next.label = t.value;
            t = state.tokens.next;
        }

        // Is it a lonely block?

        if (t.id === &quot;{&quot;) {
            // Is it a switch case block?
            //
            //  switch (foo) {
            //    case bar: { &lt;= here.
            //      ...
            //    }
            //  }
            var iscase = (state.funct[&quot;(verb)&quot;] === &quot;case&quot; &amp;&amp; state.tokens.curr.value === &quot;:&quot;);
            block(true, true, false, false, iscase);
            return;
        }

        // Parse the statement.

        r = expression(0, true);

        if (r &amp;&amp; !(r.identifier &amp;&amp; r.value === &quot;function&quot;) &amp;&amp;
            !(r.type === &quot;(punctuator)&quot; &amp;&amp; r.left &amp;&amp;
                r.left.identifier &amp;&amp; r.left.value === &quot;function&quot;)) {
            if (!state.isStrict() &amp;&amp;
                state.option.strict === &quot;global&quot;) {
                warning(&quot;E007&quot;);
            }
        }

        // Look for the final semicolon.

        if (!t.block) {
            if (!state.option.expr &amp;&amp; (!r || !r.exps)) {
                warning(&quot;W030&quot;, state.tokens.curr);
            } else if (state.option.nonew &amp;&amp; r &amp;&amp; r.left &amp;&amp; r.id === &quot;(&quot; &amp;&amp; r.left.id === &quot;new&quot;) {
                warning(&quot;W031&quot;, t);
            }
            parseFinalSemicolon();
        }


        // Restore the indentation.

        indent = i;
        if (hasOwnScope) {
            state.funct[&quot;(scope)&quot;].unstack();
        }
        return r;
    }


    function statements() {
        var a = [], p;

        while (!state.tokens.next.reach &amp;&amp; state.tokens.next.id !== &quot;(end)&quot;) {
            if (state.tokens.next.id === &quot;;&quot;) {
                p = peek();

                if (!p || (p.id !== &quot;(&quot; &amp;&amp; p.id !== &quot;[&quot;)) {
                    warning(&quot;W032&quot;);
                }

                advance(&quot;;&quot;);
            } else {
                a.push(statement());
            }
        }
        return a;
    }


    /*
     * read all directives
     * recognizes a simple form of asi, but always
     * warns, if it is used
     */
    function directives() {
        var i, p, pn;

        while (state.tokens.next.id === &quot;(string)&quot;) {
            p = peek(0);
            if (p.id === &quot;(endline)&quot;) {
                i = 1;
                do {
                    pn = peek(i++);
                } while (pn.id === &quot;(endline)&quot;);
                if (pn.id === &quot;;&quot;) {
                    p = pn;
                } else if (pn.value === &quot;[&quot; || pn.value === &quot;.&quot;) {
                    // string -&gt; [ | . is a valid production
                    break;
                } else if (!state.option.asi || pn.value === &quot;(&quot;) {
                    // string -&gt; ( is not a valid production
                    warning(&quot;W033&quot;, state.tokens.next);
                }
            } else if (p.id === &quot;.&quot; || p.id === &quot;[&quot;) {
                break;
            } else if (p.id !== &quot;;&quot;) {
                warning(&quot;W033&quot;, p);
            }

            advance();
            var directive = state.tokens.curr.value;
            if (state.directive[directive] ||
                (directive === &quot;use strict&quot; &amp;&amp; state.option.strict === &quot;implied&quot;)) {
                warning(&quot;W034&quot;, state.tokens.curr, directive);
            }

            // there&#x27;s no directive negation, so always set to true
            state.directive[directive] = true;

            if (p.id === &quot;;&quot;) {
                advance(&quot;;&quot;);
            }
        }

        if (state.isStrict()) {
            state.option.undef = true;
        }
    }


    /*
     * Parses a single block. A block is a sequence of statements wrapped in
     * braces.
     *
     * ordinary   - true for everything but function bodies and try blocks.
     * stmt       - true if block can be a single statement (e.g. in if/for/while).
     * isfunc     - true if block is a function body
     * isfatarrow - true if its a body of a fat arrow function
     * iscase      - true if block is a switch case block
     */
    function block(ordinary: boolean, stmt?: boolean, isfunc?: boolean, isfatarrow?: boolean, iscase?: boolean) {
        var a,
            b = inblock,
            old_indent = indent,
            m,
            t,
            line,
            d;

        inblock = ordinary;

        t = state.tokens.next;

        var metrics = state.funct[&quot;(metrics)&quot;];
        metrics.nestedBlockDepth += 1;
        metrics.verifyMaxNestedBlockDepthPerFunction();

        if (state.tokens.next.id === &quot;{&quot;) {
            advance(&quot;{&quot;);

            // create a new block scope
            state.funct[&quot;(scope)&quot;].stack();
            state.funct[&quot;(noblockscopedvar)&quot;] = false;

            line = state.tokens.curr.line;
            if (state.tokens.next.id !== &quot;}&quot;) {
                indent += state.option.indent;
                while (!ordinary &amp;&amp; state.tokens.next.from &gt; indent) {
                    indent += state.option.indent;
                }

                if (isfunc) {
                    m = {};
                    for (d in state.directive) {
                        if (has(state.directive, d)) {
                            m[d] = state.directive[d];
                        }
                    }
                    directives();

                    if (state.option.strict &amp;&amp; state.funct[&quot;(context)&quot;][&quot;(global)&quot;]) {
                        if (!m[&quot;use strict&quot;] &amp;&amp; !state.isStrict()) {
                            warning(&quot;E007&quot;);
                        }
                    }
                }

                a = statements();

                metrics.statementCount += a.length;

                indent -= state.option.indent;
            }

            advance(&quot;}&quot;, t);

            if (isfunc) {
                state.funct[&quot;(scope)&quot;].validateParams();
                if (m) {
                    state.directive = m;
                }
            }

            state.funct[&quot;(scope)&quot;].unstack();

            indent = old_indent;
        } else if (!ordinary) {
            if (isfunc) {
                state.funct[&quot;(scope)&quot;].stack();

                m = {};
                if (stmt &amp;&amp; !isfatarrow &amp;&amp; !state.inMoz()) {
                    error(&quot;W118&quot;, state.tokens.curr, &quot;function closure expressions&quot;);
                }

                if (!stmt) {
                    for (d in state.directive) {
                        if (has(state.directive, d)) {
                            m[d] = state.directive[d];
                        }
                    }
                }
                expression(10);

                if (state.option.strict &amp;&amp; state.funct[&quot;(context)&quot;][&quot;(global)&quot;]) {
                    if (!m[&quot;use strict&quot;] &amp;&amp; !state.isStrict()) {
                        warning(&quot;E007&quot;);
                    }
                }

                state.funct[&quot;(scope)&quot;].unstack();
            } else {
                error(&quot;E021&quot;, state.tokens.next, &quot;{&quot;, state.tokens.next.value);
            }
        } else {

            // check to avoid let declaration not within a block
            // though is fine inside for loop initializer section
            state.funct[&quot;(noblockscopedvar)&quot;] = state.tokens.next.id !== &quot;for&quot;;
            state.funct[&quot;(scope)&quot;].stack();

            if (!stmt || state.option.curly) {
                warning(&quot;W116&quot;, state.tokens.next, &quot;{&quot;, state.tokens.next.value);
            }

            state.tokens.next.inBracelessBlock = true;
            indent += state.option.indent;
            // test indentation only if statement is in new line
            a = [statement()];
            indent -= state.option.indent;

            state.funct[&quot;(scope)&quot;].unstack();
            delete state.funct[&quot;(noblockscopedvar)&quot;];
        }

        // Don&#x27;t clear and let it propagate out if it is &quot;break&quot;, &quot;return&quot; or similar in switch case
        switch (state.funct[&quot;(verb)&quot;]) {
            case &quot;break&quot;:
            case &quot;continue&quot;:
            case &quot;return&quot;:
            case &quot;throw&quot;:
                if (iscase) {
                    break;
                }

            /* falls through */
            default:
                state.funct[&quot;(verb)&quot;] = null;
        }

        inblock = b;
        if (ordinary &amp;&amp; state.option.noempty &amp;&amp; (!a || a.length === 0)) {
            warning(&quot;W035&quot;, state.tokens.prev);
        }
        metrics.nestedBlockDepth -= 1;
        return a;
    }


    function countMember(m) {
        if (membersOnly &amp;&amp; typeof membersOnly[m] !== &quot;boolean&quot;) {
            warning(&quot;W036&quot;, state.tokens.curr, m);
        }
        if (typeof member[m] === &quot;number&quot;) {
            member[m] += 1;
        } else {
            member[m] = 1;
        }
    }

    // Build the syntax table by declaring the syntactic elements of the language.

    type(&quot;(number)&quot;, function() {
        return this;
    });

    type(&quot;(string)&quot;, function() {
        return this;
    });

    state.syntax[&quot;(identifier)&quot;] = {
        type: &quot;(identifier)&quot;,
        lbp: 0,
        identifier: true,

        nud: function() {
            var v = this.value;

            // If this identifier is the lone parameter to a shorthand &quot;fat arrow&quot;
            // function definition, i.e.
            //
            //     x =&gt; x;
            //
            // ...it should not be considered as a variable in the current scope. It
            // will be added to the scope of the new function when the next token is
            // parsed, so it can be safely ignored for now.
            if (state.tokens.next.id === &quot;=&gt;&quot;) {
                return this;
            }

            if (!state.funct[&quot;(comparray)&quot;].check(v)) {
                state.funct[&quot;(scope)&quot;].block.use(v, state.tokens.curr);
            }
            return this;
        },

        led: function() {
            error(&quot;E033&quot;, state.tokens.next, state.tokens.next.value);
        }
    };

    var baseTemplateSyntax = {
        lbp: 0,
        identifier: false,
        template: true,
    };
    state.syntax[&quot;(template)&quot;] = extend({
        type: &quot;(template)&quot;,
        nud: doTemplateLiteral,
        led: doTemplateLiteral,
        noSubst: false
    }, baseTemplateSyntax);

    state.syntax[&quot;(template middle)&quot;] = extend({
        type: &quot;(template middle)&quot;,
        middle: true,
        noSubst: false
    }, baseTemplateSyntax);

    state.syntax[&quot;(template tail)&quot;] = extend({
        type: &quot;(template tail)&quot;,
        tail: true,
        noSubst: false
    }, baseTemplateSyntax);

    state.syntax[&quot;(no subst template)&quot;] = extend({
        type: &quot;(template)&quot;,
        nud: doTemplateLiteral,
        led: doTemplateLiteral,
        noSubst: true,
        tail: true // mark as tail, since it&#x27;s always the last component
    }, baseTemplateSyntax);

    type(&quot;(regexp)&quot;, function() {
        return this;
    });

    // ECMAScript parser

    delim(&quot;(endline)&quot;);
    (function(x) {
        x.line = x.from = 0;
    })(delim(&quot;(begin)&quot;));
    delim(&quot;(end)&quot;).reach = true;
    delim(&quot;(error)&quot;).reach = true;
    delim(&quot;}&quot;).reach = true;
    delim(&quot;)&quot;);
    delim(&quot;]&quot;);
    delim(&quot;\&quot;&quot;).reach = true;
    delim(&quot;&#x27;&quot;).reach = true;
    delim(&quot;;&quot;);
    delim(&quot;:&quot;).reach = true;
    delim(&quot;#&quot;);

    reserve(&quot;else&quot;);
    reserve(&quot;case&quot;).reach = true;
    reserve(&quot;catch&quot;);
    reserve(&quot;default&quot;).reach = true;
    reserve(&quot;finally&quot;);
    reservevar(&quot;arguments&quot;, function(x) {
        if (state.isStrict() &amp;&amp; state.funct[&quot;(global)&quot;]) {
            warning(&quot;E008&quot;, x);
        }
    });
    reservevar(&quot;eval&quot;);
    reservevar(&quot;false&quot;);
    reservevar(&quot;Infinity&quot;);
    reservevar(&quot;null&quot;);
    reservevar(&quot;this&quot;, function(x) {
        if (state.isStrict() &amp;&amp; !isMethod() &amp;&amp;
            !state.option.validthis &amp;&amp; ((state.funct[&quot;(statement)&quot;] &amp;&amp;
                state.funct[&quot;(name)&quot;].charAt(0) &gt; &quot;Z&quot;) || state.funct[&quot;(global)&quot;])) {
            warning(&quot;W040&quot;, x);
        }
    });
    reservevar(&quot;true&quot;);
    reservevar(&quot;undefined&quot;);

    assignop(&quot;=&quot;, &quot;assign&quot;, 20);
    assignop(&quot;+=&quot;, &quot;assignadd&quot;, 20);
    assignop(&quot;-=&quot;, &quot;assignsub&quot;, 20);
    assignop(&quot;*=&quot;, &quot;assignmult&quot;, 20);
    assignop(&quot;/=&quot;, &quot;assigndiv&quot;, 20).nud = function() {
        error(&quot;E014&quot;);
    };
    assignop(&quot;%=&quot;, &quot;assignmod&quot;, 20);

    bitwiseassignop(&quot;&amp;=&quot;);
    bitwiseassignop(&quot;|=&quot;);
    bitwiseassignop(&quot;^=&quot;);
    bitwiseassignop(&quot;&lt;&lt;=&quot;);
    bitwiseassignop(&quot;&gt;&gt;=&quot;);
    bitwiseassignop(&quot;&gt;&gt;&gt;=&quot;);
    infix(&quot;,&quot;, function(left, that) {
        var expr;
        that.exprs = [left];

        if (state.option.nocomma) {
            warning(&quot;W127&quot;);
        }

        if (!comma({ peek: true })) {
            return that;
        }
        while (true) {
            if (!(expr = expression(10))) {
                break;
            }
            that.exprs.push(expr);
            if (state.tokens.next.value !== &quot;,&quot; || !comma()) {
                break;
            }
        }
        return that;
    }, 10, true);

    infix(&quot;?&quot;, function(left, that) {
        increaseComplexityCount();
        that.left = left;
        that.right = expression(10);
        advance(&quot;:&quot;);
        that[&quot;else&quot;] = expression(10);
        return that;
    }, 30);

    var orPrecendence = 40;
    infix(&quot;||&quot;, function(left, that) {
        increaseComplexityCount();
        that.left = left;
        that.right = expression(orPrecendence);
        return that;
    }, orPrecendence);
    infix(&quot;&amp;&amp;&quot;, &quot;and&quot;, 50);
    bitwise(&quot;|&quot;, &quot;bitor&quot;, 70);
    bitwise(&quot;^&quot;, &quot;bitxor&quot;, 80);
    bitwise(&quot;&amp;&quot;, &quot;bitand&quot;, 90);
    relation(&quot;==&quot;, function(left, right) {
        var eqnull = state.option.eqnull &amp;&amp;
            ((left &amp;&amp; left.value) === &quot;null&quot; || (right &amp;&amp; right.value) === &quot;null&quot;);

        switch (true) {
            case !eqnull &amp;&amp; state.option.eqeqeq:
                this.from = this.character;
                warning(&quot;W116&quot;, this, &quot;===&quot;, &quot;==&quot;);
                break;
            case isPoorRelation(left):
                warning(&quot;W041&quot;, this, &quot;===&quot;, left.value);
                break;
            case isPoorRelation(right):
                warning(&quot;W041&quot;, this, &quot;===&quot;, right.value);
                break;
            case isTypoTypeof(right, left, state):
                warning(&quot;W122&quot;, this, right.value);
                break;
            case isTypoTypeof(left, right, state):
                warning(&quot;W122&quot;, this, left.value);
                break;
        }

        return this;
    });
    relation(&quot;===&quot;, function(left, right) {
        if (isTypoTypeof(right, left, state)) {
            warning(&quot;W122&quot;, this, right.value);
        } else if (isTypoTypeof(left, right, state)) {
            warning(&quot;W122&quot;, this, left.value);
        }
        return this;
    });
    relation(&quot;!=&quot;, function(left, right) {
        var eqnull = state.option.eqnull &amp;&amp;
            ((left &amp;&amp; left.value) === &quot;null&quot; || (right &amp;&amp; right.value) === &quot;null&quot;);

        if (!eqnull &amp;&amp; state.option.eqeqeq) {
            this.from = this.character;
            warning(&quot;W116&quot;, this, &quot;!==&quot;, &quot;!=&quot;);
        } else if (isPoorRelation(left)) {
            warning(&quot;W041&quot;, this, &quot;!==&quot;, left.value);
        } else if (isPoorRelation(right)) {
            warning(&quot;W041&quot;, this, &quot;!==&quot;, right.value);
        } else if (isTypoTypeof(right, left, state)) {
            warning(&quot;W122&quot;, this, right.value);
        } else if (isTypoTypeof(left, right, state)) {
            warning(&quot;W122&quot;, this, left.value);
        }
        return this;
    });
    relation(&quot;!==&quot;, function(left, right) {
        if (isTypoTypeof(right, left, state)) {
            warning(&quot;W122&quot;, this, right.value);
        } else if (isTypoTypeof(left, right, state)) {
            warning(&quot;W122&quot;, this, left.value);
        }
        return this;
    });
    relation(&quot;&lt;&quot;);
    relation(&quot;&gt;&quot;);
    relation(&quot;&lt;=&quot;);
    relation(&quot;&gt;=&quot;);
    bitwise(&quot;&lt;&lt;&quot;, &quot;shiftleft&quot;, 120);
    bitwise(&quot;&gt;&gt;&quot;, &quot;shiftright&quot;, 120);
    bitwise(&quot;&gt;&gt;&gt;&quot;, &quot;shiftrightunsigned&quot;, 120);
    infix(&quot;in&quot;, &quot;in&quot;, 120);
    infix(&quot;instanceof&quot;, &quot;instanceof&quot;, 120);
    infix(&quot;+&quot;, function(left, that) {
        var right;
        that.left = left;
        that.right = right = expression(130);

        if (left &amp;&amp; right &amp;&amp; left.id === &quot;(string)&quot; &amp;&amp; right.id === &quot;(string)&quot;) {
            left.value += right.value;
            left.character = right.character;
            if (!state.option.scripturl &amp;&amp; javascriptURL.test(left.value)) {
                warning(&quot;W050&quot;, left);
            }
            return left;
        }

        return that;
    }, 130);
    prefix(&quot;+&quot;, &quot;num&quot;);
    prefix(&quot;+++&quot;, function() {
        warning(&quot;W007&quot;);
        this.arity = &quot;unary&quot;;
        this.right = expression(150);
        return this;
    });
    infix(&quot;+++&quot;, function(left) {
        warning(&quot;W007&quot;);
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix(&quot;-&quot;, &quot;sub&quot;, 130);
    prefix(&quot;-&quot;, &quot;neg&quot;);
    prefix(&quot;---&quot;, function() {
        warning(&quot;W006&quot;);
        this.arity = &quot;unary&quot;;
        this.right = expression(150);
        return this;
    });
    infix(&quot;---&quot;, function(left) {
        warning(&quot;W006&quot;);
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix(&quot;*&quot;, &quot;mult&quot;, 140);
    infix(&quot;/&quot;, &quot;div&quot;, 140);
    infix(&quot;%&quot;, &quot;mod&quot;, 140);

    suffix(&quot;++&quot;);
    prefix(&quot;++&quot;, &quot;preinc&quot;);
    state.syntax[&quot;++&quot;].exps = true;

    suffix(&quot;--&quot;);
    prefix(&quot;--&quot;, &quot;predec&quot;);
    state.syntax[&quot;--&quot;].exps = true;
    prefix(&quot;delete&quot;, function() {
        var p = expression(10);
        if (!p) {
            return this;
        }

        if (p.id !== &quot;.&quot; &amp;&amp; p.id !== &quot;[&quot;) {
            warning(&quot;W051&quot;);
        }
        this.first = p;

        // The &#x60;delete&#x60; operator accepts unresolvable references when not in strict
        // mode, so the operand may be undefined.
        if (p.identifier &amp;&amp; !state.isStrict()) {
            p.forgiveUndef = true;
        }
        return this;
    }).exps = true;

    prefix(&quot;~&quot;, function() {
        if (state.option.bitwise) {
            warning(&quot;W016&quot;, this, &quot;~&quot;);
        }
        this.arity = &quot;unary&quot;;
        this.right = expression(150);
        return this;
    });

    prefix(&quot;...&quot;, function() {
        if (!state.inES6(true)) {
            warning(&quot;W119&quot;, this, &quot;spread/rest operator&quot;, &quot;6&quot;);
        }

        // TODO: Allow all AssignmentExpression
        // once parsing permits.
        //
        // How to handle eg. number, boolean when the built-in
        // prototype of may have an @@iterator definition?
        //
        // Number.prototype[Symbol.iterator] = function * () {
        //   yield this.valueOf();
        // };
        //
        // var a = [ ...1 ];
        // console.log(a); // [1];
        //
        // for (let n of [...10]) {
        //    console.log(n);
        // }
        // // 10
        //
        //
        // Boolean.prototype[Symbol.iterator] = function * () {
        //   yield this.valueOf();
        // };
        //
        // var a = [ ...true ];
        // console.log(a); // [true];
        //
        // for (let n of [...false]) {
        //    console.log(n);
        // }
        // // false
        //
        if (!state.tokens.next.identifier &amp;&amp;
            state.tokens.next.type !== &quot;(string)&quot; &amp;&amp;
            !checkPunctuators(state.tokens.next, [&quot;[&quot;, &quot;(&quot;])) {

            error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
        }
        expression(150);
        return this;
    });

    prefix(&quot;!&quot;, function() {
        this.arity = &quot;unary&quot;;
        this.right = expression(150);

        if (!this.right) { // &#x27;!&#x27; followed by nothing? Give up.
            quit(&quot;E041&quot;, this);
        }

        if (bang[this.right.id] === true) {
            warning(&quot;W018&quot;, this, &quot;!&quot;);
        }
        return this;
    });

    prefix(&quot;typeof&quot;, (function() {
        var p = expression(150);
        this.first = this.right = p;

        if (!p) { // &#x27;typeof&#x27; followed by nothing? Give up.
            quit(&quot;E041&quot;, this);
        }

        // The &#x60;typeof&#x60; operator accepts unresolvable references, so the operand
        // may be undefined.
        if (p.identifier) {
            p.forgiveUndef = true;
        }
        return this;
    }));
    prefix(&quot;new&quot;, function() {
        var mp = metaProperty(&quot;target&quot;, function() {
            if (!state.inES6(true)) {
                warning(&quot;W119&quot;, state.tokens.prev, &quot;new.target&quot;, &quot;6&quot;);
            }
            var inFunction, c = state.funct;
            while (c) {
                inFunction = !c[&quot;(global)&quot;];
                if (!c[&quot;(arrow)&quot;]) { break; }
                c = c[&quot;(context)&quot;];
            }
            if (!inFunction) {
                warning(&quot;W136&quot;, state.tokens.prev, &quot;new.target&quot;);
            }
        });
        if (mp) { return mp; }

        var c = expression(155), i;
        if (c &amp;&amp; c.id !== &quot;function&quot;) {
            if (c.identifier) {
                c[&quot;new&quot;] = true;
                switch (c.value) {
                    case &quot;Number&quot;:
                    case &quot;String&quot;:
                    case &quot;Boolean&quot;:
                    case &quot;Math&quot;:
                    case &quot;JSON&quot;:
                        warning(&quot;W053&quot;, state.tokens.prev, c.value);
                        break;
                    case &quot;Symbol&quot;:
                        if (state.inES6()) {
                            warning(&quot;W053&quot;, state.tokens.prev, c.value);
                        }
                        break;
                    case &quot;Function&quot;:
                        if (!state.option.evil) {
                            warning(&quot;W054&quot;);
                        }
                        break;
                    case &quot;Date&quot;:
                    case &quot;RegExp&quot;:
                    case &quot;this&quot;:
                        break;
                    default:
                        if (c.id !== &quot;function&quot;) {
                            i = c.value.substr(0, 1);
                            if (state.option.newcap &amp;&amp; (i &lt; &quot;A&quot; || i &gt; &quot;Z&quot;) &amp;&amp;
                                !state.funct[&quot;(scope)&quot;].isPredefined(c.value)) {
                                warning(&quot;W055&quot;, state.tokens.curr);
                            }
                        }
                }
            } else {
                if (c.id !== &quot;.&quot; &amp;&amp; c.id !== &quot;[&quot; &amp;&amp; c.id !== &quot;(&quot;) {
                    warning(&quot;W056&quot;, state.tokens.curr);
                }
            }
        } else {
            if (!state.option.supernew)
                warning(&quot;W057&quot;, this);
        }
        if (state.tokens.next.id !== &quot;(&quot; &amp;&amp; !state.option.supernew) {
            warning(&quot;W058&quot;, state.tokens.curr, state.tokens.curr.value);
        }
        this.first = this.right = c;
        return this;
    });
    state.syntax[&quot;new&quot;].exps = true;

    prefix(&quot;void&quot;).exps = true;

    infix(&quot;.&quot;, function(left, that) {
        var m = identifier(false, true);

        if (typeof m === &quot;string&quot;) {
            countMember(m);
        }

        that.left = left;
        that.right = m;

        if (m &amp;&amp; m === &quot;hasOwnProperty&quot; &amp;&amp; state.tokens.next.value === &quot;=&quot;) {
            warning(&quot;W001&quot;);
        }

        if (left &amp;&amp; left.value === &quot;arguments&quot; &amp;&amp; (m === &quot;callee&quot; || m === &quot;caller&quot;)) {
            if (state.option.noarg)
                warning(&quot;W059&quot;, left, m);
            else if (state.isStrict())
                error(&quot;E008&quot;);
        } else if (!state.option.evil &amp;&amp; left &amp;&amp; left.value === &quot;document&quot; &amp;&amp;
            (m === &quot;write&quot; || m === &quot;writeln&quot;)) {
            warning(&quot;W060&quot;, left);
        }

        if (!state.option.evil &amp;&amp; (m === &quot;eval&quot; || m === &quot;execScript&quot;)) {
            if (isGlobalEval(left, state)) {
                warning(&quot;W061&quot;);
            }
        }

        return that;
    }, 160, true);

    infix(&quot;(&quot;, function(left, that) {
        if (state.option.immed &amp;&amp; left &amp;&amp; !left.immed &amp;&amp; left.id === &quot;function&quot;) {
            warning(&quot;W062&quot;);
        }

        var n = 0;
        var p = [];

        if (left) {
            if (left.type === &quot;(identifier)&quot;) {
                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                    if (&quot;Array Number String Boolean Date Object Error Symbol&quot;.indexOf(left.value) === -1) {
                        if (left.value === &quot;Math&quot;) {
                            warning(&quot;W063&quot;, left);
                        } else if (state.option.newcap) {
                            warning(&quot;W064&quot;, left);
                        }
                    }
                }
            }
        }

        if (state.tokens.next.id !== &quot;)&quot;) {
            for (; ;) {
                p[p.length] = expression(10);
                n += 1;
                if (state.tokens.next.id !== &quot;,&quot;) {
                    break;
                }
                comma();
            }
        }

        advance(&quot;)&quot;);

        if (typeof left === &quot;object&quot;) {
            if (!state.inES5() &amp;&amp; left.value === &quot;parseInt&quot; &amp;&amp; n === 1) {
                warning(&quot;W065&quot;, state.tokens.curr);
            }
            if (!state.option.evil) {
                if (left.value === &quot;eval&quot; || left.value === &quot;Function&quot; ||
                    left.value === &quot;execScript&quot;) {
                    warning(&quot;W061&quot;, left);

                    if (p[0] &amp;&amp; p[0].id === &quot;(string)&quot;) {
                        addInternalSrc(left, p[0].value);
                    }
                } else if (p[0] &amp;&amp; p[0].id === &quot;(string)&quot; &amp;&amp;
                    (left.value === &quot;setTimeout&quot; ||
                        left.value === &quot;setInterval&quot;)) {
                    warning(&quot;W066&quot;, left);
                    addInternalSrc(left, p[0].value);

                    // window.setTimeout/setInterval
                } else if (p[0] &amp;&amp; p[0].id === &quot;(string)&quot; &amp;&amp;
                    left.value === &quot;.&quot; &amp;&amp;
                    left.left.value === &quot;window&quot; &amp;&amp;
                    (left.right === &quot;setTimeout&quot; ||
                        left.right === &quot;setInterval&quot;)) {
                    warning(&quot;W066&quot;, left);
                    addInternalSrc(left, p[0].value);
                }
            }
            if (!left.identifier &amp;&amp; left.id !== &quot;.&quot; &amp;&amp; left.id !== &quot;[&quot; &amp;&amp; left.id !== &quot;=&gt;&quot; &amp;&amp;
                left.id !== &quot;(&quot; &amp;&amp; left.id !== &quot;&amp;&amp;&quot; &amp;&amp; left.id !== &quot;||&quot; &amp;&amp; left.id !== &quot;?&quot; &amp;&amp;
                !(state.inES6() &amp;&amp; left[&quot;(name)&quot;])) {
                warning(&quot;W067&quot;, that);
            }
        }

        that.left = left;
        return that;
    }, 155, true).exps = true;

    prefix(&quot;(&quot;, function() {
        var pn = state.tokens.next, pn1, i = -1;
        var ret, triggerFnExpr, first, last;
        var parens = 1;
        var opening = state.tokens.curr;
        var preceeding = state.tokens.prev;
        var isNecessary = !state.option.singleGroups;

        do {
            if (pn.value === &quot;(&quot;) {
                parens += 1;
            } else if (pn.value === &quot;)&quot;) {
                parens -= 1;
            }

            i += 1;
            pn1 = pn;
            pn = peek(i);
        } while (!(parens === 0 &amp;&amp; pn1.value === &quot;)&quot;) &amp;&amp; pn.value !== &quot;;&quot; &amp;&amp; pn.type !== &quot;(end)&quot;);

        if (state.tokens.next.id === &quot;function&quot;) {
            triggerFnExpr = state.tokens.next.immed = true;
        }

        // If the balanced grouping operator is followed by a &quot;fat arrow&quot;, the
        // current token marks the beginning of a &quot;fat arrow&quot; function and parsing
        // should proceed accordingly.
        if (pn.value === &quot;=&gt;&quot;) {
            return doFunction({ type: &quot;arrow&quot;, parsedOpening: true });
        }

        var exprs = [];

        if (state.tokens.next.id !== &quot;)&quot;) {
            for (; ;) {
                exprs.push(expression(10));

                if (state.tokens.next.id !== &quot;,&quot;) {
                    break;
                }

                if (state.option.nocomma) {
                    warning(&quot;W127&quot;);
                }

                comma();
            }
        }

        advance(&quot;)&quot;, this);
        if (state.option.immed &amp;&amp; exprs[0] &amp;&amp; exprs[0].id === &quot;function&quot;) {
            if (state.tokens.next.id !== &quot;(&quot; &amp;&amp;
                state.tokens.next.id !== &quot;.&quot; &amp;&amp; state.tokens.next.id !== &quot;[&quot;) {
                warning(&quot;W068&quot;, this);
            }
        }

        if (!exprs.length) {
            return;
        }
        if (exprs.length &gt; 1) {
            ret = Object.create(state.syntax[&quot;,&quot;]);
            ret.exprs = exprs;

            first = exprs[0];
            last = exprs[exprs.length - 1];

            if (!isNecessary) {
                isNecessary = preceeding.assign || preceeding.delim;
            }
        } else {
            ret = first = last = exprs[0];

            if (!isNecessary) {
                isNecessary =
                    // Used to distinguish from an ExpressionStatement which may not
                    // begin with the &#x60;{&#x60; and &#x60;function&#x60; tokens
                    (opening.beginsStmt &amp;&amp; (ret.id === &quot;{&quot; || triggerFnExpr || isFunctor(ret))) ||
                    // Used to signal that a function expression is being supplied to
                    // some other operator.
                    (triggerFnExpr &amp;&amp;
                        // For parenthesis wrapping a function expression to be considered
                        // necessary, the grouping operator should be the left-hand-side of
                        // some other operator--either within the parenthesis or directly
                        // following them.
                        (!isEndOfExpr() || state.tokens.prev.id !== &quot;}&quot;)) ||
                    // Used to demarcate an arrow function as the left-hand side of some
                    // operator.
                    (isFunctor(ret) &amp;&amp; !isEndOfExpr()) ||
                    // Used as the return value of a single-statement arrow function
                    (ret.id === &quot;{&quot; &amp;&amp; preceeding.id === &quot;=&gt;&quot;) ||
                    // Used to delineate an integer number literal from a dereferencing
                    // punctuator (otherwise interpreted as a decimal point)
                    (ret.type === &quot;(number)&quot; &amp;&amp;
                        checkPunctuator(pn, &quot;.&quot;) &amp;&amp; /^\d+$/.test(ret.value));
            }
        }

        if (ret) {
            // The operator may be necessary to override the default binding power of
            // neighboring operators (whenever there is an operator in use within the
            // first expression *or* the current group contains multiple expressions)
            if (!isNecessary &amp;&amp; (first.left || first.right || ret.exprs)) {
                isNecessary =
                    (!isBeginOfExpr(preceeding) &amp;&amp; first.lbp &lt;= preceeding.lbp) ||
                    (!isEndOfExpr() &amp;&amp; last.lbp &lt; state.tokens.next.lbp);
            }

            if (!isNecessary) {
                warning(&quot;W126&quot;, opening);
            }

            ret.paren = true;
        }

        return ret;
    });

    application(&quot;=&gt;&quot;);

    infix(&quot;[&quot;, function(left, that) {
        var e = expression(10), s;
        if (e &amp;&amp; e.type === &quot;(string)&quot;) {
            if (!state.option.evil &amp;&amp; (e.value === &quot;eval&quot; || e.value === &quot;execScript&quot;)) {
                if (isGlobalEval(left, state)) {
                    warning(&quot;W061&quot;);
                }
            }

            countMember(e.value);
            if (!state.option.sub &amp;&amp; identifierRegExp.test(e.value)) {
                s = state.syntax[e.value];
                if (!s || !isReserved(s)) {
                    warning(&quot;W069&quot;, state.tokens.prev, e.value);
                }
            }
        }
        advance(&quot;]&quot;, that);

        if (e &amp;&amp; e.value === &quot;hasOwnProperty&quot; &amp;&amp; state.tokens.next.value === &quot;=&quot;) {
            warning(&quot;W001&quot;);
        }

        that.left = left;
        that.right = e;
        return that;
    }, 160, true);

    function comprehensiveArrayExpression() {
        var res: { exps?; filter?; left?; right?} = {};
        res.exps = true;
        state.funct[&quot;(comparray)&quot;].stack();

        // Handle reversed for expressions, used in spidermonkey
        var reversed = false;
        if (state.tokens.next.value !== &quot;for&quot;) {
            reversed = true;
            if (!state.inMoz()) {
                warning(&quot;W116&quot;, state.tokens.next, &quot;for&quot;, state.tokens.next.value);
            }
            state.funct[&quot;(comparray)&quot;].setState(&quot;use&quot;);
            res.right = expression(10);
        }

        advance(&quot;for&quot;);
        if (state.tokens.next.value === &quot;each&quot;) {
            advance(&quot;each&quot;);
            if (!state.inMoz()) {
                warning(&quot;W118&quot;, state.tokens.curr, &quot;for each&quot;);
            }
        }
        advance(&quot;(&quot;);
        state.funct[&quot;(comparray)&quot;].setState(&quot;define&quot;);
        res.left = expression(130);
        if (contains([&quot;in&quot;, &quot;of&quot;], state.tokens.next.value)) {
            advance();
        } else {
            error(&quot;E045&quot;, state.tokens.curr);
        }
        state.funct[&quot;(comparray)&quot;].setState(&quot;generate&quot;);
        expression(10);

        advance(&quot;)&quot;);
        if (state.tokens.next.value === &quot;if&quot;) {
            advance(&quot;if&quot;);
            advance(&quot;(&quot;);
            state.funct[&quot;(comparray)&quot;].setState(&quot;filter&quot;);
            res.filter = expression(10);
            advance(&quot;)&quot;);
        }

        if (!reversed) {
            state.funct[&quot;(comparray)&quot;].setState(&quot;use&quot;);
            res.right = expression(10);
        }

        advance(&quot;]&quot;);
        state.funct[&quot;(comparray)&quot;].unstack();
        return res;
    }

    prefix(&quot;[&quot;, function() {
        var blocktype = lookupBlockType();
        if (blocktype.isCompArray) {
            if (!state.option.esnext &amp;&amp; !state.inMoz()) {
                warning(&quot;W118&quot;, state.tokens.curr, &quot;array comprehension&quot;);
            }
            return comprehensiveArrayExpression();
        } else if (blocktype.isDestAssign) {
            this.destructAssign = destructuringPattern({ openingParsed: true, assignment: true });
            return this;
        }
        var b = state.tokens.curr.line !== startLine(state.tokens.next);
        this.first = [];
        if (b) {
            indent += state.option.indent;
            if (state.tokens.next.from === indent + state.option.indent) {
                indent += state.option.indent;
            }
        }
        while (state.tokens.next.id !== &quot;(end)&quot;) {
            while (state.tokens.next.id === &quot;,&quot;) {
                if (!state.option.elision) {
                    if (!state.inES5()) {
                        // Maintain compat with old options --- ES5 mode without
                        // elision=true will warn once per comma
                        warning(&quot;W070&quot;);
                    } else {
                        warning(&quot;W128&quot;);
                        do {
                            advance(&quot;,&quot;);
                        } while (state.tokens.next.id === &quot;,&quot;);
                        continue;
                    }
                }
                advance(&quot;,&quot;);
            }

            if (state.tokens.next.id === &quot;]&quot;) {
                break;
            }

            this.first.push(expression(10));
            if (state.tokens.next.id === &quot;,&quot;) {
                comma({ allowTrailing: true });
                if (state.tokens.next.id === &quot;]&quot; &amp;&amp; !state.inES5()) {
                    warning(&quot;W070&quot;, state.tokens.curr);
                    break;
                }
            } else {
                break;
            }
        }
        if (b) {
            indent -= state.option.indent;
        }
        advance(&quot;]&quot;, this);
        return this;
    });


    function isMethod() {
        return state.funct[&quot;(statement)&quot;] &amp;&amp; state.funct[&quot;(statement)&quot;].type === &quot;class&quot; ||
            state.funct[&quot;(context)&quot;] &amp;&amp; state.funct[&quot;(context)&quot;][&quot;(verb)&quot;] === &quot;class&quot;;
    }


    function isPropertyName(token) {
        return token.identifier || token.id === &quot;(string)&quot; || token.id === &quot;(number)&quot;;
    }


    function propertyName(preserveOrToken?) {
        var id;
        var preserve = true;
        if (typeof preserveOrToken === &quot;object&quot;) {
            id = preserveOrToken;
        } else {
            preserve = preserveOrToken;
            id = optionalidentifier(false, true, preserve);
        }

        if (!id) {
            if (state.tokens.next.id === &quot;(string)&quot;) {
                id = state.tokens.next.value;
                if (!preserve) {
                    advance();
                }
            } else if (state.tokens.next.id === &quot;(number)&quot;) {
                id = state.tokens.next.value.toString();
                if (!preserve) {
                    advance();
                }
            }
        } else if (typeof id === &quot;object&quot;) {
            if (id.id === &quot;(string)&quot; || id.id === &quot;(identifier)&quot;) id = id.value;
            else if (id.id === &quot;(number)&quot;) id = id.value.toString();
        }

        if (id === &quot;hasOwnProperty&quot;) {
            warning(&quot;W001&quot;);
        }

        return id;
    }

    /**
     * @param {Object} [options]
     * @param {token} [options.loneArg] The argument to the function in cases
     *                                  where it was defined using the
     *                                  single-argument shorthand.
     * @param {bool} [options.parsedOpening] Whether the opening parenthesis has
     *                                       already been parsed.
     * @returns {{ arity: number, params: Array.&lt;string&gt;}}
     */
    function functionparams(options) {
        var next;
        var paramsIds = [];
        var ident;
        var tokens = [];
        var t;
        var pastDefault = false;
        var pastRest = false;
        var arity = 0;
        var loneArg = options &amp;&amp; options.loneArg;

        if (loneArg &amp;&amp; loneArg.identifier === true) {
            state.funct[&quot;(scope)&quot;].addParam(loneArg.value, loneArg);
            return { arity: 1, params: [loneArg.value] };
        }

        next = state.tokens.next;

        if (!options || !options.parsedOpening) {
            advance(&quot;(&quot;);
        }

        if (state.tokens.next.id === &quot;)&quot;) {
            advance(&quot;)&quot;);
            return;
        }

        function addParam(addParamArgs) {
            state.funct[&quot;(scope)&quot;].addParam.apply(state.funct[&quot;(scope)&quot;], addParamArgs);
        }

        for (; ;) {
            arity++;
            // are added to the param scope
            var currentParams = [];

            if (contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.id)) {
                tokens = destructuringPattern();
                for (t in tokens) {
                    t = tokens[t];
                    if (t.id) {
                        paramsIds.push(t.id);
                        currentParams.push([t.id, t.token]);
                    }
                }
            } else {
                if (checkPunctuator(state.tokens.next, &quot;...&quot;)) pastRest = true;
                ident = identifier(true);
                if (ident) {
                    paramsIds.push(ident);
                    currentParams.push([ident, state.tokens.curr]);
                } else {
                    // Skip invalid parameter.
                    while (!checkPunctuators(state.tokens.next, [&quot;,&quot;, &quot;)&quot;])) advance();
                }
            }

            // It is valid to have a regular argument after a default argument
            // since undefined can be used for missing parameters. Still warn as it is
            // a possible code smell.
            if (pastDefault) {
                if (state.tokens.next.id !== &quot;=&quot;) {
                    error(&quot;W138&quot;, state.tokens.curr);
                }
            }
            if (state.tokens.next.id === &quot;=&quot;) {
                if (!state.inES6()) {
                    warning(&quot;W119&quot;, state.tokens.next, &quot;default parameters&quot;, &quot;6&quot;);
                }
                advance(&quot;=&quot;);
                pastDefault = true;
                expression(10);
            }

            // now we have evaluated the default expression, add the variable to the param scope
            currentParams.forEach(addParam);

            if (state.tokens.next.id === &quot;,&quot;) {
                if (pastRest) {
                    warning(&quot;W131&quot;, state.tokens.next);
                }
                comma();
            } else {
                advance(&quot;)&quot;, next);
                return { arity: arity, params: paramsIds };
            }
        }
    }

    function functor(name, token, overwrites) {
        var funct = {
            &quot;(name)&quot;: name,
            &quot;(breakage)&quot;: 0,
            &quot;(loopage)&quot;: 0,
            &quot;(tokens)&quot;: {},
            &quot;(properties)&quot;: {},

            &quot;(catch)&quot;: false,
            &quot;(global)&quot;: false,

            &quot;(line)&quot;: null,
            &quot;(character)&quot;: null,
            &quot;(metrics)&quot;: null,
            &quot;(statement)&quot;: null,
            &quot;(context)&quot;: null,
            &quot;(scope)&quot;: null,
            &quot;(comparray)&quot;: null,
            &quot;(generator)&quot;: null,
            &quot;(arrow)&quot;: null,
            &quot;(params)&quot;: null
        };

        if (token) {
            extend(funct, {
                &quot;(line)&quot;: token.line,
                &quot;(character)&quot;: token.character,
                &quot;(metrics)&quot;: createMetrics(token)
            });
        }

        extend(funct, overwrites);

        if (funct[&quot;(context)&quot;]) {
            funct[&quot;(scope)&quot;] = funct[&quot;(context)&quot;][&quot;(scope)&quot;];
            funct[&quot;(comparray)&quot;] = funct[&quot;(context)&quot;][&quot;(comparray)&quot;];
        }

        return funct;
    }

    function isFunctor(token) {
        return &quot;(scope)&quot; in token;
    }

    /**
     * Determine if the parser has begun parsing executable code.
     *
     * @param {Token} funct - The current &quot;functor&quot; token
     *
     * @returns {boolean}
     */
    function hasParsedCode(funct) {
        return funct[&quot;(global)&quot;] &amp;&amp; !funct[&quot;(verb)&quot;];
    }

    function doTemplateLiteral(left) {
        // ASSERT: this.type === &quot;(template)&quot;
        // jshint validthis: true
        var ctx = this.context;
        var noSubst = this.noSubst;
        var depth = this.depth;

        if (!noSubst) {
            while (!end()) {
                if (!state.tokens.next.template || state.tokens.next.depth &gt; depth) {
                    expression(0); // should probably have different rbp?
                } else {
                    // skip template start / middle
                    advance();
                }
            }
        }

        return {
            id: &quot;(template)&quot;,
            type: &quot;(template)&quot;,
            tag: left
        };

        function end() {
            if (state.tokens.curr.template &amp;&amp; state.tokens.curr.tail &amp;&amp;
                state.tokens.curr.context === ctx) return true;
            var complete = (state.tokens.next.template &amp;&amp; state.tokens.next.tail &amp;&amp;
                state.tokens.next.context === ctx);
            if (complete) advance();
            return complete || state.tokens.next.isUnclosed;
        }
    }

    /**
     * @param {Object} [options]
     * @param {token} [options.name] The identifier belonging to the function (if
     *                               any)
     * @param {boolean} [options.statement] The statement that triggered creation
     *                                      of the current function.
     * @param {string} [options.type] If specified, either &quot;generator&quot; or &quot;arrow&quot;
     * @param {token} [options.loneArg] The argument to the function in cases
     *                                  where it was defined using the
     *                                  single-argument shorthand
     * @param {bool} [options.parsedOpening] Whether the opening parenthesis has
     *                                       already been parsed
     * @param {token} [options.classExprBinding] Define a function with this
     *                                           identifier in the new function&#x27;s
     *                                           scope, mimicking the bahavior of
     *                                           class expression names within
     *                                           the body of member functions.
     */
    function doFunction(options?: { name?; statement?; type?; loneArg?; parsedOpening?; classExprBinding?; ignoreLoopFunc?}) {
        var f, token, name, statement, classExprBinding, isGenerator, isArrow, ignoreLoopFunc;
        var oldOption = state.option;
        var oldIgnored = state.ignored;

        if (options) {
            name = options.name;
            statement = options.statement;
            classExprBinding = options.classExprBinding;
            isGenerator = options.type === &quot;generator&quot;;
            isArrow = options.type === &quot;arrow&quot;;
            ignoreLoopFunc = options.ignoreLoopFunc;
        }

        state.option = Object.create(state.option);
        state.ignored = Object.create(state.ignored);

        state.funct = functor(name || state.nameStack.infer(), state.tokens.next, {
            &quot;(statement)&quot;: statement,
            &quot;(context)&quot;: state.funct,
            &quot;(arrow)&quot;: isArrow,
            &quot;(generator)&quot;: isGenerator
        });

        f = state.funct;
        token = state.tokens.curr;
        token.funct = state.funct;

        functions.push(state.funct);

        // So that the function is available to itself and referencing itself is not
        // seen as a closure, add the function name to a new scope, but do not
        // test for unused (unused: false)
        // it is a new block scope so that params can override it, it can be block scoped
        // but declarations inside the function don&#x27;t cause already declared error
        state.funct[&quot;(scope)&quot;].stack(&quot;functionouter&quot;);
        var internallyAccessibleName = name || classExprBinding;
        if (internallyAccessibleName) {
            state.funct[&quot;(scope)&quot;].block.add(internallyAccessibleName,
                classExprBinding ? &quot;class&quot; : &quot;function&quot;, state.tokens.curr, false);
        }

        // create the param scope (params added in functionparams)
        state.funct[&quot;(scope)&quot;].stack(&quot;functionparams&quot;);

        var paramsInfo = functionparams(options);

        if (paramsInfo) {
            state.funct[&quot;(params)&quot;] = paramsInfo.params;
            state.funct[&quot;(metrics)&quot;].arity = paramsInfo.arity;
            state.funct[&quot;(metrics)&quot;].verifyMaxParametersPerFunction();
        } else {
            state.funct[&quot;(metrics)&quot;].arity = 0;
        }

        if (isArrow) {
            if (!state.inES6(true)) {
                warning(&quot;W119&quot;, state.tokens.curr, &quot;arrow function syntax (=&gt;)&quot;, &quot;6&quot;);
            }

            if (!options.loneArg) {
                advance(&quot;=&gt;&quot;);
            }
        }

        block(false, true, true, isArrow);

        if (!state.option.noyield &amp;&amp; isGenerator &amp;&amp;
            state.funct[&quot;(generator)&quot;] !== &quot;yielded&quot;) {
            warning(&quot;W124&quot;, state.tokens.curr);
        }

        state.funct[&quot;(metrics)&quot;].verifyMaxStatementsPerFunction();
        state.funct[&quot;(metrics)&quot;].verifyMaxComplexityPerFunction();
        state.funct[&quot;(unusedOption)&quot;] = state.option.unused;
        state.option = oldOption;
        state.ignored = oldIgnored;
        state.funct[&quot;(last)&quot;] = state.tokens.curr.line;
        state.funct[&quot;(lastcharacter)&quot;] = state.tokens.curr.character;

        // unstack the params scope
        state.funct[&quot;(scope)&quot;].unstack(); // also does usage and label checks

        // unstack the function outer stack
        state.funct[&quot;(scope)&quot;].unstack();

        state.funct = state.funct[&quot;(context)&quot;];

        if (!ignoreLoopFunc &amp;&amp; !state.option.loopfunc &amp;&amp; state.funct[&quot;(loopage)&quot;]) {
            // If the function we just parsed accesses any non-local variables
            // trigger a warning. Otherwise, the function is safe even within
            // a loop.
            if (f[&quot;(isCapturing)&quot;]) {
                warning(&quot;W083&quot;, token);
            }
        }

        return f;
    }

    function createMetrics(functionStartToken) {
        return {
            statementCount: 0,
            nestedBlockDepth: -1,
            ComplexityCount: 1,
            arity: 0,

            verifyMaxStatementsPerFunction: function() {
                if (state.option.maxstatements &amp;&amp;
                    this.statementCount &gt; state.option.maxstatements) {
                    warning(&quot;W071&quot;, functionStartToken, this.statementCount);
                }
            },

            verifyMaxParametersPerFunction: function() {
                if (isNumber(state.option.maxparams) &amp;&amp;
                    this.arity &gt; state.option.maxparams) {
                    warning(&quot;W072&quot;, functionStartToken, this.arity);
                }
            },

            verifyMaxNestedBlockDepthPerFunction: function() {
                if (state.option.maxdepth &amp;&amp;
                    this.nestedBlockDepth &gt; 0 &amp;&amp;
                    this.nestedBlockDepth === state.option.maxdepth + 1) {
                    warning(&quot;W073&quot;, null, this.nestedBlockDepth);
                }
            },

            verifyMaxComplexityPerFunction: function() {
                var max = state.option.maxcomplexity;
                var cc = this.ComplexityCount;
                if (max &amp;&amp; cc &gt; max) {
                    warning(&quot;W074&quot;, functionStartToken, cc);
                }
            }
        };
    }

    function increaseComplexityCount() {
        state.funct[&quot;(metrics)&quot;].ComplexityCount += 1;
    }

    // Parse assignments that were found instead of conditionals.
    // For example: if (a = 1) { ... }

    function checkCondAssignment(expr) {
        var id, paren;
        if (expr) {
            id = expr.id;
            paren = expr.paren;
            if (id === &quot;,&quot; &amp;&amp; (expr = expr.exprs[expr.exprs.length - 1])) {
                id = expr.id;
                paren = paren || expr.paren;
            }
        }
        switch (id) {
            case &quot;=&quot;:
            case &quot;+=&quot;:
            case &quot;-=&quot;:
            case &quot;*=&quot;:
            case &quot;%=&quot;:
            case &quot;&amp;=&quot;:
            case &quot;|=&quot;:
            case &quot;^=&quot;:
            case &quot;/=&quot;:
                if (!paren &amp;&amp; !state.option.boss) {
                    warning(&quot;W084&quot;);
                }
        }
    }

    /**
     * @param {object} props Collection of property descriptors for a given
     *                       object.
     */
    function checkProperties(props) {
        // Check for lonely setters if in the ES5 mode.
        if (state.inES5()) {
            for (var name in props) {
                if (props[name] &amp;&amp; props[name].setterToken &amp;&amp; !props[name].getterToken) {
                    warning(&quot;W078&quot;, props[name].setterToken);
                }
            }
        }
    }

    function metaProperty(name, c) {
        if (checkPunctuator(state.tokens.next, &quot;.&quot;)) {
            var left = state.tokens.curr.id;
            advance(&quot;.&quot;);
            var id = identifier();
            state.tokens.curr.isMetaProperty = true;
            if (name !== id) {
                error(&quot;E057&quot;, state.tokens.prev, left, id);
            } else {
                c();
            }
            return state.tokens.curr;
        }
    }

    (function(x) {
        x.nud = function() {
            var b, f, i, p, t, isGeneratorMethod = false, nextVal;
            var props = Object.create(null); // All properties, including accessors

            b = state.tokens.curr.line !== startLine(state.tokens.next);
            if (b) {
                indent += state.option.indent;
                if (state.tokens.next.from === indent + state.option.indent) {
                    indent += state.option.indent;
                }
            }

            var blocktype = lookupBlockType();
            if (blocktype.isDestAssign) {
                this.destructAssign = destructuringPattern({ openingParsed: true, assignment: true });
                return this;
            }

            for (; ;) {
                if (state.tokens.next.id === &quot;}&quot;) {
                    break;
                }

                nextVal = state.tokens.next.value;
                if (state.tokens.next.identifier &amp;&amp;
                    (peekIgnoreEOL().id === &quot;,&quot; || peekIgnoreEOL().id === &quot;}&quot;)) {
                    if (!state.inES6()) {
                        warning(&quot;W104&quot;, state.tokens.next, &quot;object short notation&quot;, &quot;6&quot;);
                    }
                    i = propertyName(true);
                    saveProperty(props, i, state.tokens.next);

                    expression(10);

                } else if (peek().id !== &quot;:&quot; &amp;&amp; (nextVal === &quot;get&quot; || nextVal === &quot;set&quot;)) {
                    advance(nextVal);

                    if (!state.inES5()) {
                        error(&quot;E034&quot;);
                    }

                    i = propertyName();

                    // ES6 allows for get() {...} and set() {...} method
                    // definition shorthand syntax, so we don&#x27;t produce an error
                    // if linting ECMAScript 6 code.
                    if (!i &amp;&amp; !state.inES6()) {
                        error(&quot;E035&quot;);
                    }

                    // We don&#x27;t want to save this getter unless it&#x27;s an actual getter
                    // and not an ES6 concise method
                    if (i) {
                        saveAccessor(nextVal, props, i, state.tokens.curr);
                    }

                    t = state.tokens.next;
                    f = doFunction();
                    p = f[&quot;(params)&quot;];

                    // Don&#x27;t warn about getter/setter pairs if this is an ES6 concise method
                    if (nextVal === &quot;get&quot; &amp;&amp; i &amp;&amp; p) {
                        warning(&quot;W076&quot;, t, p[0], i);
                    } else if (nextVal === &quot;set&quot; &amp;&amp; i &amp;&amp; (!p || p.length !== 1)) {
                        warning(&quot;W077&quot;, t, i);
                    }
                } else {
                    if (state.tokens.next.value === &quot;*&quot; &amp;&amp; state.tokens.next.type === &quot;(punctuator)&quot;) {
                        if (!state.inES6()) {
                            warning(&quot;W104&quot;, state.tokens.next, &quot;generator functions&quot;, &quot;6&quot;);
                        }
                        advance(&quot;*&quot;);
                        isGeneratorMethod = true;
                    } else {
                        isGeneratorMethod = false;
                    }

                    if (state.tokens.next.id === &quot;[&quot;) {
                        i = computedPropertyName();
                        state.nameStack.set(i);
                    } else {
                        state.nameStack.set(state.tokens.next);
                        i = propertyName();
                        saveProperty(props, i, state.tokens.next);

                        if (typeof i !== &quot;string&quot;) {
                            break;
                        }
                    }

                    if (state.tokens.next.value === &quot;(&quot;) {
                        if (!state.inES6()) {
                            warning(&quot;W104&quot;, state.tokens.curr, &quot;concise methods&quot;, &quot;6&quot;);
                        }
                        doFunction({ type: isGeneratorMethod ? &quot;generator&quot; : null });
                    } else {
                        advance(&quot;:&quot;);
                        expression(10);
                    }
                }

                countMember(i);

                if (state.tokens.next.id === &quot;,&quot;) {
                    comma({ allowTrailing: true, property: true });
                    if (state.tokens.next.id === &quot;,&quot;) {
                        warning(&quot;W070&quot;, state.tokens.curr);
                    } else if (state.tokens.next.id === &quot;}&quot; &amp;&amp; !state.inES5()) {
                        warning(&quot;W070&quot;, state.tokens.curr);
                    }
                } else {
                    break;
                }
            }
            if (b) {
                indent -= state.option.indent;
            }
            advance(&quot;}&quot;, this);

            checkProperties(props);

            return this;
        };
        x.fud = function() {
            error(&quot;E036&quot;, state.tokens.curr);
        };
    } (delim(&quot;{&quot;)));

    function destructuringPattern(options?) {
        var isAssignment = options &amp;&amp; options.assignment;

        if (!state.inES6()) {
            warning(&quot;W104&quot;, state.tokens.curr,
                isAssignment ? &quot;destructuring assignment&quot; : &quot;destructuring binding&quot;, &quot;6&quot;);
        }

        return destructuringPatternRecursive(options);
    }

    function destructuringPatternRecursive(options) {
        var ids;
        var identifiers = [];
        var openingParsed = options &amp;&amp; options.openingParsed;
        var isAssignment = options &amp;&amp; options.assignment;
        var recursiveOptions = isAssignment ? { assignment: isAssignment } : null;
        var firstToken = openingParsed ? state.tokens.curr : state.tokens.next;

        var nextInnerDE = function() {
            var ident;
            if (checkPunctuators(state.tokens.next, [&quot;[&quot;, &quot;{&quot;])) {
                ids = destructuringPatternRecursive(recursiveOptions);
                for (var id in ids) {
                    id = ids[id];
                    identifiers.push({ id: id.id, token: id.token });
                }
            } else if (checkPunctuator(state.tokens.next, &quot;,&quot;)) {
                identifiers.push({ id: null, token: state.tokens.curr });
            } else if (checkPunctuator(state.tokens.next, &quot;(&quot;)) {
                advance(&quot;(&quot;);
                nextInnerDE();
                advance(&quot;)&quot;);
            } else {
                var is_rest = checkPunctuator(state.tokens.next, &quot;...&quot;);

                if (isAssignment) {
                    var identifierToken = is_rest ? peek(0) : state.tokens.next;
                    if (!identifierToken.identifier) {
                        warning(&quot;E030&quot;, identifierToken, identifierToken.value);
                    }
                    var assignTarget = expression(155);
                    if (assignTarget) {
                        checkLeftSideAssign(assignTarget);

                        // if the target was a simple identifier, add it to the list to return
                        if (assignTarget.identifier) {
                            ident = assignTarget.value;
                        }
                    }
                } else {
                    ident = identifier();
                }
                if (ident) {
                    identifiers.push({ id: ident, token: state.tokens.curr });
                }
                return is_rest;
            }
            return false;
        };
        var assignmentProperty = function() {
            var id;
            if (checkPunctuator(state.tokens.next, &quot;[&quot;)) {
                advance(&quot;[&quot;);
                expression(10);
                advance(&quot;]&quot;);
                advance(&quot;:&quot;);
                nextInnerDE();
            } else if (state.tokens.next.id === &quot;(string)&quot; ||
                state.tokens.next.id === &quot;(number)&quot;) {
                advance();
                advance(&quot;:&quot;);
                nextInnerDE();
            } else {
                // this id will either be the property name or the property name and the assigning identifier
                id = identifier();
                if (checkPunctuator(state.tokens.next, &quot;:&quot;)) {
                    advance(&quot;:&quot;);
                    nextInnerDE();
                } else if (id) {
                    // in this case we are assigning (not declaring), so check assignment
                    if (isAssignment) {
                        checkLeftSideAssign(state.tokens.curr);
                    }
                    identifiers.push({ id: id, token: state.tokens.curr });
                }
            }
        };

        var id, value;
        if (checkPunctuator(firstToken, &quot;[&quot;)) {
            if (!openingParsed) {
                advance(&quot;[&quot;);
            }
            if (checkPunctuator(state.tokens.next, &quot;]&quot;)) {
                warning(&quot;W137&quot;, state.tokens.curr);
            }
            var element_after_rest = false;
            while (!checkPunctuator(state.tokens.next, &quot;]&quot;)) {
                if (nextInnerDE() &amp;&amp; !element_after_rest &amp;&amp;
                    checkPunctuator(state.tokens.next, &quot;,&quot;)) {
                    warning(&quot;W130&quot;, state.tokens.next);
                    element_after_rest = true;
                }
                if (checkPunctuator(state.tokens.next, &quot;=&quot;)) {
                    if (checkPunctuator(state.tokens.prev, &quot;...&quot;)) {
                        advance(&quot;]&quot;);
                    } else {
                        advance(&quot;=&quot;);
                    }
                    id = state.tokens.prev;
                    value = expression(10);
                    if (value &amp;&amp; value.type === &quot;undefined&quot;) {
                        warning(&quot;W080&quot;, id, id.value);
                    }
                }
                if (!checkPunctuator(state.tokens.next, &quot;]&quot;)) {
                    advance(&quot;,&quot;);
                }
            }
            advance(&quot;]&quot;);
        } else if (checkPunctuator(firstToken, &quot;{&quot;)) {

            if (!openingParsed) {
                advance(&quot;{&quot;);
            }
            if (checkPunctuator(state.tokens.next, &quot;}&quot;)) {
                warning(&quot;W137&quot;, state.tokens.curr);
            }
            while (!checkPunctuator(state.tokens.next, &quot;}&quot;)) {
                assignmentProperty();
                if (checkPunctuator(state.tokens.next, &quot;=&quot;)) {
                    advance(&quot;=&quot;);
                    id = state.tokens.prev;
                    value = expression(10);
                    if (value &amp;&amp; value.type === &quot;undefined&quot;) {
                        warning(&quot;W080&quot;, id, id.value);
                    }
                }
                if (!checkPunctuator(state.tokens.next, &quot;}&quot;)) {
                    advance(&quot;,&quot;);
                    if (checkPunctuator(state.tokens.next, &quot;}&quot;)) {
                        // Trailing comma
                        // ObjectBindingPattern: { BindingPropertyList , }
                        break;
                    }
                }
            }
            advance(&quot;}&quot;);
        }
        return identifiers;
    }

    function destructuringPatternMatch(tokens: { first }[], value) {
        var first = value.first;

        if (!first)
            return;

        zip(tokens, Array.isArray(first) ? first : [first]).forEach(function(val) {
            var token = val[0];
            var value = val[1];

            if (token &amp;&amp; value)
                token.first = value;
            else if (token &amp;&amp; token.first &amp;&amp; !value)
                warning(&quot;W080&quot;, token.first, token.first.value);
        });
    }

    function blockVariableStatement(type, statement, context) {
        // used for both let and const statements

        var prefix = context &amp;&amp; context.prefix;
        var inexport = context &amp;&amp; context.inexport;
        var isLet = type === &quot;let&quot;;
        var isConst = type === &quot;const&quot;;
        var tokens, lone, value, letblock;

        if (!state.inES6()) {
            warning(&quot;W104&quot;, state.tokens.curr, type, &quot;6&quot;);
        }

        if (isLet &amp;&amp; state.tokens.next.value === &quot;(&quot;) {
            if (!state.inMoz()) {
                warning(&quot;W118&quot;, state.tokens.next, &quot;let block&quot;);
            }
            advance(&quot;(&quot;);
            state.funct[&quot;(scope)&quot;].stack();
            letblock = true;
        } else if (state.funct[&quot;(noblockscopedvar)&quot;]) {
            error(&quot;E048&quot;, state.tokens.curr, isConst ? &quot;Const&quot; : &quot;Let&quot;);
        }

        statement.first = [];
        for (; ;) {
            var names: any[] = [];
            if (contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
                tokens = destructuringPattern();
                lone = false;
            } else {
                tokens = [{ id: identifier(), token: state.tokens.curr }];
                lone = true;
            }

            if (!prefix &amp;&amp; isConst &amp;&amp; state.tokens.next.id !== &quot;=&quot;) {
                warning(&quot;E012&quot;, state.tokens.curr, state.tokens.curr.value);
            }

            for (var t in tokens) {
                if (tokens.hasOwnProperty(t)) {
                    t = tokens[t];
                    if (state.funct[&quot;(scope)&quot;].block.isGlobal()) {
                        if (predefined[t.id] === false) {
                            warning(&quot;W079&quot;, t.token, t.id);
                        }
                    }
                    if (t.id &amp;&amp; !state.funct[&quot;(noblockscopedvar)&quot;]) {
                        state.funct[&quot;(scope)&quot;].addlabel(t.id, {
                            type: type,
                            token: t.token
                        });
                        names.push(t.token);

                        if (lone &amp;&amp; inexport) {
                            state.funct[&quot;(scope)&quot;].setExported(t.token.value, t.token);
                        }
                    }
                }
            }

            if (state.tokens.next.id === &quot;=&quot;) {
                advance(&quot;=&quot;);
                if (!prefix &amp;&amp; peek(0).id === &quot;=&quot; &amp;&amp; state.tokens.next.identifier) {
                    warning(&quot;W120&quot;, state.tokens.next, state.tokens.next.value);
                }
                var id = state.tokens.prev;
                // don&#x27;t accept &#x60;in&#x60; in expression if prefix is used for ForIn/Of loop.
                value = expression(prefix ? 120 : 10);
                if (!prefix &amp;&amp; value &amp;&amp; value.type === &quot;undefined&quot;) {
                    warning(&quot;W080&quot;, id, id.value);
                }
                if (lone) {
                    tokens[0].first = value;
                } else {
                    destructuringPatternMatch(names, value);
                }
            }

            statement.first = statement.first.concat(names);

            if (state.tokens.next.id !== &quot;,&quot;) {
                break;
            }
            comma();
        }
        if (letblock) {
            advance(&quot;)&quot;);
            block(true, true);
            statement.block = true;
            state.funct[&quot;(scope)&quot;].unstack();
        }

        return statement;
    }

    var conststatement = stmt(&quot;const&quot;, function(context) {
        return blockVariableStatement(&quot;const&quot;, this, context);
    });
    conststatement.exps = true;

    var letstatement = stmt(&quot;let&quot;, function(context) {
        return blockVariableStatement(&quot;let&quot;, this, context);
    });
    letstatement.exps = true;

    var varstatement = stmt(&quot;var&quot;, function(context) {
        var prefix = context &amp;&amp; context.prefix;
        var inexport = context &amp;&amp; context.inexport;
        var tokens, lone, value;

        // If the &#x60;implied&#x60; option is set, bindings are set differently.
        var implied = context &amp;&amp; context.implied;
        var report = !(context &amp;&amp; context.ignore);

        this.first = [];
        for (; ;) {
            var names: { first }[] = [];
            if (contains([&quot;{&quot;, &quot;[&quot;], state.tokens.next.value)) {
                tokens = destructuringPattern();
                lone = false;
            } else {
                tokens = [{ id: identifier(), token: state.tokens.curr }];
                lone = true;
            }

            if (!(prefix &amp;&amp; implied) &amp;&amp; report &amp;&amp; state.option.varstmt) {
                warning(&quot;W132&quot;, this);
            }

            this.first = this.first.concat(names);

            for (var t in tokens) {
                if (tokens.hasOwnProperty(t)) {
                    t = tokens[t];
                    if (!implied &amp;&amp; state.funct[&quot;(global)&quot;]) {
                        if (predefined[t.id] === false) {
                            warning(&quot;W079&quot;, t.token, t.id);
                        } else if (state.option.futurehostile === false) {
                            if ((!state.inES5() &amp;&amp; ecmaIdentifiers[5][t.id] === false) ||
                                (!state.inES6() &amp;&amp; ecmaIdentifiers[6][t.id] === false)) {
                                warning(&quot;W129&quot;, t.token, t.id);
                            }
                        }
                    }
                    if (t.id) {
                        if (implied === &quot;for&quot;) {

                            if (!state.funct[&quot;(scope)&quot;].has(t.id)) {
                                if (report) warning(&quot;W088&quot;, t.token, t.id);
                            }
                            state.funct[&quot;(scope)&quot;].block.use(t.id, t.token);
                        } else {
                            state.funct[&quot;(scope)&quot;].addlabel(t.id, {
                                type: &quot;var&quot;,
                                token: t.token
                            });

                            if (lone &amp;&amp; inexport) {
                                state.funct[&quot;(scope)&quot;].setExported(t.id, t.token);
                            }
                        }
                        names.push(t.token);
                    }
                }
            }

            if (state.tokens.next.id === &quot;=&quot;) {
                state.nameStack.set(state.tokens.curr);

                advance(&quot;=&quot;);
                if (peek(0).id === &quot;=&quot; &amp;&amp; state.tokens.next.identifier) {
                    if (!prefix &amp;&amp; report &amp;&amp;
                        !state.funct[&quot;(params)&quot;] ||
                        state.funct[&quot;(params)&quot;].indexOf(state.tokens.next.value) === -1) {
                        warning(&quot;W120&quot;, state.tokens.next, state.tokens.next.value);
                    }
                }
                var id = state.tokens.prev;
                // don&#x27;t accept &#x60;in&#x60; in expression if prefix is used for ForIn/Of loop.
                value = expression(prefix ? 120 : 10);
                if (value &amp;&amp; !prefix &amp;&amp; report &amp;&amp; !state.funct[&quot;(loopage)&quot;] &amp;&amp; value.type === &quot;undefined&quot;) {
                    warning(&quot;W080&quot;, id, id.value);
                }
                if (lone) {
                    tokens[0].first = value;
                } else {
                    destructuringPatternMatch(names, value);
                }
            }

            if (state.tokens.next.id !== &quot;,&quot;) {
                break;
            }
            comma();
        }

        return this;
    });
    varstatement.exps = true;

    blockstmt(&quot;class&quot;, function() {
        return classdef.call(this, true);
    });

    function classdef(isStatement) {

        /*jshint validthis:true */
        if (!state.inES6()) {
            warning(&quot;W104&quot;, state.tokens.curr, &quot;class&quot;, &quot;6&quot;);
        }
        if (isStatement) {
            // BindingIdentifier
            this.name = identifier();

            state.funct[&quot;(scope)&quot;].addlabel(this.name, {
                type: &quot;class&quot;,
                token: state.tokens.curr
            });
        } else if (state.tokens.next.identifier &amp;&amp; state.tokens.next.value !== &quot;extends&quot;) {
            // BindingIdentifier(opt)
            this.name = identifier();
            this.namedExpr = true;
        } else {
            this.name = state.nameStack.infer();
        }
        classtail(this);
        return this;
    }

    function classtail(c) {
        var wasInClassBody = state.inClassBody;
        // ClassHeritage(opt)
        if (state.tokens.next.value === &quot;extends&quot;) {
            advance(&quot;extends&quot;);
            c.heritage = expression(10);
        }

        state.inClassBody = true;
        advance(&quot;{&quot;);
        // ClassBody(opt)
        c.body = classbody(c);
        advance(&quot;}&quot;);
        state.inClassBody = wasInClassBody;
    }

    function classbody(c) {
        var name;
        var isStatic;
        var isGenerator;
        var getset;
        var props = Object.create(null);
        var staticProps = Object.create(null);
        var computed;
        for (var i = 0; state.tokens.next.id !== &quot;}&quot;; ++i) {
            name = state.tokens.next;
            isStatic = false;
            isGenerator = false;
            getset = null;

            // The ES6 grammar for ClassElement includes the &#x60;;&#x60; token, but it is
            // defined only as a placeholder to facilitate future language
            // extensions. In ES6 code, it serves no purpose.
            if (name.id === &quot;;&quot;) {
                warning(&quot;W032&quot;);
                advance(&quot;;&quot;);
                continue;
            }

            if (name.id === &quot;*&quot;) {
                isGenerator = true;
                advance(&quot;*&quot;);
                name = state.tokens.next;
            }
            if (name.id === &quot;[&quot;) {
                name = computedPropertyName();
                computed = true;
            } else if (isPropertyName(name)) {
                // Non-Computed PropertyName
                advance();
                computed = false;
                if (name.identifier &amp;&amp; name.value === &quot;static&quot;) {
                    if (checkPunctuator(state.tokens.next, &quot;*&quot;)) {
                        isGenerator = true;
                        advance(&quot;*&quot;);
                    }
                    if (isPropertyName(state.tokens.next) || state.tokens.next.id === &quot;[&quot;) {
                        computed = state.tokens.next.id === &quot;[&quot;;
                        isStatic = true;
                        name = state.tokens.next;
                        if (state.tokens.next.id === &quot;[&quot;) {
                            name = computedPropertyName();
                        } else advance();
                    }
                }

                if (name.identifier &amp;&amp; (name.value === &quot;get&quot; || name.value === &quot;set&quot;)) {
                    if (isPropertyName(state.tokens.next) || state.tokens.next.id === &quot;[&quot;) {
                        computed = state.tokens.next.id === &quot;[&quot;;
                        getset = name;
                        name = state.tokens.next;
                        if (state.tokens.next.id === &quot;[&quot;) {
                            name = computedPropertyName();
                        } else advance();
                    }
                }
            } else {
                warning(&quot;W052&quot;, state.tokens.next, state.tokens.next.value || state.tokens.next.type);
                advance();
                continue;
            }

            if (!checkPunctuator(state.tokens.next, &quot;(&quot;)) {
                // error --- class properties must be methods
                error(&quot;E054&quot;, state.tokens.next, state.tokens.next.value);
                while (state.tokens.next.id !== &quot;}&quot; &amp;&amp;
                    !checkPunctuator(state.tokens.next, &quot;(&quot;)) {
                    advance();
                }
                if (state.tokens.next.value !== &quot;(&quot;) {
                    doFunction({ statement: c });
                }
            }

            if (!computed) {
                // We don&#x27;t know how to determine if we have duplicate computed property names :(
                if (getset) {
                    saveAccessor(
                        getset.value, isStatic ? staticProps : props, name.value, name, true, isStatic);
                } else {
                    if (name.value === &quot;constructor&quot;) {
                        state.nameStack.set(c);
                    } else {
                        state.nameStack.set(name);
                    }
                    saveProperty(isStatic ? staticProps : props, name.value, name, true, isStatic);
                }
            }

            if (getset &amp;&amp; name.value === &quot;constructor&quot;) {
                var propDesc = getset.value === &quot;get&quot; ? &quot;class getter method&quot; : &quot;class setter method&quot;;
                error(&quot;E049&quot;, name, propDesc, &quot;constructor&quot;);
            } else if (name.value === &quot;prototype&quot;) {
                error(&quot;E049&quot;, name, &quot;class method&quot;, &quot;prototype&quot;);
            }

            propertyName(name);

            doFunction({
                statement: c,
                type: isGenerator ? &quot;generator&quot; : null,
                classExprBinding: c.namedExpr ? c.name : null
            });
        }

        checkProperties(props);
    }

    blockstmt(&quot;function&quot;, function(context) {
        var inexport = context &amp;&amp; context.inexport;
        var generator = false;
        if (state.tokens.next.value === &quot;*&quot;) {
            advance(&quot;*&quot;);
            if (state.inES6(true)) {
                generator = true;
            } else {
                warning(&quot;W119&quot;, state.tokens.curr, &quot;function*&quot;, &quot;6&quot;);
            }
        }
        if (inblock) {
            warning(&quot;W082&quot;, state.tokens.curr);
        }
        var i = optionalidentifier();

        state.funct[&quot;(scope)&quot;].addlabel(i, {
            type: &quot;function&quot;,
            token: state.tokens.curr
        });

        if (i === void 0) {
            warning(&quot;W025&quot;);
        } else if (inexport) {
            state.funct[&quot;(scope)&quot;].setExported(i, state.tokens.prev);
        }

        doFunction({
            name: i,
            statement: this,
            type: generator ? &quot;generator&quot; : null,
            ignoreLoopFunc: inblock // a declaration may already have warned
        });
        if (state.tokens.next.id === &quot;(&quot; &amp;&amp; state.tokens.next.line === state.tokens.curr.line) {
            error(&quot;E039&quot;);
        }
        return this;
    });

    prefix(&quot;function&quot;, function() {
        var generator = false;

        if (state.tokens.next.value === &quot;*&quot;) {
            if (!state.inES6()) {
                warning(&quot;W119&quot;, state.tokens.curr, &quot;function*&quot;, &quot;6&quot;);
            }
            advance(&quot;*&quot;);
            generator = true;
        }

        var i = optionalidentifier();
        doFunction({ name: i, type: generator ? &quot;generator&quot; : null });
        return this;
    });

    blockstmt(&quot;if&quot;, function() {
        var t = state.tokens.next;
        increaseComplexityCount();
        state.condition = true;
        advance(&quot;(&quot;);
        var expr = expression(0);
        checkCondAssignment(expr);

        // When the if is within a for-in loop, check if the condition
        // starts with a negation operator
        var forinifcheck = null;
        if (state.option.forin &amp;&amp; state.forinifcheckneeded) {
            state.forinifcheckneeded = false; // We only need to analyze the first if inside the loop
            forinifcheck = state.forinifchecks[state.forinifchecks.length - 1];
            if (expr.type === &quot;(punctuator)&quot; &amp;&amp; expr.value === &quot;!&quot;) {
                forinifcheck.type = &quot;(negative)&quot;;
            } else {
                forinifcheck.type = &quot;(positive)&quot;;
            }
        }

        advance(&quot;)&quot;, t);
        state.condition = false;
        var s = block(true, true);

        // When the if is within a for-in loop and the condition has a negative form,
        // check if the body contains nothing but a continue statement
        if (forinifcheck &amp;&amp; forinifcheck.type === &quot;(negative)&quot;) {
            if (s &amp;&amp; s[0] &amp;&amp; s[0].type === &quot;(identifier)&quot; &amp;&amp; s[0].value === &quot;continue&quot;) {
                forinifcheck.type = &quot;(negative-with-continue)&quot;;
            }
        }

        if (state.tokens.next.id === &quot;else&quot;) {
            advance(&quot;else&quot;);
            if (state.tokens.next.id === &quot;if&quot; || state.tokens.next.id === &quot;switch&quot;) {
                statement();
            } else {
                block(true, true);
            }
        }
        return this;
    });

    blockstmt(&quot;try&quot;, function() {
        var b;

        function doCatch() {
            advance(&quot;catch&quot;);
            advance(&quot;(&quot;);

            state.funct[&quot;(scope)&quot;].stack(&quot;catchparams&quot;);

            if (checkPunctuators(state.tokens.next, [&quot;[&quot;, &quot;{&quot;])) {
                var tokens = destructuringPattern();
                tokens.forEach(function(token: any) {
                    if (token.id) {
                        state.funct[&quot;(scope)&quot;].addParam(token.id, token, &quot;exception&quot;);
                    }
                });
            } else if (state.tokens.next.type !== &quot;(identifier)&quot;) {
                warning(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
            } else {
                // only advance if we have an identifier so we can continue parsing in the most common error - that no param is given.
                state.funct[&quot;(scope)&quot;].addParam(identifier(), state.tokens.curr, &quot;exception&quot;);
            }

            if (state.tokens.next.value === &quot;if&quot;) {
                if (!state.inMoz()) {
                    warning(&quot;W118&quot;, state.tokens.curr, &quot;catch filter&quot;);
                }
                advance(&quot;if&quot;);
                expression(0);
            }

            advance(&quot;)&quot;);

            block(false);

            state.funct[&quot;(scope)&quot;].unstack();
        }

        block(true);

        while (state.tokens.next.id === &quot;catch&quot;) {
            increaseComplexityCount();
            if (b &amp;&amp; (!state.inMoz())) {
                warning(&quot;W118&quot;, state.tokens.next, &quot;multiple catch blocks&quot;);
            }
            doCatch();
            b = true;
        }

        if (state.tokens.next.id === &quot;finally&quot;) {
            advance(&quot;finally&quot;);
            block(true);
            return;
        }

        if (!b) {
            error(&quot;E021&quot;, state.tokens.next, &quot;catch&quot;, state.tokens.next.value);
        }

        return this;
    });

    blockstmt(&quot;while&quot;, function() {
        var t = state.tokens.next;
        state.funct[&quot;(breakage)&quot;] += 1;
        state.funct[&quot;(loopage)&quot;] += 1;
        increaseComplexityCount();
        advance(&quot;(&quot;);
        checkCondAssignment(expression(0));
        advance(&quot;)&quot;, t);
        block(true, true);
        state.funct[&quot;(breakage)&quot;] -= 1;
        state.funct[&quot;(loopage)&quot;] -= 1;
        return this;
    }).labelled = true;

    blockstmt(&quot;with&quot;, function() {
        var t = state.tokens.next;
        if (state.isStrict()) {
            error(&quot;E010&quot;, state.tokens.curr);
        } else if (!state.option.withstmt) {
            warning(&quot;W085&quot;, state.tokens.curr);
        }

        advance(&quot;(&quot;);
        expression(0);
        advance(&quot;)&quot;, t);
        block(true, true);

        return this;
    });

    blockstmt(&quot;switch&quot;, function() {
        var t = state.tokens.next;
        var g = false;
        var noindent = false;

        state.funct[&quot;(breakage)&quot;] += 1;
        advance(&quot;(&quot;);
        checkCondAssignment(expression(0));
        advance(&quot;)&quot;, t);
        t = state.tokens.next;
        advance(&quot;{&quot;);

        if (state.tokens.next.from === indent)
            noindent = true;

        if (!noindent)
            indent += state.option.indent;

        this.cases = [];

        for (; ;) {
            switch (state.tokens.next.id) {
                case &quot;case&quot;:
                    switch (state.funct[&quot;(verb)&quot;]) {
                        case &quot;yield&quot;:
                        case &quot;break&quot;:
                        case &quot;case&quot;:
                        case &quot;continue&quot;:
                        case &quot;return&quot;:
                        case &quot;switch&quot;:
                        case &quot;throw&quot;:
                            break;
                        default:
                            // You can tell JSHint that you don&#x27;t use break intentionally by
                            // adding a comment /* falls through */ on a line just before
                            // the next &#x60;case&#x60;.
                            if (!state.tokens.curr.caseFallsThrough) {
                                warning(&quot;W086&quot;, state.tokens.curr, &quot;case&quot;);
                            }
                    }

                    advance(&quot;case&quot;);
                    this.cases.push(expression(0));
                    increaseComplexityCount();
                    g = true;
                    advance(&quot;:&quot;);
                    state.funct[&quot;(verb)&quot;] = &quot;case&quot;;
                    break;
                case &quot;default&quot;:
                    switch (state.funct[&quot;(verb)&quot;]) {
                        case &quot;yield&quot;:
                        case &quot;break&quot;:
                        case &quot;continue&quot;:
                        case &quot;return&quot;:
                        case &quot;throw&quot;:
                            break;
                        default:
                            // Do not display a warning if &#x27;default&#x27; is the first statement or if
                            // there is a special /* falls through */ comment.
                            if (this.cases.length) {
                                if (!state.tokens.curr.caseFallsThrough) {
                                    warning(&quot;W086&quot;, state.tokens.curr, &quot;default&quot;);
                                }
                            }
                    }

                    advance(&quot;default&quot;);
                    g = true;
                    advance(&quot;:&quot;);
                    break;
                case &quot;}&quot;:
                    if (!noindent)
                        indent -= state.option.indent;

                    advance(&quot;}&quot;, t);
                    state.funct[&quot;(breakage)&quot;] -= 1;
                    state.funct[&quot;(verb)&quot;] = void 0;
                    return;
                case &quot;(end)&quot;:
                    error(&quot;E023&quot;, state.tokens.next, &quot;}&quot;);
                    return;
                default:
                    indent += state.option.indent;
                    if (g) {
                        switch (state.tokens.curr.id) {
                            case &quot;,&quot;:
                                error(&quot;E040&quot;);
                                return;
                            case &quot;:&quot;:
                                g = false;
                                statements();
                                break;
                            default:
                                error(&quot;E025&quot;, state.tokens.curr);
                                return;
                        }
                    } else {
                        if (state.tokens.curr.id === &quot;:&quot;) {
                            advance(&quot;:&quot;);
                            error(&quot;E024&quot;, state.tokens.curr, &quot;:&quot;);
                            statements();
                        } else {
                            error(&quot;E021&quot;, state.tokens.next, &quot;case&quot;, state.tokens.next.value);
                            return;
                        }
                    }
                    indent -= state.option.indent;
            }
        }
        return this;
    }).labelled = true;

    stmt(&quot;debugger&quot;, function() {
        if (!state.option.debug) {
            warning(&quot;W087&quot;, this);
        }
        return this;
    }).exps = true;

    (function() {
        var x = stmt(&quot;do&quot;, function() {
            state.funct[&quot;(breakage)&quot;] += 1;
            state.funct[&quot;(loopage)&quot;] += 1;
            increaseComplexityCount();

            this.first = block(true, true);
            advance(&quot;while&quot;);
            var t = state.tokens.next;
            advance(&quot;(&quot;);
            checkCondAssignment(expression(0));
            advance(&quot;)&quot;, t);
            state.funct[&quot;(breakage)&quot;] -= 1;
            state.funct[&quot;(loopage)&quot;] -= 1;
            return this;
        });
        x.labelled = true;
        x.exps = true;
    } ());

    blockstmt(&quot;for&quot;, function() {
        var s, t = state.tokens.next;
        var letscope = false;
        var foreachtok = null;

        if (t.value === &quot;each&quot;) {
            foreachtok = t;
            advance(&quot;each&quot;);
            if (!state.inMoz()) {
                warning(&quot;W118&quot;, state.tokens.curr, &quot;for each&quot;);
            }
        }

        increaseComplexityCount();
        advance(&quot;(&quot;);

        // what kind of for() statement it is? for(of)? for(in)? for(;;)?
        var nextop; // contains the token of the &quot;in&quot; or &quot;of&quot; operator
        var i = 0;
        var inof = [&quot;in&quot;, &quot;of&quot;];
        var level = 0; // BindingPattern &quot;level&quot; --- level 0 === no BindingPattern
        var comma; // First comma punctuator at level 0
        var initializer; // First initializer at level 0

        // If initial token is a BindingPattern, count it as such.
        if (checkPunctuators(state.tokens.next, [&quot;{&quot;, &quot;[&quot;]))++level;
        do {
            nextop = peek(i);
            ++i;
            if (checkPunctuators(nextop, [&quot;{&quot;, &quot;[&quot;]))++level;
            else if (checkPunctuators(nextop, [&quot;}&quot;, &quot;]&quot;]))--level;
            if (level &lt; 0) break;
            if (level === 0) {
                if (!comma &amp;&amp; checkPunctuator(nextop, &quot;,&quot;)) comma = nextop;
                else if (!initializer &amp;&amp; checkPunctuator(nextop, &quot;=&quot;)) initializer = nextop;
            }
        } while (level &gt; 0 || !contains(inof, nextop.value) &amp;&amp; nextop.value !== &quot;;&quot; &amp;&amp;
        nextop.type !== &quot;(end)&quot;); // Is this a JSCS bug? This looks really weird.

        // if we&#x27;re in a for ( in|of ) statement
        if (contains(inof, nextop.value)) {
            if (!state.inES6() &amp;&amp; nextop.value === &quot;of&quot;) {
                warning(&quot;W104&quot;, nextop, &quot;for of&quot;, &quot;6&quot;);
            }

            var ok = !(initializer || comma);
            if (initializer) {
                error(&quot;W133&quot;, comma, nextop.value, &quot;initializer is forbidden&quot;);
            }

            if (comma) {
                error(&quot;W133&quot;, comma, nextop.value, &quot;more than one ForBinding&quot;);
            }

            if (state.tokens.next.id === &quot;var&quot;) {
                advance(&quot;var&quot;);
                state.tokens.curr.fud({ prefix: true });
            } else if (state.tokens.next.id === &quot;let&quot; || state.tokens.next.id === &quot;const&quot;) {
                advance(state.tokens.next.id);
                // create a new block scope
                letscope = true;
                state.funct[&quot;(scope)&quot;].stack();
                state.tokens.curr.fud({ prefix: true });
            } else {
                // Parse as a var statement, with implied bindings. Ignore errors if an error
                // was already reported
                Object.create(varstatement).fud({ prefix: true, implied: &quot;for&quot;, ignore: !ok });
            }
            advance(nextop.value);
            expression(20);
            advance(&quot;)&quot;, t);

            if (nextop.value === &quot;in&quot; &amp;&amp; state.option.forin) {
                state.forinifcheckneeded = true;

                if (state.forinifchecks === void 0) {
                    state.forinifchecks = [];
                }

                // Push a new for-in-if check onto the stack. The type will be modified
                // when the loop&#x27;s body is parsed and a suitable if statement exists.
                state.forinifchecks.push({
                    type: &quot;(none)&quot;
                });
            }

            state.funct[&quot;(breakage)&quot;] += 1;
            state.funct[&quot;(loopage)&quot;] += 1;

            s = block(true, true);

            if (nextop.value === &quot;in&quot; &amp;&amp; state.option.forin) {
                if (state.forinifchecks &amp;&amp; state.forinifchecks.length &gt; 0) {
                    var check = state.forinifchecks.pop();

                    if (// No if statement or not the first statement in loop body
                        s &amp;&amp; s.length &gt; 0 &amp;&amp; (typeof s[0] !== &quot;object&quot; || s[0].value !== &quot;if&quot;) ||
                        // Positive if statement is not the only one in loop body
                        check.type === &quot;(positive)&quot; &amp;&amp; s.length &gt; 1 ||
                        // Negative if statement but no continue
                        check.type === &quot;(negative)&quot;) {
                        warning(&quot;W089&quot;, this);
                    }
                }

                // Reset the flag in case no if statement was contained in the loop body
                state.forinifcheckneeded = false;
            }

            state.funct[&quot;(breakage)&quot;] -= 1;
            state.funct[&quot;(loopage)&quot;] -= 1;
        } else {
            if (foreachtok) {
                error(&quot;E045&quot;, foreachtok);
            }
            if (state.tokens.next.id !== &quot;;&quot;) {
                if (state.tokens.next.id === &quot;var&quot;) {
                    advance(&quot;var&quot;);
                    state.tokens.curr.fud();
                } else if (state.tokens.next.id === &quot;let&quot;) {
                    advance(&quot;let&quot;);
                    // create a new block scope
                    letscope = true;
                    state.funct[&quot;(scope)&quot;].stack();
                    state.tokens.curr.fud();
                } else {
                    for (; ;) {
                        expression(0, &quot;for&quot;);
                        if (state.tokens.next.id !== &quot;,&quot;) {
                            break;
                        }
                        comma();
                    }
                }
            }
            nolinebreak(state.tokens.curr);
            advance(&quot;;&quot;);

            // start loopage after the first ; as the next two expressions are executed
            // on every loop
            state.funct[&quot;(loopage)&quot;] += 1;
            if (state.tokens.next.id !== &quot;;&quot;) {
                checkCondAssignment(expression(0));
            }
            nolinebreak(state.tokens.curr);
            advance(&quot;;&quot;);
            if (state.tokens.next.id === &quot;;&quot;) {
                error(&quot;E021&quot;, state.tokens.next, &quot;)&quot;, &quot;;&quot;);
            }
            if (state.tokens.next.id !== &quot;)&quot;) {
                for (; ;) {
                    expression(0, &quot;for&quot;);
                    if (state.tokens.next.id !== &quot;,&quot;) {
                        break;
                    }
                    comma();
                }
            }
            advance(&quot;)&quot;, t);
            state.funct[&quot;(breakage)&quot;] += 1;
            block(true, true);
            state.funct[&quot;(breakage)&quot;] -= 1;
            state.funct[&quot;(loopage)&quot;] -= 1;

        }
        // unstack loop blockscope
        if (letscope) {
            state.funct[&quot;(scope)&quot;].unstack();
        }
        return this;
    }).labelled = true;


    stmt(&quot;break&quot;, function() {
        var v = state.tokens.next.value;

        if (!state.option.asi)
            nolinebreak(this);

        if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach &amp;&amp;
            state.tokens.curr.line === startLine(state.tokens.next)) {
            if (!state.funct[&quot;(scope)&quot;].funct.hasBreakLabel(v)) {
                warning(&quot;W090&quot;, state.tokens.next, v);
            }
            this.first = state.tokens.next;
            advance();
        } else {
            if (state.funct[&quot;(breakage)&quot;] === 0)
                warning(&quot;W052&quot;, state.tokens.next, this.value);
        }

        reachable(this);

        return this;
    }).exps = true;


    stmt(&quot;continue&quot;, function() {
        var v = state.tokens.next.value;

        if (state.funct[&quot;(breakage)&quot;] === 0)
            warning(&quot;W052&quot;, state.tokens.next, this.value);
        if (!state.funct[&quot;(loopage)&quot;])
            warning(&quot;W052&quot;, state.tokens.next, this.value);

        if (!state.option.asi)
            nolinebreak(this);

        if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach) {
            if (state.tokens.curr.line === startLine(state.tokens.next)) {
                if (!state.funct[&quot;(scope)&quot;].funct.hasBreakLabel(v)) {
                    warning(&quot;W090&quot;, state.tokens.next, v);
                }
                this.first = state.tokens.next;
                advance();
            }
        }

        reachable(this);

        return this;
    }).exps = true;


    stmt(&quot;return&quot;, function() {
        if (this.line === startLine(state.tokens.next)) {
            if (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.tokens.next.reach) {
                this.first = expression(0);

                if (this.first &amp;&amp;
                    this.first.type === &quot;(punctuator)&quot; &amp;&amp; this.first.value === &quot;=&quot; &amp;&amp;
                    !this.first.paren &amp;&amp; !state.option.boss) {
                    warningAt(&quot;W093&quot;, this.first.line, this.first.character);
                }
            }
        } else {
            if (state.tokens.next.type === &quot;(punctuator)&quot; &amp;&amp;
                [&quot;[&quot;, &quot;{&quot;, &quot;+&quot;, &quot;-&quot;].indexOf(state.tokens.next.value) &gt; -1) {
                nolinebreak(this); // always warn (Line breaking error)
            }
        }

        reachable(this);

        return this;
    }).exps = true;

    (function(x) {
        x.exps = true;
        x.lbp = 25;
    } (prefix(&quot;yield&quot;, function() {
        var prev = state.tokens.prev;
        if (state.inES6(true) &amp;&amp; !state.funct[&quot;(generator)&quot;]) {
            // If it&#x27;s a yield within a catch clause inside a generator then that&#x27;s ok
            if (!(&quot;(catch)&quot; === state.funct[&quot;(name)&quot;] &amp;&amp; state.funct[&quot;(context)&quot;][&quot;(generator)&quot;])) {
                error(&quot;E046&quot;, state.tokens.curr, &quot;yield&quot;);
            }
        } else if (!state.inES6()) {
            warning(&quot;W104&quot;, state.tokens.curr, &quot;yield&quot;, &quot;6&quot;);
        }
        state.funct[&quot;(generator)&quot;] = &quot;yielded&quot;;
        var delegatingYield = false;

        if (state.tokens.next.value === &quot;*&quot;) {
            delegatingYield = true;
            advance(&quot;*&quot;);
        }

        if (this.line === startLine(state.tokens.next) || !state.inMoz()) {
            if (delegatingYield ||
                (state.tokens.next.id !== &quot;;&quot; &amp;&amp; !state.option.asi &amp;&amp;
                    !state.tokens.next.reach &amp;&amp; state.tokens.next.nud)) {

                nobreaknonadjacent(state.tokens.curr, state.tokens.next);
                this.first = expression(10);

                if (this.first.type === &quot;(punctuator)&quot; &amp;&amp; this.first.value === &quot;=&quot; &amp;&amp;
                    !this.first.paren &amp;&amp; !state.option.boss) {
                    warningAt(&quot;W093&quot;, this.first.line, this.first.character);
                }
            }

            if (state.inMoz() &amp;&amp; state.tokens.next.id !== &quot;)&quot; &amp;&amp;
                (prev.lbp &gt; 30 || (!prev.assign &amp;&amp; !isEndOfExpr()) || prev.id === &quot;yield&quot;)) {
                error(&quot;E050&quot;, this);
            }
        } else if (!state.option.asi) {
            nolinebreak(this); // always warn (Line breaking error)
        }
        return this;
    })));


    stmt(&quot;throw&quot;, function() {
        nolinebreak(this);
        this.first = expression(20);

        reachable(this);

        return this;
    }).exps = true;

    stmt(&quot;import&quot;, function() {
        if (!state.inES6()) {
            warning(&quot;W119&quot;, state.tokens.curr, &quot;import&quot;, &quot;6&quot;);
        }

        if (state.tokens.next.type === &quot;(string)&quot;) {
            // ModuleSpecifier :: StringLiteral
            advance(&quot;(string)&quot;);
            return this;
        }

        if (state.tokens.next.identifier) {
            // ImportClause :: ImportedDefaultBinding
            this.name = identifier();
            // Import bindings are immutable (see ES6 8.1.1.5.5)
            state.funct[&quot;(scope)&quot;].addlabel(this.name, {
                type: &quot;const&quot;,
                token: state.tokens.curr
            });

            if (state.tokens.next.value === &quot;,&quot;) {
                // ImportClause :: ImportedDefaultBinding , NameSpaceImport
                // ImportClause :: ImportedDefaultBinding , NamedImports
                advance(&quot;,&quot;);
                // At this point, we intentionally fall through to continue matching
                // either NameSpaceImport or NamedImports.
                // Discussion:
                // https://github.com/jshint/jshint/pull/2144#discussion_r23978406
            } else {
                advance(&quot;from&quot;);
                advance(&quot;(string)&quot;);
                return this;
            }
        }

        if (state.tokens.next.id === &quot;*&quot;) {
            // ImportClause :: NameSpaceImport
            advance(&quot;*&quot;);
            advance(&quot;as&quot;);
            if (state.tokens.next.identifier) {
                this.name = identifier();
                // Import bindings are immutable (see ES6 8.1.1.5.5)
                state.funct[&quot;(scope)&quot;].addlabel(this.name, {
                    type: &quot;const&quot;,
                    token: state.tokens.curr
                });
            }
        } else {
            // ImportClause :: NamedImports
            advance(&quot;{&quot;);
            for (; ;) {
                if (state.tokens.next.value === &quot;}&quot;) {
                    advance(&quot;}&quot;);
                    break;
                }
                var importName;
                if (state.tokens.next.type === &quot;default&quot;) {
                    importName = &quot;default&quot;;
                    advance(&quot;default&quot;);
                } else {
                    importName = identifier();
                }
                if (state.tokens.next.value === &quot;as&quot;) {
                    advance(&quot;as&quot;);
                    importName = identifier();
                }

                // Import bindings are immutable (see ES6 8.1.1.5.5)
                state.funct[&quot;(scope)&quot;].addlabel(importName, {
                    type: &quot;const&quot;,
                    token: state.tokens.curr
                });

                if (state.tokens.next.value === &quot;,&quot;) {
                    advance(&quot;,&quot;);
                } else if (state.tokens.next.value === &quot;}&quot;) {
                    advance(&quot;}&quot;);
                    break;
                } else {
                    error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
                    break;
                }
            }
        }

        // FromClause
        advance(&quot;from&quot;);
        advance(&quot;(string)&quot;);
        return this;
    }).exps = true;

    stmt(&quot;export&quot;, function() {
        var ok = true;
        var token;
        var identifier;

        if (!state.inES6()) {
            warning(&quot;W119&quot;, state.tokens.curr, &quot;export&quot;, &quot;6&quot;);
            ok = false;
        }

        if (!state.funct[&quot;(scope)&quot;].block.isGlobal()) {
            error(&quot;E053&quot;, state.tokens.curr);
            ok = false;
        }

        if (state.tokens.next.value === &quot;*&quot;) {
            // ExportDeclaration :: export * FromClause
            advance(&quot;*&quot;);
            advance(&quot;from&quot;);
            advance(&quot;(string)&quot;);
            return this;
        }

        if (state.tokens.next.type === &quot;default&quot;) {
            // ExportDeclaration ::
            //      export default [lookahead  { function, class }] AssignmentExpression[In] ;
            //      export default HoistableDeclaration
            //      export default ClassDeclaration
            state.nameStack.set(state.tokens.next);
            advance(&quot;default&quot;);
            var exportType = state.tokens.next.id;
            if (exportType === &quot;function&quot; || exportType === &quot;class&quot;) {
                this.block = true;
            }

            token = peek();

            expression(10);

            identifier = token.value;

            if (this.block) {
                state.funct[&quot;(scope)&quot;].addlabel(identifier, {
                    type: exportType,
                    token: token
                });

                state.funct[&quot;(scope)&quot;].setExported(identifier, token);
            }

            return this;
        }

        if (state.tokens.next.value === &quot;{&quot;) {
            // ExportDeclaration :: export ExportClause
            advance(&quot;{&quot;);
            var exportedTokens = [];
            for (; ;) {
                if (!state.tokens.next.identifier) {
                    error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
                }
                advance();

                exportedTokens.push(state.tokens.curr);

                if (state.tokens.next.value === &quot;as&quot;) {
                    advance(&quot;as&quot;);
                    if (!state.tokens.next.identifier) {
                        error(&quot;E030&quot;, state.tokens.next, state.tokens.next.value);
                    }
                    advance();
                }

                if (state.tokens.next.value === &quot;,&quot;) {
                    advance(&quot;,&quot;);
                } else if (state.tokens.next.value === &quot;}&quot;) {
                    advance(&quot;}&quot;);
                    break;
                } else {
                    error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
                    break;
                }
            }
            if (state.tokens.next.value === &quot;from&quot;) {
                // ExportDeclaration :: export ExportClause FromClause
                advance(&quot;from&quot;);
                advance(&quot;(string)&quot;);
            } else if (ok) {
                exportedTokens.forEach(function(token) {
                    state.funct[&quot;(scope)&quot;].setExported(token.value, token);
                });
            }
            return this;
        }

        if (state.tokens.next.id === &quot;var&quot;) {
            // ExportDeclaration :: export VariableStatement
            advance(&quot;var&quot;);
            state.tokens.curr.fud({ inexport: true });
        } else if (state.tokens.next.id === &quot;let&quot;) {
            // ExportDeclaration :: export VariableStatement
            advance(&quot;let&quot;);
            state.tokens.curr.fud({ inexport: true });
        } else if (state.tokens.next.id === &quot;const&quot;) {
            // ExportDeclaration :: export VariableStatement
            advance(&quot;const&quot;);
            state.tokens.curr.fud({ inexport: true });
        } else if (state.tokens.next.id === &quot;function&quot;) {
            // ExportDeclaration :: export Declaration
            this.block = true;
            advance(&quot;function&quot;);
            state.syntax[&quot;function&quot;].fud({ inexport: true });
        } else if (state.tokens.next.id === &quot;class&quot;) {
            // ExportDeclaration :: export Declaration
            this.block = true;
            advance(&quot;class&quot;);
            var classNameToken = state.tokens.next;
            state.syntax[&quot;class&quot;].fud();
            state.funct[&quot;(scope)&quot;].setExported(classNameToken.value, classNameToken);
        } else {
            error(&quot;E024&quot;, state.tokens.next, state.tokens.next.value);
        }

        return this;
    }).exps = true;

    // Future Reserved Words

    FutureReservedWord(&quot;abstract&quot;);
    FutureReservedWord(&quot;boolean&quot;);
    FutureReservedWord(&quot;byte&quot;);
    FutureReservedWord(&quot;char&quot;);
    FutureReservedWord(&quot;class&quot;, { es5: true, nud: classdef });
    FutureReservedWord(&quot;double&quot;);
    FutureReservedWord(&quot;enum&quot;, { es5: true });
    FutureReservedWord(&quot;export&quot;, { es5: true });
    FutureReservedWord(&quot;extends&quot;, { es5: true });
    FutureReservedWord(&quot;final&quot;);
    FutureReservedWord(&quot;float&quot;);
    FutureReservedWord(&quot;goto&quot;);
    FutureReservedWord(&quot;implements&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;import&quot;, { es5: true });
    FutureReservedWord(&quot;int&quot;);
    FutureReservedWord(&quot;interface&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;long&quot;);
    FutureReservedWord(&quot;native&quot;);
    FutureReservedWord(&quot;package&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;private&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;protected&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;public&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;short&quot;);
    FutureReservedWord(&quot;static&quot;, { es5: true, strictOnly: true });
    FutureReservedWord(&quot;super&quot;, { es5: true });
    FutureReservedWord(&quot;synchronized&quot;);
    FutureReservedWord(&quot;transient&quot;);
    FutureReservedWord(&quot;volatile&quot;);

    // this function is used to determine whether a squarebracket or a curlybracket
    // expression is a comprehension array, destructuring assignment or a json value.

    var lookupBlockType = function() {
        var pn, pn1, prev;
        var i = -1;
        var bracketStack = 0;
        var ret: any = {};
        if (checkPunctuators(state.tokens.curr, [&quot;[&quot;, &quot;{&quot;])) {
            bracketStack += 1;
        }
        do {
            prev = i === -1 ? state.tokens.curr : pn;
            pn = i === -1 ? state.tokens.next : peek(i);
            pn1 = peek(i + 1);
            i = i + 1;
            if (checkPunctuators(pn, [&quot;[&quot;, &quot;{&quot;])) {
                bracketStack += 1;
            } else if (checkPunctuators(pn, [&quot;]&quot;, &quot;}&quot;])) {
                bracketStack -= 1;
            }
            if (bracketStack === 1 &amp;&amp; pn.identifier &amp;&amp; pn.value === &quot;for&quot; &amp;&amp;
                !checkPunctuator(prev, &quot;.&quot;)) {
                ret.isCompArray = true;
                ret.notJson = true;
                break;
            }
            if (bracketStack === 0 &amp;&amp; checkPunctuators(pn, [&quot;}&quot;, &quot;]&quot;])) {
                if (pn1.value === &quot;=&quot;) {
                    ret.isDestAssign = true;
                    ret.notJson = true;
                    break;
                } else if (pn1.value === &quot;.&quot;) {
                    ret.notJson = true;
                    break;
                }
            }
            if (checkPunctuator(pn, &quot;;&quot;)) {
                ret.isBlock = true;
                ret.notJson = true;
            }
        } while (bracketStack &gt; 0 &amp;&amp; pn.id !== &quot;(end)&quot;);
        return ret;
    };

    function saveProperty(props, name, tkn, isClass?, isStatic?) {
        var msgs = [&quot;key&quot;, &quot;class method&quot;, &quot;static class method&quot;];
        var msg = msgs[(isClass || false) + (isStatic || false)];
        if (tkn.identifier) {
            name = tkn.value;
        }

        if (props[name] &amp;&amp; name !== &quot;__proto__&quot;) {
            warning(&quot;W075&quot;, state.tokens.next, msg, name);
        } else {
            props[name] = Object.create(null);
        }

        props[name].basic = true;
        props[name].basictkn = tkn;
    }

    /**
     * @param {string} accessorType - Either &quot;get&quot; or &quot;set&quot;
     * @param {object} props - a collection of all properties of the object to
     *                         which the current accessor is being assigned
     * @param {object} tkn - the identifier token representing the accessor name
     * @param {boolean} isClass - whether the accessor is part of an ES6 Class
     *                            definition
     * @param {boolean} isStatic - whether the accessor is a static method
     */
    function saveAccessor(accessorType: string, props, name, tkn, isClass?: boolean, isStatic?: boolean) {
        var flagName = accessorType === &quot;get&quot; ? &quot;getterToken&quot; : &quot;setterToken&quot;;
        var msg = &quot;&quot;;

        if (isClass) {
            if (isStatic) {
                msg += &quot;static &quot;;
            }
            msg += accessorType + &quot;ter method&quot;;
        } else {
            msg = &quot;key&quot;;
        }

        state.tokens.curr.accessorType = accessorType;
        state.nameStack.set(tkn);

        if (props[name]) {
            if ((props[name].basic || props[name][flagName]) &amp;&amp; name !== &quot;__proto__&quot;) {
                warning(&quot;W075&quot;, state.tokens.next, msg, name);
            }
        } else {
            props[name] = Object.create(null);
        }

        props[name][flagName] = tkn;
    }

    function computedPropertyName() {
        advance(&quot;[&quot;);
        if (!state.inES6()) {
            warning(&quot;W119&quot;, state.tokens.curr, &quot;computed property names&quot;, &quot;6&quot;);
        }
        var value = expression(10);
        advance(&quot;]&quot;);
        return value;
    }

    /**
     * Test whether a given token is a punctuator matching one of the specified values
     * @param {Token} token
     * @param {Array.&lt;string&gt;} values
     * @returns {boolean}
     */
    function checkPunctuators(token: { type: string; value: string }, values: string[]) {
        if (token.type === &quot;(punctuator)&quot;) {
            return contains(values, token.value);
        }
        return false;
    }

    /**
     * Test whether a given token is a punctuator matching the specified value
     * @param {Token} token
     * @param {string} value
     * @returns {boolean}
     */
    function checkPunctuator(token, value) {
        return token.type === &quot;(punctuator)&quot; &amp;&amp; token.value === value;
    }

    // Check whether this function has been reached for a destructuring assign with undeclared values
    function destructuringAssignOrJsonValue() {
        // lookup for the assignment (ECMAScript 6 only)
        // if it has semicolons, it is a block, so go parse it as a block
        // or it&#x27;s not a block, but there are assignments, check for undeclared variables

        var block = lookupBlockType();
        if (block.notJson) {
            if (!state.inES6() &amp;&amp; block.isDestAssign) {
                warning(&quot;W104&quot;, state.tokens.curr, &quot;destructuring assignment&quot;, &quot;6&quot;);
            }
            statements();
            // otherwise parse json value
        } else {
            state.option.laxbreak = true;
            state.jsonMode = true;
            jsonValue();
        }
    }

    // array comprehension parsing function
    // parses and defines the three states of the list comprehension in order
    // to avoid defining global variables, but keeping them to the list comprehension scope
    // only. The order of the states are as follows:
    //  * &quot;use&quot; which will be the returned iterative part of the list comprehension
    //  * &quot;define&quot; which will define the variables local to the list comprehension
    //  * &quot;filter&quot; which will help filter out values

    var arrayComprehension = function() {
        var CompArray = function() {
            this.mode = &quot;use&quot;;
            this.variables = [];
        };
        var _carrays = [];
        var _current;
        function declare(v) {
            var l = _current.variables.filter(function(elt) {
                // if it has, change its undef state
                if (elt.value === v) {
                    elt.undef = false;
                    return v;
                }
            }).length;
            return l !== 0;
        }
        function use(v) {
            var l = _current.variables.filter(function(elt) {
                // and if it has been defined
                if (elt.value === v &amp;&amp; !elt.undef) {
                    if (elt.unused === true) {
                        elt.unused = false;
                    }
                    return v;
                }
            }).length;
            // otherwise we warn about it
            return (l === 0);
        }
        return {
            stack: function() {
                _current = new CompArray();
                _carrays.push(_current);
            },
            unstack: function() {
                _current.variables.filter(function(v) {
                    if (v.unused)
                        warning(&quot;W098&quot;, v.token, v.raw_text || v.value);
                    if (v.undef)
                        state.funct[&quot;(scope)&quot;].block.use(v.value, v.token);
                });
                _carrays.splice(-1, 1);
                _current = _carrays[_carrays.length - 1];
            },
            setState: function(s: string) {
                if (contains([&quot;use&quot;, &quot;define&quot;, &quot;generate&quot;, &quot;filter&quot;], s))
                    _current.mode = s;
            },
            check: function(v) {
                if (!_current) {
                    return;
                }
                // When we are in &quot;use&quot; state of the list comp, we enqueue that var
                if (_current &amp;&amp; _current.mode === &quot;use&quot;) {
                    if (use(v)) {
                        _current.variables.push({
                            funct: state.funct,
                            token: state.tokens.curr,
                            value: v,
                            undef: true,
                            unused: false
                        });
                    }
                    return true;
                    // When we are in &quot;define&quot; state of the list comp,
                } else if (_current &amp;&amp; _current.mode === &quot;define&quot;) {
                    // check if the variable has been used previously
                    if (!declare(v)) {
                        _current.variables.push({
                            funct: state.funct,
                            token: state.tokens.curr,
                            value: v,
                            undef: false,
                            unused: true
                        });
                    }
                    return true;
                    // When we are in the &quot;generate&quot; state of the list comp,
                } else if (_current &amp;&amp; _current.mode === &quot;generate&quot;) {
                    state.funct[&quot;(scope)&quot;].block.use(v, state.tokens.curr);
                    return true;
                    // When we are in &quot;filter&quot; state,
                } else if (_current &amp;&amp; _current.mode === &quot;filter&quot;) {
                    // we check whether current variable has been declared
                    if (use(v)) {
                        // if not we warn about it
                        state.funct[&quot;(scope)&quot;].block.use(v, state.tokens.curr);
                    }
                    return true;
                }
                return false;
            }
        };
    };


    // Parse JSON

    function jsonValue() {
        function jsonObject() {
            var o = {}, t = state.tokens.next;
            advance(&quot;{&quot;);
            if (state.tokens.next.id !== &quot;}&quot;) {
                for (; ;) {
                    if (state.tokens.next.id === &quot;(end)&quot;) {
                        error(&quot;E026&quot;, state.tokens.next, t.line);
                    } else if (state.tokens.next.id === &quot;}&quot;) {
                        warning(&quot;W094&quot;, state.tokens.curr);
                        break;
                    } else if (state.tokens.next.id === &quot;,&quot;) {
                        error(&quot;E028&quot;, state.tokens.next);
                    } else if (state.tokens.next.id !== &quot;(string)&quot;) {
                        warning(&quot;W095&quot;, state.tokens.next, state.tokens.next.value);
                    }
                    if (o[state.tokens.next.value] === true) {
                        warning(&quot;W075&quot;, state.tokens.next, &quot;key&quot;, state.tokens.next.value);
                    } else if ((state.tokens.next.value === &quot;__proto__&quot; &amp;&amp;
                        !state.option.proto) || (state.tokens.next.value === &quot;__iterator__&quot; &amp;&amp;
                            !state.option.iterator)) {
                        warning(&quot;W096&quot;, state.tokens.next, state.tokens.next.value);
                    } else {
                        o[state.tokens.next.value] = true;
                    }
                    advance();
                    advance(&quot;:&quot;);
                    jsonValue();
                    if (state.tokens.next.id !== &quot;,&quot;) {
                        break;
                    }
                    advance(&quot;,&quot;);
                }
            }
            advance(&quot;}&quot;);
        }

        function jsonArray() {
            var t = state.tokens.next;
            advance(&quot;[&quot;);
            if (state.tokens.next.id !== &quot;]&quot;) {
                for (; ;) {
                    if (state.tokens.next.id === &quot;(end)&quot;) {
                        error(&quot;E027&quot;, state.tokens.next, t.line);
                    } else if (state.tokens.next.id === &quot;]&quot;) {
                        warning(&quot;W094&quot;, state.tokens.curr);
                        break;
                    } else if (state.tokens.next.id === &quot;,&quot;) {
                        error(&quot;E028&quot;, state.tokens.next);
                    }
                    jsonValue();
                    if (state.tokens.next.id !== &quot;,&quot;) {
                        break;
                    }
                    advance(&quot;,&quot;);
                }
            }
            advance(&quot;]&quot;);
        }

        switch (state.tokens.next.id) {
            case &quot;{&quot;:
                jsonObject();
                break;
            case &quot;[&quot;:
                jsonArray();
                break;
            case &quot;true&quot;:
            case &quot;false&quot;:
            case &quot;null&quot;:
            case &quot;(number)&quot;:
            case &quot;(string)&quot;:
                advance();
                break;
            case &quot;-&quot;:
                advance(&quot;-&quot;);
                advance(&quot;(number)&quot;);
                break;
            default:
                error(&quot;E003&quot;, state.tokens.next);
        }
    }

    var escapeRegex = function(str) {
        return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, &quot;\\$&amp;&quot;);
    };

    // The actual JSHINT function itself.
    var itself: any = function(s, o: JSHintOptions, g) {
        var i, k, x, reIgnoreStr, reIgnore;
        var optionKeys: string[];
        var newOptionObj = {};
        var newIgnoredObj: { [something: string]: boolean } = {};

        o = clone(o);
        state.reset();

        if (o &amp;&amp; o.scope) {
            JSHINT.scope = o.scope;
        } else {
            JSHINT.errors = [];
            JSHINT.undefs = [];
            JSHINT.internals = [];
            JSHINT.blacklist = {};
            JSHINT.scope = &quot;(main)&quot;;
        }

        predefined = Object.create(null);
        combine(predefined, ecmaIdentifiers[3]);
        combine(predefined, reservedVars);

        combine(predefined, g || {});

        declared = Object.create(null);
        var exported = Object.create(null); // Variables that live outside the current file

        if (o) {
            each(o.predef || null, function(item: any) {
                var slice, prop;

                if (item[0] === &quot;-&quot;) {
                    slice = item.slice(1);
                    JSHINT.blacklist[slice] = slice;
                    // remove from predefined if there
                    delete predefined[slice];
                }
                else {
                    prop = Object.getOwnPropertyDescriptor(o.predef, item);
                    predefined[item] = prop ? prop.value : false;
                }
            });

            each(o.exported || null, function(item: string) {
                exported[item] = true;
            });

            delete o.predef;
            delete o.exported;

            optionKeys = Object.keys(o);
            for (x = 0; x &lt; optionKeys.length; x++) {
                if (/^-W\d{3}$/g.test(optionKeys[x])) {
                    newIgnoredObj[optionKeys[x].slice(1)] = true;
                } else {
                    var optionKey = optionKeys[x];
                    newOptionObj[optionKey] = o[optionKey];
                    if ((optionKey === &quot;esversion&quot; &amp;&amp; o[optionKey] === 5) ||
                        (optionKey === &quot;es5&quot; &amp;&amp; o[optionKey])) {
                        warningAt(&quot;I003&quot;, 0, 0);
                    }
                }
            }
        }

        state.option = newOptionObj;
        state.ignored = newIgnoredObj;

        state.option.indent = state.option.indent || 4;
        state.option.maxerr = state.option.maxerr || 50;

        indent = 1;

        var scopeManagerInst = scopeManager(state, predefined, exported, declared);
        scopeManagerInst.on(&quot;warning&quot;, function(ev) {
            warning.apply(null, [ev.code, ev.token].concat(ev.data));
        });

        scopeManagerInst.on(&quot;error&quot;, function(ev) {
            error.apply(null, [ev.code, ev.token].concat(ev.data));
        });

        state.funct = functor(&quot;(global)&quot;, null, {
            &quot;(global)&quot;: true,
            &quot;(scope)&quot;: scopeManagerInst,
            &quot;(comparray)&quot;: arrayComprehension(),
            &quot;(metrics)&quot;: createMetrics(state.tokens.next)
        });

        functions = [state.funct];
        urls = [];
        stack = null;
        member = {};
        membersOnly = null;
        inblock = false;
        lookahead = [];

        if (!isString(s) &amp;&amp; !Array.isArray(s)) {
            errorAt(&quot;E004&quot;, 0);
            return false;
        }

        api = {
            get isJSON() {
                return state.jsonMode;
            },

            getOption: function(name) {
                return state.option[name] || null;
            },

            getCache: function(name) {
                return state.cache[name];
            },

            setCache: function(name, value) {
                state.cache[name] = value;
            },

            warn: function(code, data) {
                warningAt.apply(null, [code, data.line, data.char].concat(data.data));
            },

            on: function(names, listener) {
                names.split(&quot; &quot;).forEach(function(name) {
                    emitter.on(name, listener);
                }.bind(this));
            }
        };

        emitter.removeAllListeners();
        (extraModules || []).forEach(function(func) {
            func(api);
        });

        state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax[&quot;(begin)&quot;];

        if (o &amp;&amp; o.ignoreDelimiters) {

            if (!Array.isArray(o.ignoreDelimiters)) {
                o.ignoreDelimiters = [o.ignoreDelimiters];
            }

            o.ignoreDelimiters.forEach(function(delimiterPair) {
                if (!delimiterPair.start || !delimiterPair.end)
                    return;

                reIgnoreStr = escapeRegex(delimiterPair.start) +
                    &quot;[\\s\\S]*?&quot; +
                    escapeRegex(delimiterPair.end);

                reIgnore = new RegExp(reIgnoreStr, &quot;ig&quot;);

                s = s.replace(reIgnore, function(match) {
                    return match.replace(/./g, &quot; &quot;);
                });
            });
        }

        lex = new Lexer(s);

        lex.on(&quot;warning&quot;, function(ev) {
            warningAt.apply(null, [ev.code, ev.line, ev.character].concat(ev.data));
        });

        lex.on(&quot;error&quot;, function(ev) {
            errorAt.apply(null, [ev.code, ev.line, ev.character].concat(ev.data));
        });

        lex.on(&quot;fatal&quot;, function(ev) {
            quit(&quot;E041&quot;, ev);
        });

        lex.on(&quot;Identifier&quot;, function(ev) {
            emitter.emit(&quot;Identifier&quot;, ev);
        });

        lex.on(&quot;String&quot;, function(ev) {
            emitter.emit(&quot;String&quot;, ev);
        });

        lex.on(&quot;Number&quot;, function(ev) {
            emitter.emit(&quot;Number&quot;, ev);
        });

        lex.start();

        // Check options
        for (var name in o) {
            if (has(o, name)) {
                checkOption(name, state.tokens.curr);
            }
        }

        try {
            assume();

            // combine the passed globals after we&#x27;ve assumed all our options
            combine(predefined, g || {});

            //reset values
            comma[&#x27;first&#x27;] = true;

            advance();
            switch (state.tokens.next.id) {
                case &quot;{&quot;:
                case &quot;[&quot;:
                    destructuringAssignOrJsonValue();
                    break;
                default:
                    directives();

                    if (state.directive[&quot;use strict&quot;]) {
                        if (state.option.strict !== &quot;global&quot; &amp;&amp;
                            !((state.option.strict === true || !state.option.strict) &amp;&amp;
                                (state.option.globalstrict || state.option.module || state.option.node ||
                                    state.option.phantom || state.option.browserify))) {
                            warning(&quot;W097&quot;, state.tokens.prev);
                        }
                    }

                    statements();
            }

            if (state.tokens.next.id !== &quot;(end)&quot;) {
                quit(&quot;E041&quot;, state.tokens.curr);
            }

            state.funct[&quot;(scope)&quot;].unstack();

        }
        catch (err) {
            if (err &amp;&amp; err.name === &quot;JSHintError&quot;) {
                var nt = state.tokens.next || {};
                JSHINT.errors.push({
                    scope: &quot;(main)&quot;,
                    raw: err.raw,
                    code: err.code,
                    reason: err.reason,
                    line: err.line || nt.line,
                    character: err.character || nt.from
                }, null);
            } else {
                throw err;
            }
        }

        // Loop over the listed &quot;internals&quot;, and check them as well.

        if (JSHINT.scope === &quot;(main)&quot;) {
            o = o || {};

            for (i = 0; i &lt; JSHINT.internals.length; i += 1) {
                k = JSHINT.internals[i];
                o.scope = k.elem;
                itself(k.value, o, g);
            }
        }

        return JSHINT.errors.length === 0;
    };

    // Modules.
    itself.addModule = function(func) {
        extraModules.push(func);
    };

    itself.addModule(register);

    // Data summary.
    itself.data = function() {
        var data: {
            errors?;
            functions: any[];
            globals?;
            implieds?;
            json?: boolean;
            member?;
            options?;
            unused?;
            urls?;
        } = {
                functions: [],
                options: state.option
            };

        var fu, f, i, j, n, globals;

        if (itself.errors.length) {
            data.errors = itself.errors;
        }

        if (state.jsonMode) {
            data.json = true;
        }

        var impliedGlobals = state.funct[&quot;(scope)&quot;].getImpliedGlobals();
        if (impliedGlobals.length &gt; 0) {
            data.implieds = impliedGlobals;
        }

        if (urls.length &gt; 0) {
            data.urls = urls;
        }

        globals = state.funct[&quot;(scope)&quot;].getUsedOrDefinedGlobals();
        if (globals.length &gt; 0) {
            data.globals = globals;
        }

        for (i = 1; i &lt; functions.length; i += 1) {
            f = functions[i];
            fu = {};

            for (j = 0; j &lt; functionicity.length; j += 1) {
                fu[functionicity[j]] = [];
            }

            for (j = 0; j &lt; functionicity.length; j += 1) {
                if (fu[functionicity[j]].length === 0) {
                    delete fu[functionicity[j]];
                }
            }

            fu.name = f[&quot;(name)&quot;];
            fu.param = f[&quot;(params)&quot;];
            fu.line = f[&quot;(line)&quot;];
            fu.character = f[&quot;(character)&quot;];
            fu.last = f[&quot;(last)&quot;];
            fu.lastcharacter = f[&quot;(lastcharacter)&quot;];

            fu.metrics = {
                complexity: f[&quot;(metrics)&quot;].ComplexityCount,
                parameters: f[&quot;(metrics)&quot;].arity,
                statements: f[&quot;(metrics)&quot;].statementCount
            };

            data.functions.push(fu);
        }

        var unuseds = state.funct[&quot;(scope)&quot;].getUnuseds();
        if (unuseds.length &gt; 0) {
            data.unused = unuseds;
        }

        for (n in member) {
            if (typeof member[n] === &quot;number&quot;) {
                data.member = member;
                break;
            }
        }

        return data;
    };

    itself.jshint = itself;

    return itself;
} ());

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
