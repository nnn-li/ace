<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/autocomplete.ts - deuce</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../../assets/logo.png" title="deuce"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.16</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Anchor.html">Anchor</a></li>
                                <li><a href="../classes/BackgroundTokenizer.html">BackgroundTokenizer</a></li>
                                <li><a href="../classes/Editor.html">Editor</a></li>
                                <li><a href="../classes/EditorDocument.html">EditorDocument</a></li>
                                <li><a href="../classes/EditSession.html">EditSession</a></li>
                                <li><a href="../classes/Fold.html">Fold</a></li>
                                <li><a href="../classes/FoldLine.html">FoldLine</a></li>
                                <li><a href="../classes/GutterTooltip.html">GutterTooltip</a></li>
                                <li><a href="../classes/HScrollBar.html">HScrollBar</a></li>
                                <li><a href="../classes/HtmlMode.html">HtmlMode</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Mode.html">Mode</a></li>
                                <li><a href="../classes/Position.html">Position</a></li>
                                <li><a href="../classes/Range.html">Range</a></li>
                                <li><a href="../classes/ScrollBar.html">ScrollBar</a></li>
                                <li><a href="../classes/Search.html">Search</a></li>
                                <li><a href="../classes/Selection.html">Selection</a></li>
                                <li><a href="../classes/TokenIterator.html">TokenIterator</a></li>
                                <li><a href="../classes/Tokenizer.html">Tokenizer</a></li>
                                <li><a href="../classes/Tooltip.html">Tooltip</a></li>
                                <li><a href="../classes/UndoManager.html">UndoManager</a></li>
                                <li><a href="../classes/VirtualRenderer.html">VirtualRenderer</a></li>
                                <li><a href="../classes/VScrollBar.html">VScrollBar</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/autocomplete.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2012, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */

import HashHandler from &quot;./keyboard/HashHandler&quot;;
import {ListViewPopup} from &quot;./autocomplete/popup&quot;;
import {retrievePrecedingIdentifier} from &quot;./autocomplete/util&quot;;
import {} from &quot;./lib/event&quot;;
import {delayedCall} from &quot;./lib/lang&quot;;
import {snippetManager} from &quot;./snippets&quot;;
import Editor from &#x27;./Editor&#x27;;
import EditSession from &#x27;./EditSession&#x27;;
import Anchor from &#x27;./Anchor&#x27;;
import Range from &#x27;./Range&#x27;;

var EDITOR_EXT_COMPLETER = &#x27;completer&#x27;;

export interface Completer {
    getCompletions(editor: Editor, session: EditSession, pos: { row: number; column: number }, prefix: string, callback);
}

export function getCompleter(editor: Editor): CompleterAggregate {
    return editor[EDITOR_EXT_COMPLETER];
}

export function setCompleter(editor: Editor, completer: CompleterAggregate) {
    editor[EDITOR_EXT_COMPLETER] = completer;
}

export class CompleterAggregate implements Completer {
    private editor: Editor;
    private keyboardHandler = new HashHandler();
    public activated: boolean;
    private changeTimer;
    private gatherCompletionsId = 0;
    private base: Anchor;
    private completions: { filtered; filterText; setFilter };
    private commands: { [name: string]: (editor: Editor) =&gt; void };
    public autoSelect = true;
    public autoInsert = true;
    constructor(editor: Editor) {
        this.editor = editor;
        this.commands = {
            &quot;Up&quot;: function(editor: Editor) { getCompleter(editor).goTo(&quot;up&quot;); },
            &quot;Down&quot;: function(editor: Editor) { getCompleter(editor).goTo(&quot;down&quot;); },
            &quot;Ctrl-Up|Ctrl-Home&quot;: function(editor: Editor) { getCompleter(editor).goTo(&quot;start&quot;); },
            &quot;Ctrl-Down|Ctrl-End&quot;: function(editor: Editor) { getCompleter(editor).goTo(&quot;end&quot;); },

            &quot;Esc&quot;: function(editor: Editor) { getCompleter(editor).detach(); },
            &quot;Space&quot;: function(editor: Editor) { getCompleter(editor).detach(); editor.insert(&quot; &quot;); },
            &quot;Return&quot;: function(editor: Editor) { return getCompleter(editor).insertMatch(); },
            &quot;Shift-Return&quot;: function(editor: Editor) { getCompleter(editor).insertMatch(true); },
            &quot;Tab&quot;: function(editor: Editor) {
                var result = getCompleter(editor).insertMatch();
                if (!result &amp;&amp; !editor[&#x27;tabstopManager&#x27;]) {
                    getCompleter(editor).goTo(&quot;down&quot;);
                }
                else
                    return result;
            },

            &quot;PageUp&quot;: function(editor: Editor) { getCompleter(editor).goTo(&#x27;pageUp&#x27;); },
            &quot;PageDown&quot;: function(editor: Editor) { getCompleter(editor).goTo(&#x27;pageDown&#x27;); }
        };

        this.keyboardHandler.bindKeys(this.commands);

        this.blurListener = this.blurListener.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.mousedownListener = this.mousedownListener.bind(this);
        this.mousewheelListener = this.mousewheelListener.bind(this);

        this.changeTimer = delayedCall(function() { this.updateCompletions(true); }.bind(this));
    }
    public popup: ListViewPopup;

    /**
     * Implementation of the Completer interface.
     */
    public insertMatch(data?) {
        if (!data) {
            data = this.popup.getData(this.popup.getRow());
        }

        if (!data) {
            return;
        }

        if (data.completer &amp;&amp; data.completer.insertMatch) {
            data.completer.insertMatch(this.editor);
        }
        else {
            if (this.completions.filterText) {
                // FIXME: getAllRanges on Selection?
                var ranges: Range[] = this.editor.selection[&#x27;getAllRanges&#x27;]();
                // TODO: Assignment in conditional expression.
                // TODO: Assignment in conditional expression.
                // It&#x27;s cute but also may halt prematurely and so hide bugs.
                // Replace by length variable and test?
                // Use assertion within the loop to look for falsey values.
                for (var i = 0, range; range = ranges[i]; i++) {
                    range.start.column -= this.completions.filterText.length;
                    this.editor.getSession().remove(range);
                }
            }
            if (data.snippet) {
                snippetManager.insertSnippet(this.editor, data.snippet);
            }
            else {
                this.editor.execCommand(&quot;insertstring&quot;, data.value || data);
            }
        }
        this.detach();
    }

    /**
     * Implementation of the Completer interface.
     */
    public detach() {
        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
        this.editor.off(&quot;changeSelection&quot;, this.changeListener);
        this.editor.off(&quot;blur&quot;, this.blurListener);
        this.editor.off(&quot;mousedown&quot;, this.mousedownListener);
        this.editor.off(&quot;mousewheel&quot;, this.mousewheelListener);
        this.changeTimer.cancel();

        if (this.popup &amp;&amp; this.popup.isOpen) {
            this.gatherCompletionsId += 1;
            this.popup.hide();
        }

        if (this.base)
            this.base.detach();
        this.activated = false;
        this.completions = this.base = null;
    }

    /**
     * Implementation of the Completer interface.
     */
    public goTo(where: string) {
        var row = this.popup.getRow();
        var max = this.popup.getLength() - 1;

        switch (where) {
            case &quot;up&quot;: row = row &lt;= 0 ? max : row - 1; break;
            case &quot;down&quot;: row = row &gt;= max ? -1 : row + 1; break;
            case &quot;start&quot;: row = 0; break;
            case &quot;end&quot;: row = max; break;
        }

        this.popup.setRow(row);
    }

    /**
     * Implementation of the Completer interface.
     */
    public getCompletions(editor: Editor, session: EditSession, pos: { row: number; column: number }, prefix: string, callback) {

        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);

        var matches = [];
        var total = editor.completers.length;
        editor.completers.forEach(function(completer: Completer, i) {
            completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (!err)
                    matches = matches.concat(results);
                // Fetch prefix again, because they may have changed by now
                var pos: { row: number; column: number } = editor.getCursorPosition();
                var line = session.getLine(pos.row);
                callback(null, {
                    prefix: retrievePrecedingIdentifier(line, pos.column, results[0] &amp;&amp; results[0].identifierRegex),
                    matches: matches,
                    finished: (--total === 0)
                });
            });
        });
        return true;
    }

    private updateCompletions(keepPopupPosition: boolean): void {
        var pos = this.editor.getCursorPosition();
        var prefix: string;
        if (keepPopupPosition &amp;&amp; this.base &amp;&amp; this.completions) {
            var range = new Range(this.base.row, this.base.column, pos.row, pos.column);
            prefix = this.editor.getSession().getTextRange(range);
            if (prefix == this.completions.filterText)
                return;
            this.completions.setFilter(prefix);
            if (!this.completions.filtered.length)
                return this.detach();

            if (this.completions.filtered.length == 1 &amp;&amp; this.completions.filtered[0].value == prefix &amp;&amp; !this.completions.filtered[0].snippet) {
                return this.detach();
            }

            this.openPopup(this.editor, prefix, keepPopupPosition);
        }
        else {
            // Save current gatherCompletions session, session is close when a match is insert
            var _id = this.gatherCompletionsId;
            var editor = this.editor;
            var session = editor.getSession();
            var line = session.getLine(pos.row);
            prefix = retrievePrecedingIdentifier(line, pos.column);
            this.getCompletions(this.editor, session, this.editor.getCursorPosition(), prefix, function(err, results) {
                // Only detach if result gathering is finished
                var detachIfFinished = function() {
                    if (!results.finished) return;
                    return this.detach();
                }.bind(this);

                var prefix = results.prefix;
                var matches = results &amp;&amp; results.matches;

                if (!matches || !matches.length)
                    return detachIfFinished();
    
                // Wrong prefix or wrong session -&gt; ignore
                if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)
                    return;

                this.completions = new FilteredList(matches);
                this.completions.setFilter(prefix);
                var filtered = this.completions.filtered;
    
                // No results
                if (!filtered.length)
                    return detachIfFinished();
    
                // One result equals to the prefix
                if (filtered.length == 1 &amp;&amp; filtered[0].value == prefix &amp;&amp; !filtered[0].snippet)
                    return detachIfFinished();
    
                // Autoinsert if one result
                if (this.autoInsert &amp;&amp; filtered.length == 1)
                    return this.insertMatch(filtered[0]);

                this.openPopup(this.editor, prefix, keepPopupPosition);
            }.bind(this));
        }
    }

    private openPopup(editor: Editor, prefix: string, keepPopupPosition: boolean) {
        if (!this.popup) {
            this.popup = new ListViewPopup(document.body || document.documentElement);
            this.popup.on(&quot;click&quot;, function(e) { this.insertMatch(); e.stop(); }.bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
        }

        this.popup.setData(this.completions.filtered);

        this.popup.setRow(this.autoSelect ? 0 : -1);

        if (!keepPopupPosition) {
            this.popup.setTheme(editor.getTheme());
            this.popup.setFontSize(editor.getFontSize());

            var lineHeight = editor.renderer.layerConfig.lineHeight;

            var pos: { left: number; top: number } = editor.renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();

            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - editor.renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += editor.renderer.$gutterLayer.gutterWidth;

            this.popup.show(pos, lineHeight);
        }
    }

    private changeListener(e) {
        var cursor = this.editor.selection.lead;
        if (cursor.row != this.base.row || cursor.column &lt; this.base.column) {
            this.detach();
        }
        if (this.activated)
            this.changeTimer.schedule();
        else
            this.detach();
    }

    private blurListener() {
        // we have to check if activeElement is a child of popup because
        // on IE preventDefault doesn&#x27;t stop scrollbar from being focussed
        var el = document.activeElement;
        if (el != this.editor.textInput.getElement() &amp;&amp; el.parentNode != this.popup.container) {
            this.detach();
        }
    }

    private mousedownListener(e) {
        this.detach();
    }

    private mousewheelListener(e) {
        this.detach();
    }

    public showPopup = function(editor: Editor) {

        if (this.editor) {
            this.detach();
        }

        this.activated = true;

        this.editor = editor;

        if (getCompleter(editor) != this) {
            if (getCompleter(editor)) {
                getCompleter(editor).detach();
            }
            setCompleter(editor, this);
        }

        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        editor.on(&quot;changeSelection&quot;, this.changeListener);
        editor.on(&quot;blur&quot;, this.blurListener);
        editor.on(&quot;mousedown&quot;, this.mousedownListener);
        editor.on(&quot;mousewheel&quot;, this.mousewheelListener);

        this.updateCompletions();
    }
    public cancelContextMenu() {
        this.editor.cancelMouseContextMenu();
    }
}

// TODO: Should we implement Completer or is it really just implementation?
export class Autocomplete {
    static startCommand = {
        name: &quot;startAutocomplete&quot;,
        exec: function(editor: Editor) {
            var aggregate: CompleterAggregate = getCompleter(editor);
            if (!aggregate) {
                aggregate = new CompleterAggregate(editor);
                setCompleter(editor, aggregate);
            }
            aggregate.autoInsert = true;
            aggregate.autoSelect = true;
            aggregate.showPopup(editor);
            // needed for firefox on mac
            aggregate.cancelContextMenu();
        },
        bindKey: &quot;Ctrl-Space|Ctrl-Shift-Space|Alt-Space&quot;
    };
}

export class FilteredList {
    private all;
    private filtered;
    private filterText: string;
    constructor(all, filterText?: string, mutateData?) {
        this.all = all;
        this.filtered = all;
        this.filterText = filterText || &quot;&quot;;
    }
    private setFilter(str) {
        var matches;
        if (str.length &gt; this.filterText &amp;&amp; str.lastIndexOf(this.filterText, 0) === 0)
            matches = this.filtered;
        else
            matches = this.all;

        this.filterText = str;
        matches = this.filterCompletions(matches, this.filterText);
        matches = matches.sort(function(a, b) {
            return b.exactMatch - a.exactMatch || b.score - a.score;
        });

        // make unique
        var prev = null;
        matches = matches.filter(function(item) {
            var caption = item.value || item.caption || item.snippet;
            if (caption === prev) return false;
            prev = caption;
            return true;
        });

        this.filtered = matches;
    }
    private filterCompletions(items: { caption; value; snippet }[], needle: string) {
        var results = [];
        var upper = needle.toUpperCase();
        var lower = needle.toLowerCase();
        // TODO: Assignment in conditional expression.
        // It&#x27;s cute but also may halt prematurely and so hide bugs.
        // Replace by length variable and test?
        // Use assertion within the loop to look for falsey values.
        loop: for (var i = 0, length = items.length; i &lt; length; i++) {
            var item: any = items[i];
            var caption = item.value || item.caption || item.snippet;
            if (!caption) continue;
            var lastIndex = -1;
            var matchMask = 0;
            var penalty = 0;
            var index, distance;
            // caption char iteration is faster in Chrome but slower in Firefox, so lets use indexOf
            for (var j = 0; j &lt; needle.length; j++) {
                // TODO add penalty on case mismatch
                var i1 = caption.indexOf(lower[j], lastIndex + 1);
                var i2 = caption.indexOf(upper[j], lastIndex + 1);
                index = (i1 &gt;= 0) ? ((i2 &lt; 0 || i1 &lt; i2) ? i1 : i2) : i2;
                if (index &lt; 0)
                    continue loop;
                distance = index - lastIndex - 1;
                if (distance &gt; 0) {
                    // first char mismatch should be more sensitive
                    if (lastIndex === -1)
                        penalty += 10;
                    penalty += distance;
                }
                matchMask = matchMask | (1 &lt;&lt; index);
                lastIndex = index;
            }
            item.matchMask = matchMask;
            item.exactMatch = penalty ? 0 : 1;
            item.score = (item.score || 0) - penalty;
            results.push(item);
        }
        return results;
    }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
