// Do NOT MODIFY. File automatically generated by asdl_ts.py.

// ----------------------
// operator functions
// ----------------------

export class Load {}
export class Store {}
export class Del {}
export class AugLoad {}
export class AugStore {}
export class Param {}

export class And {}
export class Or {}

export class Add {}
export class Sub {}
export class Mult {}
export class Div {}
export class Mod {}
export class Pow {}
export class LShift {}
export class RShift {}
export class BitOr {}
export class BitXor {}
export class BitAnd {}
export class FloorDiv {}

export class Invert {}
export class Not {}
export class UAdd {}
export class USub {}

export class Eq {}
export class NotEq {}
export class Lt {}
export class LtE {}
export class Gt {}
export class GtE {}
export class Is {}
export class IsNot {}
export class In_ {}
export class NotIn {}


// ----------------------
// productions
// ----------------------

export interface mod {}
export interface stmt {
  lineno: number;
  col_offset: number;
}
export interface expr {
  lineno: number;
  col_offset: number;
}
export interface expr_context {}
export interface slice {}
export interface boolop {}
export interface operator {}
export interface unaryop {}
export interface cmpop {}
export interface comprehension {}
export interface excepthandler {}
export interface arguments_ {}
export interface keyword {}
export interface alias {}

// ----------------------
// constructors for nodes
// ----------------------

export class Module implements mod
{
  public body:stmt[];
  constructor(body:stmt[])
  {
    this.body = body;
  }
}

export class Interactive implements mod
{
  public body:stmt[];
  constructor(body:stmt[])
  {
    this.body = body;
  }
}

export class Expression implements mod
{
  public body:expr;
  constructor(body:expr)
  {
    this.body = body;
  }
}

export class Suite implements mod
{
  public body:stmt[];
  constructor(body:stmt[])
  {
    this.body = body;
  }
}

export class FunctionDef implements stmt
{
  public name:string;
  public args:arguments_;
  public body:stmt[];
  public decorator_list:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(name:string, args:arguments_, body:stmt[], decorator_list:expr[], lineno:number, col_offset:number)
  {
    this.name = name;
    this.args = args;
    this.body = body;
    this.decorator_list = decorator_list;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class ClassDef implements stmt
{
  public name:string;
  public bases:expr[];
  public body:stmt[];
  public decorator_list:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(name:string, bases:expr[], body:stmt[], decorator_list:expr[], lineno:number, col_offset:number)
  {
    this.name = name;
    this.bases = bases;
    this.body = body;
    this.decorator_list = decorator_list;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Return_ implements stmt
{
  public value:expr;
  public lineno:number;
  public col_offset:number;
  constructor(value:expr, lineno:number, col_offset:number)
  {
    this.value = value;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Delete_ implements stmt
{
  public targets:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(targets:expr[], lineno:number, col_offset:number)
  {
    this.targets = targets;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Assign implements stmt
{
  public targets:expr[];
  public value:expr;
  public lineno:number;
  public col_offset:number;
  constructor(targets:expr[], value:expr, lineno:number, col_offset:number)
  {
    this.targets = targets;
    this.value = value;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class AugAssign implements stmt
{
  public target:expr;
  public op:operator;
  public value:expr;
  public lineno:number;
  public col_offset:number;
  constructor(target:expr, op:operator, value:expr, lineno:number, col_offset:number)
  {
    this.target = target;
    this.op = op;
    this.value = value;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Print implements stmt
{
  public dest:expr;
  public values:expr[];
  public nl:boolean;
  public lineno:number;
  public col_offset:number;
  constructor(dest:expr, values:expr[], nl:boolean, lineno:number, col_offset:number)
  {
    this.dest = dest;
    this.values = values;
    this.nl = nl;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class For_ implements stmt
{
  public target:expr;
  public iter:expr;
  public body:stmt[];
  public orelse:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(target:expr, iter:expr, body:stmt[], orelse:stmt[], lineno:number, col_offset:number)
  {
    this.target = target;
    this.iter = iter;
    this.body = body;
    this.orelse = orelse;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class While_ implements stmt
{
  public test:expr;
  public body:stmt[];
  public orelse:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(test:expr, body:stmt[], orelse:stmt[], lineno:number, col_offset:number)
  {
    this.test = test;
    this.body = body;
    this.orelse = orelse;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class If_ implements stmt
{
  public test:expr;
  public body:stmt[];
  public orelse:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(test:expr, body:stmt[], orelse:stmt[], lineno:number, col_offset:number)
  {
    this.test = test;
    this.body = body;
    this.orelse = orelse;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class With_ implements stmt
{
  public context_expr:expr;
  public optional_vars:expr;
  public body:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(context_expr:expr, optional_vars:expr, body:stmt[], lineno:number, col_offset:number)
  {
    this.context_expr = context_expr;
    this.optional_vars = optional_vars;
    this.body = body;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Raise implements stmt
{
  public type:expr;
  public inst:expr;
  public tback:expr;
  public lineno:number;
  public col_offset:number;
  constructor(type:expr, inst:expr, tback:expr, lineno:number, col_offset:number)
  {
    this.type = type;
    this.inst = inst;
    this.tback = tback;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class TryExcept implements stmt
{
  public body:stmt[];
  public handlers:excepthandler[];
  public orelse:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(body:stmt[], handlers:excepthandler[], orelse:stmt[], lineno:number, col_offset:number)
  {
    this.body = body;
    this.handlers = handlers;
    this.orelse = orelse;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class TryFinally implements stmt
{
  public body:stmt[];
  public finalbody:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(body:stmt[], finalbody:stmt[], lineno:number, col_offset:number)
  {
    this.body = body;
    this.finalbody = finalbody;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Assert implements stmt
{
  public test:expr;
  public msg:expr;
  public lineno:number;
  public col_offset:number;
  constructor(test:expr, msg:expr, lineno:number, col_offset:number)
  {
    this.test = test;
    this.msg = msg;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Import_ implements stmt
{
  public names:alias[];
  public lineno:number;
  public col_offset:number;
  constructor(names:alias[], lineno:number, col_offset:number)
  {
    this.names = names;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class ImportFrom implements stmt
{
  public module:string;
  public names:alias[];
  public level:number;
  public lineno:number;
  public col_offset:number;
  constructor(module:string, names:alias[], level:number, lineno:number, col_offset:number)
  {
    this.module = module;
    this.names = names;
    this.level = level;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Exec implements stmt
{
  public body:expr;
  public globals:expr;
  public locals:expr;
  public lineno:number;
  public col_offset:number;
  constructor(body:expr, globals:expr, locals:expr, lineno:number, col_offset:number)
  {
    this.body = body;
    this.globals = globals;
    this.locals = locals;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Global implements stmt
{
  public names:string[];
  public lineno:number;
  public col_offset:number;
  constructor(names:string[], lineno:number, col_offset:number)
  {
    this.names = names;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class NonLocal implements stmt
{
  public names:string[];
  public lineno:number;
  public col_offset:number;
  constructor(names:string[], lineno:number, col_offset:number)
  {
    this.names = names;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Expr implements stmt
{
  public value:expr;
  public lineno:number;
  public col_offset:number;
  constructor(value:expr, lineno:number, col_offset:number)
  {
    this.value = value;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Pass implements stmt
{
  public lineno:number;
  public col_offset:number;
  constructor(lineno:number, col_offset:number)
  {
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Break_ implements stmt
{
  public lineno:number;
  public col_offset:number;
  constructor(lineno:number, col_offset:number)
  {
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Continue_ implements stmt
{
  public lineno:number;
  public col_offset:number;
  constructor(lineno:number, col_offset:number)
  {
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class BoolOp implements expr
{
  public op:boolop;
  public values:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(op:boolop, values:expr[], lineno:number, col_offset:number)
  {
    this.op = op;
    this.values = values;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class BinOp implements expr
{
  public left:expr;
  public op:operator;
  public right:expr;
  public lineno:number;
  public col_offset:number;
  constructor(left:expr, op:operator, right:expr, lineno:number, col_offset:number)
  {
    this.left = left;
    this.op = op;
    this.right = right;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class UnaryOp implements expr
{
  public op:unaryop;
  public operand:expr;
  public lineno:number;
  public col_offset:number;
  constructor(op:unaryop, operand:expr, lineno:number, col_offset:number)
  {
    this.op = op;
    this.operand = operand;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Lambda implements expr
{
  public args:arguments_;
  public body:expr;
  public lineno:number;
  public col_offset:number;
  constructor(args:arguments_, body:expr, lineno:number, col_offset:number)
  {
    this.args = args;
    this.body = body;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class IfExp implements expr
{
  public test:expr;
  public body:expr;
  public orelse:expr;
  public lineno:number;
  public col_offset:number;
  constructor(test:expr, body:expr, orelse:expr, lineno:number, col_offset:number)
  {
    this.test = test;
    this.body = body;
    this.orelse = orelse;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Dict implements expr
{
  public keys:expr[];
  public values:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(keys:expr[], values:expr[], lineno:number, col_offset:number)
  {
    this.keys = keys;
    this.values = values;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class ListComp implements expr
{
  public elt:expr;
  public generators:comprehension[];
  public lineno:number;
  public col_offset:number;
  constructor(elt:expr, generators:comprehension[], lineno:number, col_offset:number)
  {
    this.elt = elt;
    this.generators = generators;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class GeneratorExp implements expr
{
  public elt:expr;
  public generators:comprehension[];
  public lineno:number;
  public col_offset:number;
  constructor(elt:expr, generators:comprehension[], lineno:number, col_offset:number)
  {
    this.elt = elt;
    this.generators = generators;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Yield implements expr
{
  public value:expr;
  public lineno:number;
  public col_offset:number;
  constructor(value:expr, lineno:number, col_offset:number)
  {
    this.value = value;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Compare implements expr
{
  public left:expr;
  public ops:cmpop[];
  public comparators:expr[];
  public lineno:number;
  public col_offset:number;
  constructor(left:expr, ops:cmpop[], comparators:expr[], lineno:number, col_offset:number)
  {
    this.left = left;
    this.ops = ops;
    this.comparators = comparators;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Call implements expr
{
  public func:expr;
  public args:expr[];
  public keywords:keyword[];
  public starargs:expr;
  public kwargs:expr;
  public lineno:number;
  public col_offset:number;
  constructor(func:expr, args:expr[], keywords:keyword[], starargs:expr, kwargs:expr, lineno:number, col_offset:number)
  {
    this.func = func;
    this.args = args;
    this.keywords = keywords;
    this.starargs = starargs;
    this.kwargs = kwargs;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Num implements expr
{
  public n:any;
  public lineno:number;
  public col_offset:number;
  constructor(n:any, lineno:number, col_offset:number)
  {
    this.n = n;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Str implements expr
{
  public s:string;
  public lineno:number;
  public col_offset:number;
  constructor(s:string, lineno:number, col_offset:number)
  {
    this.s = s;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Attribute implements expr
{
  public value:expr;
  public attr:string;
  public ctx:expr_context;
  public lineno:number;
  public col_offset:number;
  constructor(value:expr, attr:string, ctx:expr_context, lineno:number, col_offset:number)
  {
    this.value = value;
    this.attr = attr;
    this.ctx = ctx;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Subscript implements expr
{
  public value:expr;
  public slice:slice;
  public ctx:expr_context;
  public lineno:number;
  public col_offset:number;
  constructor(value:expr, slice:slice, ctx:expr_context, lineno:number, col_offset:number)
  {
    this.value = value;
    this.slice = slice;
    this.ctx = ctx;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Name implements expr
{
  public id:string;
  public ctx:expr_context;
  public lineno:number;
  public col_offset:number;
  constructor(id:string, ctx:expr_context, lineno:number, col_offset:number)
  {
    this.id = id;
    this.ctx = ctx;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class List implements expr
{
  public elts:expr[];
  public ctx:expr_context;
  public lineno:number;
  public col_offset:number;
  constructor(elts:expr[], ctx:expr_context, lineno:number, col_offset:number)
  {
    this.elts = elts;
    this.ctx = ctx;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Tuple implements expr
{
  public elts:expr[];
  public ctx:expr_context;
  public lineno:number;
  public col_offset:number;
  constructor(elts:expr[], ctx:expr_context, lineno:number, col_offset:number)
  {
    this.elts = elts;
    this.ctx = ctx;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Ellipsis implements slice
{
  constructor()
  {
  }
}

export class Slice implements slice
{
  public lower:expr;
  public upper:expr;
  public step:expr;
  constructor(lower:expr, upper:expr, step:expr)
  {
    this.lower = lower;
    this.upper = upper;
    this.step = step;
  }
}

export class ExtSlice implements slice
{
  public dims:slice[];
  constructor(dims:slice[])
  {
    this.dims = dims;
  }
}

export class Index implements slice
{
  public value:expr;
  constructor(value:expr)
  {
    this.value = value;
  }
}

export class Comprehension implements comprehension
{
  public target:expr;
  public iter:expr;
  public ifs:expr[];
  constructor(target:expr, iter:expr, ifs:expr[])
  {
    this.target = target;
    this.iter = iter;
    this.ifs = ifs;
  }
}

export class ExceptHandler implements excepthandler
{
  public type:expr;
  public name:expr;
  public body:stmt[];
  public lineno:number;
  public col_offset:number;
  constructor(type:expr, name:expr, body:stmt[], lineno:number, col_offset:number)
  {
    this.type = type;
    this.name = name;
    this.body = body;
    this.lineno = lineno;
    this.col_offset = col_offset;
  }
}

export class Arguments implements arguments_
{
  public args:expr[];
  public vararg:string;
  public kwarg:string;
  public defaults:expr[];
  constructor(args:expr[], vararg:string, kwarg:string, defaults:expr[])
  {
    this.args = args;
    this.vararg = vararg;
    this.kwarg = kwarg;
    this.defaults = defaults;
  }
}

export class Keyword implements keyword
{
  public arg:string;
  public value:expr;
  constructor(arg:string, value:expr)
  {
    this.arg = arg;
    this.value = value;
  }
}

export class Alias implements alias
{
  public name:string;
  public asname:string;
  constructor(name:string, asname:string)
  {
    this.name = name;
    this.asname = asname;
  }
}




