System.registerDynamic("npm:core-js@1.2.6/library/fn/object/define-properties", ["npm:core-js@1.2.6/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  module.exports = function defineProperties(T, D) {
    return $.setDescs(T, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/define-properties", ["npm:core-js@1.2.6/library/fn/object/define-properties"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/define-properties'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("src/keyboard/KeyBinding.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/keys.js", "src/lib/event.js"], function (_export) {
    var _createClass, _classCallCheck, keyCodeToString, stopEvent, KeyBinding;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibKeysJs) {
            keyCodeToString = _srcLibKeysJs.keyCodeToString;
        }, function (_srcLibEventJs) {
            stopEvent = _srcLibEventJs.stopEvent;
        }],
        execute: function () {
            "use strict";

            KeyBinding = (function () {
                function KeyBinding(editor) {
                    _classCallCheck(this, KeyBinding);

                    this.$editor = editor;
                    this.$data = { editor: editor };
                    this.$handlers = [];
                    this.setDefaultHandler(editor.commands);
                }

                _createClass(KeyBinding, [{
                    key: "setDefaultHandler",
                    value: function setDefaultHandler(kb) {
                        this.removeKeyboardHandler(this.$defaultHandler);
                        this.$defaultHandler = kb;
                        this.addKeyboardHandler(kb, 0);
                    }
                }, {
                    key: "setKeyboardHandler",
                    value: function setKeyboardHandler(kb) {
                        var h = this.$handlers;
                        if (h[h.length - 1] === kb) return;
                        while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler) this.removeKeyboardHandler(h[h.length - 1]);
                        this.addKeyboardHandler(kb, 1);
                    }
                }, {
                    key: "addKeyboardHandler",
                    value: function addKeyboardHandler(kb, pos) {
                        if (!kb) {
                            return;
                        }
                        if (typeof kb === "function" && !kb.handleKeyboard) {
                            kb.handleKeyboard = kb;
                        }
                        var i = this.$handlers.indexOf(kb);
                        if (i !== -1) {
                            this.$handlers.splice(i, 1);
                        }
                        if (pos === void 0) {
                            this.$handlers.push(kb);
                        } else {
                            this.$handlers.splice(pos, 0, kb);
                        }
                        if (i === -1 && kb.attach) {
                            kb.attach(this.$editor);
                        }
                    }
                }, {
                    key: "removeKeyboardHandler",
                    value: function removeKeyboardHandler(kb) {
                        var i = this.$handlers.indexOf(kb);
                        if (i === -1) {
                            return false;
                        }
                        this.$handlers.splice(i, 1);
                        kb.detach && kb.detach(this.$editor);
                        return true;
                    }
                }, {
                    key: "getKeyboardHandler",
                    value: function getKeyboardHandler() {
                        return this.$handlers[this.$handlers.length - 1];
                    }
                }, {
                    key: "$callKeyboardHandlers",
                    value: function $callKeyboardHandlers(hashId, keyString, keyCode, e) {
                        var toExecute;
                        var success = false;
                        var commands = this.$editor.commands;
                        for (var i = this.$handlers.length; i--;) {
                            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                            if (!toExecute || !toExecute.command) continue;
                            if (toExecute.command == "null") {
                                success = true;
                            } else {
                                success = commands.exec(toExecute.command, this.$editor, toExecute.args);
                            }
                            if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                                stopEvent(e);
                            }
                            if (success) break;
                        }
                        return success;
                    }
                }, {
                    key: "onCommandKey",
                    value: function onCommandKey(e, hashId, keyCode) {
                        var keyString = keyCodeToString(keyCode);
                        this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
                    }
                }, {
                    key: "onTextInput",
                    value: function onTextInput(text) {
                        var success = this.$callKeyboardHandlers(-1, text);
                        if (!success) {
                            this.$editor.commands.exec("insertstring", this.$editor, text);
                        }
                    }
                }]);

                return KeyBinding;
            })();

            _export("default", KeyBinding);
        }
    };
});
System.register("src/keyboard/TextInput.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/event.js", "src/lib/useragent.js", "src/lib/dom.js", "src/lib/lang.js"], function (_export) {
    var _createClass, _classCallCheck, addCommandKeyListener, addListener, capture, preventDefault, isChrome, isGecko, isIE, isMac, isOldIE, isTouchPad, isWebKit, isWin, createElement, delayedCall, BROKEN_SETDATA, USE_IE_MIME_TYPE, TextInput;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibEventJs) {
            addCommandKeyListener = _srcLibEventJs.addCommandKeyListener;
            addListener = _srcLibEventJs.addListener;
            capture = _srcLibEventJs.capture;
            preventDefault = _srcLibEventJs.preventDefault;
        }, function (_srcLibUseragentJs) {
            isChrome = _srcLibUseragentJs.isChrome;
            isGecko = _srcLibUseragentJs.isGecko;
            isIE = _srcLibUseragentJs.isIE;
            isMac = _srcLibUseragentJs.isMac;
            isOldIE = _srcLibUseragentJs.isOldIE;
            isTouchPad = _srcLibUseragentJs.isTouchPad;
            isWebKit = _srcLibUseragentJs.isWebKit;
            isWin = _srcLibUseragentJs.isWin;
        }, function (_srcLibDomJs) {
            createElement = _srcLibDomJs.createElement;
        }, function (_srcLibLangJs) {
            delayedCall = _srcLibLangJs.delayedCall;
        }],
        execute: function () {
            "use strict";
            BROKEN_SETDATA = isChrome < 18;
            USE_IE_MIME_TYPE = isIE;

            TextInput = (function () {
                function TextInput(container, editor) {
                    _classCallCheck(this, TextInput);

                    var text = createElement("textarea");
                    text.className = "ace_text-input";
                    if (isTouchPad) {
                        text.setAttribute("x-palm-disable-auto-cap", 'true');
                    }
                    text.wrap = "off";
                    text['autocorrect'] = "off";
                    text['autocapitalize'] = "off";
                    text.spellcheck = false;
                    text.style.opacity = "0";
                    container.insertBefore(text, container.firstChild);
                    var PLACEHOLDER = "\x01\x01";
                    var copied = false;
                    var pasted = false;
                    var inComposition = false;
                    var tempStyle = '';
                    var isSelectionEmpty = true;
                    try {
                        var isFocused = document.activeElement === text;
                    } catch (e) {}
                    addListener(text, "blur", function () {
                        editor.onBlur();
                        isFocused = false;
                    });
                    addListener(text, "focus", function () {
                        isFocused = true;
                        editor.onFocus();
                        resetSelection();
                    });
                    this.focus = function () {
                        text.focus();
                    };
                    this.blur = function () {
                        text.blur();
                    };
                    this.isFocused = function () {
                        return isFocused;
                    };
                    var syncSelection = delayedCall(function () {
                        isFocused && resetSelection(isSelectionEmpty);
                    });
                    var syncValue = delayedCall(function () {
                        if (!inComposition) {
                            text.value = PLACEHOLDER;
                            isFocused && resetSelection();
                        }
                    });
                    function resetSelection(isEmpty) {
                        if (inComposition) return;
                        if (inputHandler) {
                            selectionStart = 0;
                            selectionEnd = isEmpty ? 0 : text.value.length - 1;
                        } else {
                            var selectionStart = isEmpty ? 2 : 1;
                            var selectionEnd = 2;
                        }
                        try {
                            text.setSelectionRange(selectionStart, selectionEnd);
                        } catch (e) {}
                    }
                    function resetValue() {
                        if (inComposition) return;
                        text.value = PLACEHOLDER;
                        if (isWebKit) syncValue.schedule();
                    }
                    isWebKit || editor.on('changeSelection', function (event, editor) {
                        if (editor.selection.isEmpty() != isSelectionEmpty) {
                            isSelectionEmpty = !isSelectionEmpty;
                            syncSelection.schedule();
                        }
                    });
                    resetValue();
                    if (isFocused) editor.onFocus();
                    var isAllSelected = function isAllSelected(text) {
                        return text.selectionStart === 0 && text.selectionEnd === text.value.length;
                    };
                    if (!text.setSelectionRange && text.createTextRange) {
                        text.setSelectionRange = function (selectionStart, selectionEnd) {
                            var range = this.createTextRange();
                            range.collapse(true);
                            range.moveStart('character', selectionStart);
                            range.moveEnd('character', selectionEnd);
                            range.select();
                        };
                        isAllSelected = function (text) {
                            try {
                                var range = text.ownerDocument['selection'].createRange();
                            } catch (e) {}
                            if (!range || range.parentElement() != text) return false;
                            return range.text == text.value;
                        };
                    }
                    if (isOldIE) {
                        var inPropertyChange = false;
                        var onPropertyChange = function onPropertyChange(e) {
                            if (inPropertyChange) return;
                            var data = text.value;
                            if (inComposition || !data || data == PLACEHOLDER) return;
                            if (e && data == PLACEHOLDER[0]) return syncProperty.schedule();
                            sendText(data);
                            inPropertyChange = true;
                            resetValue();
                            inPropertyChange = false;
                        };
                        var syncProperty = delayedCall(onPropertyChange);
                        addListener(text, "propertychange", onPropertyChange);
                        var keytable = { 13: 1, 27: 1 };
                        addListener(text, "keyup", function (e) {
                            if (inComposition && (!text.value || keytable[e.keyCode])) setTimeout(onCompositionEnd, 0);
                            if ((text.value.charCodeAt(0) || 0) < 129) {
                                return syncProperty.call();
                            }
                            inComposition ? onCompositionUpdate() : onCompositionStart();
                        });
                        addListener(text, "keydown", function (e) {
                            syncProperty.schedule(50);
                        });
                    }
                    var onSelect = function onSelect(e) {
                        if (copied) {
                            copied = false;
                        } else if (isAllSelected(text)) {
                            editor.selectAll();
                            resetSelection();
                        } else if (inputHandler) {
                            resetSelection(editor.selection.isEmpty());
                        }
                    };
                    var inputHandler = null;
                    this.setInputHandler = function (cb) {
                        inputHandler = cb;
                    };
                    this.getInputHandler = function () {
                        return inputHandler;
                    };
                    var afterContextMenu = false;
                    var sendText = function sendText(data) {
                        if (inputHandler) {
                            data = inputHandler(data);
                            inputHandler = null;
                        }
                        if (pasted) {
                            resetSelection();
                            if (data) editor.onPaste(data);
                            pasted = false;
                        } else if (data == PLACEHOLDER.charAt(0)) {
                            if (afterContextMenu) editor.execCommand("del", { source: "ace" });else editor.execCommand("backspace", { source: "ace" });
                        } else {
                            if (data.substring(0, 2) == PLACEHOLDER) data = data.substr(2);else if (data.charAt(0) == PLACEHOLDER.charAt(0)) data = data.substr(1);else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
                            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0)) data = data.slice(0, -1);
                            if (data) editor.onTextInput(data);
                        }
                        if (afterContextMenu) afterContextMenu = false;
                    };
                    var onInput = function onInput(e) {
                        if (inComposition) return;
                        var data = text.value;
                        sendText(data);
                        resetValue();
                    };
                    var handleClipboardData = function handleClipboardData(e, data) {
                        var clipboardData = e.clipboardData || window['clipboardData'];
                        if (!clipboardData || BROKEN_SETDATA) return;
                        var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
                        if (data) {
                            return clipboardData.setData(mime, data) !== false;
                        } else {
                            return clipboardData.getData(mime);
                        }
                    };
                    var doCopy = function doCopy(e, isCut) {
                        var data = editor.getCopyText();
                        if (!data) return preventDefault(e);
                        if (handleClipboardData(e, data)) {
                            isCut ? editor.onCut() : editor.onCopy();
                            preventDefault(e);
                        } else {
                            copied = true;
                            text.value = data;
                            text.select();
                            setTimeout(function () {
                                copied = false;
                                resetValue();
                                resetSelection();
                                isCut ? editor.onCut() : editor.onCopy();
                            });
                        }
                    };
                    var onCut = function onCut(e) {
                        doCopy(e, true);
                    };
                    var onCopy = function onCopy(e) {
                        doCopy(e, false);
                    };
                    var onPaste = function onPaste(e) {
                        var data = handleClipboardData(e);
                        if (typeof data === "string") {
                            if (data) editor.onPaste(data);
                            if (isIE) setTimeout(resetSelection);
                            preventDefault(e);
                        } else {
                            text.value = "";
                            pasted = true;
                        }
                    };
                    addCommandKeyListener(text, editor.onCommandKey.bind(editor));
                    addListener(text, "select", onSelect);
                    addListener(text, "input", onInput);
                    addListener(text, "cut", onCut);
                    addListener(text, "copy", onCopy);
                    addListener(text, "paste", onPaste);
                    if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
                        addListener(container, "keydown", function (e) {
                            if (isMac && !e.metaKey || !e.ctrlKey) return;
                            switch (e.keyCode) {
                                case 67:
                                    onCopy(e);
                                    break;
                                case 86:
                                    onPaste(e);
                                    break;
                                case 88:
                                    onCut(e);
                                    break;
                            }
                        });
                    }
                    var onCompositionStart = function onCompositionStart() {
                        if (inComposition || !editor.onCompositionStart || editor.$readOnly) return;
                        inComposition = {};
                        editor.onCompositionStart();
                        setTimeout(onCompositionUpdate, 0);
                        editor.on("mousedown", onCompositionEnd);
                        if (!editor.selection.isEmpty()) {
                            editor.insert("", false);
                            editor.getSession().markUndoGroup();
                            editor.selection.clearSelection();
                        }
                        editor.getSession().markUndoGroup();
                    };
                    var onCompositionUpdate = function onCompositionUpdate() {
                        if (!inComposition || !editor.onCompositionUpdate || editor.$readOnly) return;
                        var val = text.value.replace(/\x01/g, "");
                        if (inComposition.lastValue === val) return;
                        editor.onCompositionUpdate(val);
                        if (inComposition.lastValue) editor.undo();
                        inComposition.lastValue = val;
                        if (inComposition.lastValue) {
                            var r = editor.selection.getRange();
                            editor.insert(inComposition.lastValue, false);
                            editor.getSession().markUndoGroup();
                            inComposition.range = editor.selection.getRange();
                            editor.selection.setRange(r);
                            editor.selection.clearSelection();
                        }
                    };
                    var onCompositionEnd = function onCompositionEnd(e, editor) {
                        if (!editor.onCompositionEnd || editor.$readOnly) return;
                        var c = inComposition;
                        inComposition = false;
                        var timer = setTimeout(function () {
                            timer = null;
                            var str = text.value.replace(/\x01/g, "");
                            if (inComposition) return;else if (str == c.lastValue) resetValue();else if (!c.lastValue && str) {
                                resetValue();
                                sendText(str);
                            }
                        });
                        inputHandler = function compositionInputHandler(str) {
                            if (timer) clearTimeout(timer);
                            str = str.replace(/\x01/g, "");
                            if (str == c.lastValue) return "";
                            if (c.lastValue && timer) editor.undo();
                            return str;
                        };
                        editor.onCompositionEnd();
                        editor.off("mousedown", onCompositionEnd);
                        if (e.type == "compositionend" && c.range) {
                            editor.selection.setRange(c.range);
                        }
                    };
                    var syncComposition = delayedCall(onCompositionUpdate, 50);
                    addListener(text, "compositionstart", onCompositionStart);
                    if (isGecko) {
                        addListener(text, "text", function () {
                            syncComposition.schedule();
                        });
                    } else {
                        addListener(text, "keyup", function () {
                            syncComposition.schedule();
                        });
                        addListener(text, "keydown", function () {
                            syncComposition.schedule();
                        });
                    }
                    addListener(text, "compositionend", onCompositionEnd);
                    this.getElement = function () {
                        return text;
                    };
                    this.setReadOnly = function (readOnly) {
                        text.readOnly = readOnly;
                    };
                    this.onContextMenu = function (e) {
                        afterContextMenu = true;
                        resetSelection(editor.selection.isEmpty());
                        editor._emit("nativecontextmenu", { target: editor, domEvent: e });
                        this.moveToMouse(e, true);
                    };
                    this.moveToMouse = function (e, bringToFront) {
                        if (!tempStyle) tempStyle = text.style.cssText;
                        text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (isIE ? "opacity:0.1;" : "");
                        var rect = editor.container.getBoundingClientRect();
                        var style = window.getComputedStyle(editor.container);
                        var top = rect.top + (parseInt(style.borderTopWidth) || 0);
                        var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
                        var maxTop = rect.bottom - top - text.clientHeight - 2;
                        var move = function move(e) {
                            text.style.left = e.clientX - left - 2 + "px";
                            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
                        };
                        move(e);
                        if (e.type != "mousedown") return;
                        if (editor.renderer.$keepTextAreaAtCursor) editor.renderer.$keepTextAreaAtCursor = null;
                        if (isWin) capture(editor.container, move, onContextMenuClose);
                    };
                    this.onContextMenuClose = onContextMenuClose;
                    function onContextMenuClose() {
                        setTimeout(function () {
                            if (tempStyle) {
                                text.style.cssText = tempStyle;
                                tempStyle = '';
                            }
                            if (editor.renderer.$keepTextAreaAtCursor == null) {
                                editor.renderer.$keepTextAreaAtCursor = true;
                                editor.renderer.$moveTextAreaToCursor();
                            }
                        }, 0);
                    }
                    var onContextMenu = function onContextMenu(e) {
                        editor.textInput.onContextMenu(e);
                        onContextMenuClose();
                    };
                    addListener(editor.renderer.scroller, "contextmenu", onContextMenu);
                    addListener(text, "contextmenu", onContextMenu);
                }

                _createClass(TextInput, [{
                    key: "focus",
                    value: function focus() {}
                }, {
                    key: "blur",
                    value: function blur() {}
                }, {
                    key: "isFocused",
                    value: function isFocused() {}
                }, {
                    key: "setReadOnly",
                    value: function setReadOnly(readOnly) {}
                }, {
                    key: "onContextMenuClose",
                    value: function onContextMenuClose() {}
                }, {
                    key: "onContextMenu",
                    value: function onContextMenu(e) {}
                }, {
                    key: "moveToMouse",
                    value: function moveToMouse(e, bringToFront) {}
                }, {
                    key: "setInputHandler",
                    value: function setInputHandler(cb) {}
                }, {
                    key: "getInputHandler",
                    value: function getInputHandler() {}
                }, {
                    key: "getElement",
                    value: function getElement() {}
                }]);

                return TextInput;
            })();

            _export("default", TextInput);
        }
    };
});
System.register("src/Search.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/lang.js", "src/lib/oop.js", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, copyObject, escapeRegExp, getMatchOffsets, mixin, Range, Search;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibLangJs) {
            copyObject = _srcLibLangJs.copyObject;
            escapeRegExp = _srcLibLangJs.escapeRegExp;
            getMatchOffsets = _srcLibLangJs.getMatchOffsets;
        }, function (_srcLibOopJs) {
            mixin = _srcLibOopJs.mixin;
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            Search = (function () {
                function Search() {
                    _classCallCheck(this, Search);

                    this.$options = {};
                }

                _createClass(Search, [{
                    key: "set",
                    value: function set(options) {
                        mixin(this.$options, options);
                        return this;
                    }
                }, {
                    key: "getOptions",
                    value: function getOptions() {
                        return copyObject(this.$options);
                    }
                }, {
                    key: "setOptions",
                    value: function setOptions(options) {
                        this.$options = options;
                    }
                }, {
                    key: "find",
                    value: function find(session) {
                        var iterator = this.$matchIterator(session, this.$options);
                        if (!iterator) {
                            return void 0;
                        }
                        var firstRange = null;
                        iterator.forEach(function (range, row, offset) {
                            if (!range.start) {
                                var column = range.offset + (offset || 0);
                                firstRange = new Range(row, column, row, column + range.length);
                            } else firstRange = range;
                            return true;
                        });
                        return firstRange;
                    }
                }, {
                    key: "findAll",
                    value: function findAll(session) {
                        var options = this.$options;
                        if (!options.needle) {
                            return [];
                        }
                        this.$assembleRegExp(options);
                        var range = options.range;
                        var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
                        var ranges = [];
                        if (options.$isMultiLine) {
                            var re = options.re;
                            var len = re.length;
                            var maxRow = lines.length - len;
                            var prevRange;
                            outer: for (var row = re['offset'] || 0; row <= maxRow; row++) {
                                for (var j = 0; j < len; j++) if (lines[row + j].search(re[j]) == -1) continue outer;
                                var startLine = lines[row];
                                var line = lines[row + len - 1];
                                var startIndex = startLine.length - startLine.match(re[0])[0].length;
                                var endIndex = line.match(re[len - 1])[0].length;
                                if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                                    continue;
                                }
                                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                                if (len > 2) row = row + len - 2;
                            }
                        } else {
                            var re = options.re;
                            for (var i = 0; i < lines.length; i++) {
                                var matches = getMatchOffsets(lines[i], re);
                                for (var j = 0; j < matches.length; j++) {
                                    var match = matches[j];
                                    ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                                }
                            }
                        }
                        if (range) {
                            var startColumn = range.start.column;
                            var endColumn = range.start.column;
                            var i = 0,
                                j = ranges.length - 1;
                            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row) i++;
                            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row) j--;
                            ranges = ranges.slice(i, j + 1);
                            for (i = 0, j = ranges.length; i < j; i++) {
                                ranges[i].start.row += range.start.row;
                                ranges[i].end.row += range.start.row;
                            }
                        }
                        return ranges;
                    }
                }, {
                    key: "replace",
                    value: function replace(input, replacement) {
                        var options = this.$options;
                        var re = this.$assembleRegExp(options);
                        if (options.$isMultiLine) {
                            return replacement;
                        }
                        if (!re) {
                            return;
                        }
                        var match = re.exec(input);
                        if (!match || match[0].length !== input.length) {
                            return null;
                        }
                        replacement = input.replace(re, replacement);
                        if (options.preserveCase) {
                            var parts = replacement.split("");
                            for (var i = Math.min(input.length, input.length); i--;) {
                                var ch = input[i];
                                if (ch && ch.toLowerCase() != ch) parts[i] = parts[i].toUpperCase();else parts[i] = parts[i].toLowerCase();
                            }
                            replacement = parts.join("");
                        }
                        return replacement;
                    }
                }, {
                    key: "$matchIterator",
                    value: function $matchIterator(session, options) {
                        var re = this.$assembleRegExp(options);
                        if (!re) {
                            return false;
                        }
                        var self = this,
                            callback,
                            backwards = options.backwards;
                        if (options.$isMultiLine) {
                            var len = re.length;
                            var matchIterator = function matchIterator(line, row, offset) {
                                var startIndex = line.search(re[0]);
                                if (startIndex == -1) return;
                                for (var i = 1; i < len; i++) {
                                    line = session.getLine(row + i);
                                    if (line.search(re[i]) == -1) return;
                                }
                                var endIndex = line.match(re[len - 1])[0].length;
                                var range = new Range(row, startIndex, row + len - 1, endIndex);
                                if (re['offset'] == 1) {
                                    range.start.row--;
                                    range.start.column = Number.MAX_VALUE;
                                } else if (offset) range.start.column += offset;
                                if (callback(range)) return true;
                            };
                        } else if (backwards) {
                            var matchIterator = function matchIterator(line, row, startIndex) {
                                var matches = getMatchOffsets(line, re);
                                for (var i = matches.length - 1; i >= 0; i--) if (callback(matches[i], row, startIndex)) return true;
                            };
                        } else {
                            var matchIterator = function matchIterator(line, row, startIndex) {
                                var matches = getMatchOffsets(line, re);
                                for (var i = 0; i < matches.length; i++) if (callback(matches[i], row, startIndex)) return true;
                            };
                        }
                        return {
                            forEach: function forEach(_callback) {
                                callback = _callback;
                                self.$lineIterator(session, options).forEach(matchIterator);
                            }
                        };
                    }
                }, {
                    key: "$assembleRegExp",
                    value: function $assembleRegExp(options, $disableFakeMultiline) {
                        if (!options.needle) {
                            options.re = false;
                        } else if (options.needle instanceof RegExp) {
                            options.re = options.needle;
                        } else if (typeof options.needle === 'string') {
                            var needleString = options.needle;
                            if (!options.regExp) {
                                needleString = escapeRegExp(needleString);
                            }
                            if (options.wholeWord) {
                                needleString = "\\b" + needleString + "\\b";
                            }
                            var modifier = options.caseSensitive ? "g" : "gi";
                            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needleString);
                            if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needleString, modifier);
                            try {
                                options.re = new RegExp(needleString, modifier);
                            } catch (e) {
                                options.re = false;
                            }
                        } else {
                            throw new Error("typeof options.needle => " + typeof options.needle);
                        }
                        return options.re;
                    }
                }, {
                    key: "$assembleMultilineRegExp",
                    value: function $assembleMultilineRegExp(needle, modifier) {
                        var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
                        var re = [];
                        for (var i = 0; i < parts.length; i++) {
                            try {
                                re.push(new RegExp(parts[i], modifier));
                            } catch (e) {
                                return void 0;
                            }
                        }
                        if (parts[0] === "") {
                            re.shift();
                            re['offset'] = 1;
                        } else {
                            re['offset'] = 0;
                        }
                        return re;
                    }
                }, {
                    key: "$lineIterator",
                    value: function $lineIterator(session, options) {
                        var backwards = options.backwards == true;
                        var skipCurrent = options.skipCurrent != false;
                        var range = options.range;
                        var start = options.start;
                        if (!start) {
                            if (range) {
                                start = backwards ? range.end : range.start;
                            } else {
                                var x = session.getSelection().getRange();
                                start = skipCurrent !== backwards ? x.end : x.start;
                            }
                        }
                        var firstRow = range ? range.start.row : 0;
                        var lastRow = range ? range.end.row : session.getLength() - 1;
                        var forEach = backwards ? function (callback) {
                            var row = start.row;
                            var line = session.getLine(row).substring(0, start.column);
                            if (callback(line, row)) return;
                            for (row--; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;
                            if (options.wrap == false) return;
                            for (row = lastRow, firstRow = start.row; row >= firstRow; row--) if (callback(session.getLine(row), row)) return;
                        } : function (callback) {
                            var row = start.row;
                            var line = session.getLine(row).substr(start.column);
                            if (callback(line, row, start.column)) return;
                            for (row = row + 1; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;
                            if (options.wrap == false) return;
                            for (row = firstRow, lastRow = start.row; row <= lastRow; row++) if (callback(session.getLine(row), row)) return;
                        };
                        return { forEach: forEach };
                    }
                }]);

                return Search;
            })();

            _export("default", Search);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.get-names", ["npm:core-js@1.2.6/library/modules/$.to-iobject", "npm:core-js@1.2.6/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject'),
      getNames = $__require('npm:core-js@1.2.6/library/modules/$').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.get-own-property-names", ["npm:core-js@1.2.6/library/modules/$.object-sap", "npm:core-js@1.2.6/library/modules/$.get-names"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/$.object-sap')('getOwnPropertyNames', function() {
    return $__require('npm:core-js@1.2.6/library/modules/$.get-names').get;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/get-own-property-names", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/es6.object.get-own-property-names"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  $__require('npm:core-js@1.2.6/library/modules/es6.object.get-own-property-names');
  module.exports = function getOwnPropertyNames(it) {
    return $.getNames(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/get-own-property-names", ["npm:core-js@1.2.6/library/fn/object/get-own-property-names"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/get-own-property-names'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("src/lib/mix.js", ["npm:babel-runtime@5.8.34/core-js/object/get-own-property-names"], function (_export) {
    var _Object$getOwnPropertyNames;

    function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function (baseCtor) {
            _Object$getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                derivedCtor.prototype[name] = baseCtor.prototype[name];
            });
        });
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectGetOwnPropertyNames) {
            _Object$getOwnPropertyNames = _npmBabelRuntime5834CoreJsObjectGetOwnPropertyNames["default"];
        }],
        execute: function () {
            "use strict";

            _export("applyMixins", applyMixins);
        }
    };
});
System.register("src/keyboard/HashHandler.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/object/keys", "src/lib/keys.js", "src/lib/useragent.js"], function (_export) {
    var _createClass, _classCallCheck, _Object$keys, FUNCTION_KEYS, KEY_MODS, keyCodes, isMac, HashHandler;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys["default"];
        }, function (_srcLibKeysJs) {
            FUNCTION_KEYS = _srcLibKeysJs.FUNCTION_KEYS;
            KEY_MODS = _srcLibKeysJs.KEY_MODS;
            keyCodes = _srcLibKeysJs["default"];
        }, function (_srcLibUseragentJs) {
            isMac = _srcLibUseragentJs.isMac;
        }],
        execute: function () {
            "use strict";

            HashHandler = (function () {
                function HashHandler(config, platform) {
                    _classCallCheck(this, HashHandler);

                    this.platform = platform || (isMac ? "mac" : "win");
                    this.commands = {};
                    this.commandKeyBinding = {};
                    this.addCommands(config);
                }

                _createClass(HashHandler, [{
                    key: "addCommand",
                    value: function addCommand(command) {
                        if (this.commands[command.name]) {
                            this.removeCommand(command);
                        }
                        this.commands[command.name] = command;
                        if (command.bindKey) this._buildKeyHash(command);
                    }
                }, {
                    key: "removeCommand",
                    value: function removeCommand(command) {
                        var name = typeof command === 'string' ? command : command.name;
                        command = this.commands[name];
                        delete this.commands[name];
                        var ckb = this.commandKeyBinding;
                        for (var hashId in ckb) {
                            for (var key in ckb[hashId]) {
                                if (ckb[hashId][key] == command) delete ckb[hashId][key];
                            }
                        }
                    }
                }, {
                    key: "bindKey",
                    value: function bindKey(key, command) {
                        var self = this;
                        if (!key) return;
                        if (typeof command === "function") {
                            this.addCommand({ exec: command, bindKey: key, name: command.name || key });
                            return;
                        }
                        var ckb = this.commandKeyBinding;
                        key.split("|").forEach(function (keyPart) {
                            var binding = self.parseKeys(keyPart);
                            var hashId = binding.hashId;
                            (ckb[hashId] || (ckb[hashId] = {}))[binding.key] = command;
                        }, self);
                    }
                }, {
                    key: "addCommands",
                    value: function addCommands(commands) {
                        commands && _Object$keys(commands).forEach(function (name) {
                            var command = commands[name];
                            if (!command) {
                                return;
                            }
                            if (typeof command === "string") {
                                return this.bindKey(command, name);
                            }
                            if (typeof command === "function") {
                                command = { exec: command };
                            }
                            if (typeof command !== "object") {
                                return;
                            }
                            if (!command.name) {
                                command.name = name;
                            }
                            this.addCommand(command);
                        }, this);
                    }
                }, {
                    key: "removeCommands",
                    value: function removeCommands(commands) {
                        _Object$keys(commands).forEach(function (name) {
                            this.removeCommand(commands[name]);
                        }, this);
                    }
                }, {
                    key: "bindKeys",
                    value: function bindKeys(keyList) {
                        var self = this;
                        _Object$keys(keyList).forEach(function (key) {
                            self.bindKey(key, keyList[key]);
                        }, self);
                    }
                }, {
                    key: "_buildKeyHash",
                    value: function _buildKeyHash(command) {
                        var binding = command.bindKey;
                        if (!binding) return;
                        var key = typeof binding == "string" ? binding : binding[this.platform];
                        this.bindKey(key, command);
                    }
                }, {
                    key: "parseKeys",
                    value: function parseKeys(keys) {
                        if (keys.indexOf(" ") != -1) keys = keys.split(/\s+/).pop();
                        var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function (x) {
                            return x;
                        });
                        var key = parts.pop();
                        var keyCode = keyCodes[key];
                        if (FUNCTION_KEYS[keyCode]) key = FUNCTION_KEYS[keyCode].toLowerCase();else if (!parts.length) return { key: key, hashId: -1 };else if (parts.length == 1 && parts[0] == "shift") return { key: key.toUpperCase(), hashId: -1 };
                        var hashId = 0;
                        for (var i = parts.length; i--;) {
                            var modifier = KEY_MODS[parts[i]];
                            if (modifier === null) {
                                throw new Error("invalid modifier " + parts[i] + " in " + keys);
                            }
                            hashId |= modifier;
                        }
                        return { key: key, hashId: hashId };
                    }
                }, {
                    key: "findKeyCommand",
                    value: function findKeyCommand(hashId, keyString) {
                        var ckbr = this.commandKeyBinding;
                        return ckbr[hashId] && ckbr[hashId][keyString];
                    }
                }, {
                    key: "handleKeyboard",
                    value: function handleKeyboard(dataUnused, hashId, keyString, keyCodeUnused, e) {
                        var response = {
                            command: this.findKeyCommand(hashId, keyString)
                        };
                        return response;
                    }
                }]);

                return HashHandler;
            })();

            _export("default", HashHandler);
        }
    };
});
System.register("src/commands/CommandManager.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/mix.js", "src/keyboard/HashHandler.js", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, applyMixins, HashHandler, EventEmitterClass, CommandManager;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibMixJs) {
            applyMixins = _srcLibMixJs.applyMixins;
        }, function (_srcKeyboardHashHandlerJs) {
            HashHandler = _srcKeyboardHashHandlerJs["default"];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";

            CommandManager = (function () {
                function CommandManager(platform, commands) {
                    _classCallCheck(this, CommandManager);

                    this.eventBus = new EventEmitterClass(this);
                    this.hashHandler = new HashHandler(commands, platform);
                    this.eventBus.setDefaultHandler("exec", function (e) {
                        return e.command.exec(e.editor, e.args || {});
                    });
                }

                _createClass(CommandManager, [{
                    key: "bindKey",
                    value: function bindKey(key, command) {
                        return this.hashHandler.bindKey(key, command);
                    }
                }, {
                    key: "bindKeys",
                    value: function bindKeys(keyList) {
                        return this.hashHandler.bindKeys(keyList);
                    }
                }, {
                    key: "addCommand",
                    value: function addCommand(command) {
                        this.hashHandler.addCommand(command);
                    }
                }, {
                    key: "removeCommand",
                    value: function removeCommand(commandName) {
                        this.hashHandler.removeCommand(commandName);
                    }
                }, {
                    key: "findKeyCommand",
                    value: function findKeyCommand(hashId, keyString) {
                        return this.hashHandler.findKeyCommand(hashId, keyString);
                    }
                }, {
                    key: "parseKeys",
                    value: function parseKeys(keys) {
                        return this.hashHandler.parseKeys(keys);
                    }
                }, {
                    key: "addCommands",
                    value: function addCommands(commands) {
                        this.hashHandler.addCommands(commands);
                    }
                }, {
                    key: "removeCommands",
                    value: function removeCommands(commands) {
                        this.hashHandler.removeCommands(commands);
                    }
                }, {
                    key: "handleKeyboard",
                    value: function handleKeyboard(data, hashId, keyString, keyCode) {
                        return this.hashHandler.handleKeyboard(data, hashId, keyString, keyCode);
                    }
                }, {
                    key: "exec",
                    value: function exec(command, editor, args) {
                        if (typeof command === 'string') {
                            command = this.hashHandler.commands[command];
                        }
                        if (!command) {
                            return false;
                        }
                        if (editor && editor.$readOnly && !command.readOnly) {
                            return false;
                        }
                        var e = { editor: editor, command: command, args: args };
                        var retvalue = this.eventBus._emit("exec", e);
                        this.eventBus._signal("afterExec", e);
                        return retvalue === false ? false : true;
                    }
                }, {
                    key: "toggleRecording",
                    value: function toggleRecording(editor) {
                        if (this.$inReplay) return;
                        editor && editor._emit("changeStatus");
                        if (this.recording) {
                            this.macro.pop();
                            this.eventBus.off("exec", this.$addCommandToMacro);
                            if (!this.macro.length) this.macro = this.oldMacro;
                            return this.recording = false;
                        }
                        if (!this.$addCommandToMacro) {
                            this.$addCommandToMacro = (function (e) {
                                this.macro.push([e.command, e.args]);
                            }).bind(this);
                        }
                        this.oldMacro = this.macro;
                        this.macro = [];
                        this.eventBus.on("exec", this.$addCommandToMacro);
                        return this.recording = true;
                    }
                }, {
                    key: "replay",
                    value: function replay(editor) {
                        if (this.$inReplay || !this.macro) return;
                        if (this.recording) return this.toggleRecording(editor);
                        try {
                            this.$inReplay = true;
                            this.macro.forEach(function (x) {
                                if (typeof x == "string") this.exec(x, editor);else this.exec(x[0], editor, x[1]);
                            }, this);
                        } finally {
                            this.$inReplay = false;
                        }
                    }
                }, {
                    key: "trimMacro",
                    value: function trimMacro(m) {
                        return m.map(function (x) {
                            if (typeof x[0] != "string") x[0] = x[0].name;
                            if (!x[1]) x = x[0];
                            return x;
                        });
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback, capturing) {
                        this.eventBus.on(eventName, callback, capturing);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "platform",
                    get: function get() {
                        return this.hashHandler.platform;
                    }
                }, {
                    key: "commands",
                    get: function get() {
                        return this.hashHandler.commands;
                    }
                }, {
                    key: "commandKeyBinding",
                    get: function get() {
                        return this.hashHandler.commandKeyBinding;
                    }
                }]);

                return CommandManager;
            })();

            _export("default", CommandManager);

            applyMixins(CommandManager, [HashHandler]);
        }
    };
});
System.register("src/commands/default_commands.js", ["src/lib/lang.js", "src/config.js", "src/Range.js"], function (_export) {
    "use strict";
    var stringRepeat, stringTrimLeft, stringTrimRight, loadModule, Range, commands;

    function bindKey(win, mac) {
        return { win: win, mac: mac };
    }
    return {
        setters: [function (_srcLibLangJs) {
            stringRepeat = _srcLibLangJs.stringRepeat;
            stringTrimLeft = _srcLibLangJs.stringTrimLeft;
            stringTrimRight = _srcLibLangJs.stringTrimRight;
        }, function (_srcConfigJs) {
            loadModule = _srcConfigJs.loadModule;
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            commands = [{
                name: "showSettingsMenu",
                bindKey: bindKey("Ctrl-,", "Command-,"),
                exec: function exec(editor) {
                    loadModule("ace/ext/settings_menu", function (module) {
                        module.init(editor);
                    });
                },
                readOnly: true
            }, {
                name: "goToNextError",
                bindKey: bindKey("Alt-E", "Ctrl-E"),
                exec: function exec(editor) {
                    loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, 1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "goToPreviousError",
                bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
                exec: function exec(editor) {
                    loadModule("ace/ext/error_marker", function (module) {
                        module.showErrorMarker(editor, -1);
                    });
                },
                scrollIntoView: "animate",
                readOnly: true
            }, {
                name: "selectall",
                bindKey: bindKey("Ctrl-A", "Command-A"),
                exec: function exec(editor) {
                    editor.selectAll();
                },
                readOnly: true
            }, {
                name: "centerselection",
                bindKey: bindKey(null, "Ctrl-L"),
                exec: function exec(editor) {
                    editor.centerSelection();
                },
                readOnly: true
            }, {
                name: "gotoline",
                bindKey: bindKey("Ctrl-L", "Command-L"),
                exec: function exec(editor) {
                    var line = parseInt(prompt("Enter line number:"), 10);
                    if (!isNaN(line)) {
                        editor.gotoLine(line);
                    }
                },
                readOnly: true
            }, {
                name: "fold",
                bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
                exec: function exec(editor) {
                    editor.getSession().toggleFold(false);
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfold",
                bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
                exec: function exec(editor) {
                    editor.getSession().toggleFold(true);
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleFoldWidget",
                bindKey: bindKey("F2", "F2"),
                exec: function exec(editor) {
                    editor.getSession().toggleFoldWidget();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "toggleParentFoldWidget",
                bindKey: bindKey("Alt-F2", "Alt-F2"),
                exec: function exec(editor) {
                    editor.getSession().toggleFoldWidget(true);
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldall",
                bindKey: bindKey("Ctrl-Alt-0", "Ctrl-Command-Option-0"),
                exec: function exec(editor) {
                    editor.getSession().foldAll();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "foldOther",
                bindKey: bindKey("Alt-0", "Command-Option-0"),
                exec: function exec(editor) {
                    editor.getSession().foldAll();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "unfoldall",
                bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
                exec: function exec(editor) {
                    editor.getSession().unfold();
                },
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findnext",
                bindKey: bindKey("Ctrl-K", "Command-G"),
                exec: function exec(editor) {
                    editor.findNext();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "findprevious",
                bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
                exec: function exec(editor) {
                    editor.findPrevious();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "center",
                readOnly: true
            }, {
                name: "selectOrFindNext",
                bindKey: bindKey("Alt-K", "Ctrl-G"),
                exec: function exec(editor) {
                    if (editor.selection.isEmpty()) {
                        editor.selection.selectWord();
                    } else {
                        editor.findNext();
                    }
                },
                readOnly: true
            }, {
                name: "selectOrFindPrevious",
                bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
                exec: function exec(editor) {
                    if (editor.selection.isEmpty()) {
                        editor.selection.selectWord();
                    } else {
                        editor.findPrevious();
                    }
                },
                readOnly: true
            }, {
                name: "find",
                bindKey: bindKey("Ctrl-F", "Command-F"),
                exec: function exec(editor) {
                    loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor);
                    });
                },
                readOnly: true
            }, {
                name: "overwrite",
                bindKey: bindKey("Insert", "Insert"),
                exec: function exec(editor) {
                    editor.toggleOverwrite();
                },
                readOnly: true
            }, {
                name: "selecttostart",
                bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
                exec: function exec(editor) {
                    editor.getSelection().selectFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotostart",
                bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
                exec: function exec(editor) {
                    editor.navigateFileStart();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectup",
                bindKey: bindKey("Shift-Up", "Shift-Up"),
                exec: function exec(editor) {
                    editor.getSelection().selectUp();
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "golineup",
                bindKey: bindKey("Up", "Up|Ctrl-P"),
                exec: function exec(editor, args) {
                    editor.navigateUp(args.times);
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "selecttoend",
                bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
                exec: function exec(editor) {
                    editor.getSelection().selectFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "gotoend",
                bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
                exec: function exec(editor) {
                    editor.navigateFileEnd();
                },
                multiSelectAction: "forEach",
                readOnly: true,
                scrollIntoView: "animate",
                aceCommandGroup: "fileJump"
            }, {
                name: "selectdown",
                bindKey: bindKey("Shift-Down", "Shift-Down"),
                exec: function exec(editor) {
                    editor.getSelection().selectDown();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "golinedown",
                bindKey: bindKey("Down", "Down|Ctrl-N"),
                exec: function exec(editor, args) {
                    editor.navigateDown(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordleft",
                bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
                exec: function exec(editor) {
                    editor.getSelection().selectWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordleft",
                bindKey: bindKey("Ctrl-Left", "Option-Left"),
                exec: function exec(editor) {
                    editor.navigateWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolinestart",
                bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
                exec: function exec(editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolinestart",
                bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
                exec: function exec(editor) {
                    editor.navigateLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectleft",
                bindKey: bindKey("Shift-Left", "Shift-Left"),
                exec: function exec(editor) {
                    editor.getSelection().selectLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoleft",
                bindKey: bindKey("Left", "Left|Ctrl-B"),
                exec: function exec(editor, args) {
                    editor.navigateLeft(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectwordright",
                bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
                exec: function exec(editor) {
                    editor.getSelection().selectWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotowordright",
                bindKey: bindKey("Ctrl-Right", "Option-Right"),
                exec: function exec(editor) {
                    editor.navigateWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selecttolineend",
                bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
                exec: function exec(editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotolineend",
                bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
                exec: function exec(editor) {
                    editor.navigateLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectright",
                bindKey: bindKey("Shift-Right", "Shift-Right"),
                exec: function exec(editor) {
                    editor.getSelection().selectRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "gotoright",
                bindKey: bindKey("Right", "Right|Ctrl-F"),
                exec: function exec(editor, args) {
                    editor.navigateRight(args.times);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectpagedown",
                bindKey: "Shift-PageDown",
                exec: function exec(editor) {
                    editor.selectPageDown();
                },
                readOnly: true
            }, {
                name: "pagedown",
                bindKey: bindKey(null, "Option-PageDown"),
                exec: function exec(editor) {
                    editor.scrollPageDown();
                },
                readOnly: true
            }, {
                name: "gotopagedown",
                bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
                exec: function exec(editor) {
                    editor.gotoPageDown();
                },
                readOnly: true
            }, {
                name: "selectpageup",
                bindKey: "Shift-PageUp",
                exec: function exec(editor) {
                    editor.selectPageUp();
                },
                readOnly: true
            }, {
                name: "pageup",
                bindKey: bindKey(null, "Option-PageUp"),
                exec: function exec(editor) {
                    editor.scrollPageUp();
                },
                readOnly: true
            }, {
                name: "gotopageup",
                bindKey: "PageUp",
                exec: function exec(editor) {
                    editor.gotoPageUp();
                },
                readOnly: true
            }, {
                name: "scrollup",
                bindKey: bindKey("Ctrl-Up", null),
                exec: function exec(e) {
                    e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "scrolldown",
                bindKey: bindKey("Ctrl-Down", null),
                exec: function exec(e) {
                    e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
                },
                readOnly: true
            }, {
                name: "selectlinestart",
                bindKey: "Shift-Home",
                exec: function exec(editor) {
                    editor.getSelection().selectLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "selectlineend",
                bindKey: "Shift-End",
                exec: function exec(editor) {
                    editor.getSelection().selectLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "togglerecording",
                bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
                exec: function exec(editor) {
                    editor.commands.toggleRecording(editor);
                },
                readOnly: true
            }, {
                name: "replaymacro",
                bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
                exec: function exec(editor) {
                    editor.commands.replay(editor);
                },
                readOnly: true
            }, {
                name: "jumptomatching",
                bindKey: bindKey("Ctrl-P", "Ctrl-P"),
                exec: function exec(editor) {
                    editor.jumpToMatching();
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "selecttomatching",
                bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
                exec: function exec(editor) {
                    editor.jumpToMatching(true);
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "passKeysToBrowser",
                bindKey: bindKey("null", "null"),
                exec: function exec() {},
                passEvent: true,
                readOnly: true
            }, {
                name: "cut",
                exec: function exec(editor) {
                    var range = editor.getSelectionRange();
                    editor._emit("cut", range);
                    if (!editor.selection.isEmpty()) {
                        editor.getSession().remove(range);
                        editor.clearSelection();
                    }
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "removeline",
                bindKey: bindKey("Ctrl-D", "Command-D"),
                exec: function exec(editor) {
                    editor.removeLines();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEachLine"
            }, {
                name: "duplicateSelection",
                bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
                exec: function exec(editor) {
                    editor.duplicateSelection();
                },
                scrollIntoView: "cursor",
                multiSelectAction: "forEach"
            }, {
                name: "sortlines",
                bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
                exec: function exec(editor) {
                    editor.sortLines();
                },
                scrollIntoView: "selection",
                multiSelectAction: "forEachLine"
            }, {
                name: "togglecomment",
                bindKey: bindKey("Ctrl-/", "Command-/"),
                exec: function exec(editor) {
                    editor.toggleCommentLines();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "toggleBlockComment",
                bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
                exec: function exec(editor) {
                    editor.toggleBlockComment();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "modifyNumberUp",
                bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
                exec: function exec(editor) {
                    editor.modifyNumber(1);
                },
                multiSelectAction: "forEach"
            }, {
                name: "modifyNumberDown",
                bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
                exec: function exec(editor) {
                    editor.modifyNumber(-1);
                },
                multiSelectAction: "forEach"
            }, {
                name: "replace",
                bindKey: bindKey("Ctrl-H", "Command-Option-F"),
                exec: function exec(editor) {
                    loadModule("ace/ext/searchbox", function (e) {
                        e.Search(editor, true);
                    });
                }
            }, {
                name: "undo",
                bindKey: bindKey("Ctrl-Z", "Command-Z"),
                exec: function exec(editor) {
                    editor.undo();
                }
            }, {
                name: "redo",
                bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
                exec: function exec(editor) {
                    editor.redo();
                }
            }, {
                name: "copylinesup",
                bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
                exec: function exec(editor) {
                    editor.copyLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesup",
                bindKey: bindKey("Alt-Up", "Option-Up"),
                exec: function exec(editor) {
                    editor.moveLinesUp();
                },
                scrollIntoView: "cursor"
            }, {
                name: "copylinesdown",
                bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
                exec: function exec(editor) {
                    editor.copyLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "movelinesdown",
                bindKey: bindKey("Alt-Down", "Option-Down"),
                exec: function exec(editor) {
                    editor.moveLinesDown();
                },
                scrollIntoView: "cursor"
            }, {
                name: "del",
                bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
                exec: function exec(editor) {
                    editor.remove("right");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "backspace",
                bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
                exec: function exec(editor) {
                    editor.remove("left");
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "cut_or_delete",
                bindKey: bindKey("Shift-Delete", null),
                exec: function exec(editor) {
                    if (editor.selection.isEmpty()) {
                        editor.remove("left");
                    } else {
                        return false;
                    }
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolinestart",
                bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
                exec: function exec(editor) {
                    editor.removeToLineStart();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removetolineend",
                bindKey: bindKey("Alt-Delete", "Ctrl-K"),
                exec: function exec(editor) {
                    editor.removeToLineEnd();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordleft",
                bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
                exec: function exec(editor) {
                    editor.removeWordLeft();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "removewordright",
                bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
                exec: function exec(editor) {
                    editor.removeWordRight();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "outdent",
                bindKey: bindKey("Shift-Tab", "Shift-Tab"),
                exec: function exec(editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "indent",
                bindKey: bindKey("Tab", "Tab"),
                exec: function exec(editor) {
                    editor.indent();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockoutdent",
                bindKey: bindKey("Ctrl-[", "Ctrl-["),
                exec: function exec(editor) {
                    editor.blockOutdent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "blockindent",
                bindKey: bindKey("Ctrl-]", "Ctrl-]"),
                exec: function exec(editor) {
                    editor.blockIndent();
                },
                multiSelectAction: "forEachLine",
                scrollIntoView: "selectionPart"
            }, {
                name: "insertstring",
                exec: function exec(editor, str) {
                    editor.insert(str);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "inserttext",
                exec: function exec(editor, args) {
                    editor.insert(stringRepeat(args.text || "", args.times || 1));
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "splitline",
                bindKey: bindKey(null, "Ctrl-O"),
                exec: function exec(editor) {
                    editor.splitLine();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "transposeletters",
                bindKey: bindKey("Ctrl-T", "Ctrl-T"),
                exec: function exec(editor) {
                    editor.transposeLetters();
                },
                multiSelectAction: function multiSelectAction(editor) {},
                scrollIntoView: "cursor"
            }, {
                name: "touppercase",
                bindKey: bindKey("Ctrl-U", "Ctrl-U"),
                exec: function exec(editor) {
                    editor.toUpperCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "tolowercase",
                bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
                exec: function exec(editor) {
                    editor.toLowerCase();
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor"
            }, {
                name: "expandtoline",
                bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
                exec: function exec(editor) {
                    var range = editor.selection.getRange();
                    range.start.column = range.end.column = 0;
                    range.end.row++;
                    editor.selection.setRange(range, false);
                },
                multiSelectAction: "forEach",
                scrollIntoView: "cursor",
                readOnly: true
            }, {
                name: "joinlines",
                bindKey: bindKey(null, null),
                exec: function exec(editor) {
                    var isBackwards = editor.selection.isBackwards();
                    var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                    var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                    var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                    var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                    var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                    var insertLine = editor.session.doc.getLine(selectionStart.row);
                    for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
                        var curLine = stringTrimLeft(stringTrimRight(editor.session.doc.getLine(i)));
                        if (curLine.length !== 0) {
                            curLine = " " + curLine;
                        }
                        insertLine += curLine;
                    }
                    ;
                    if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
                        insertLine += editor.session.doc.getNewLineCharacter();
                    }
                    editor.clearSelection();
                    editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
                    if (selectedCount > 0) {
                        editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                        editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                    } else {
                        firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                        editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                    }
                },
                multiSelectAction: "forEach",
                readOnly: true
            }, {
                name: "invertSelection",
                bindKey: bindKey(null, null),
                exec: function exec(editor) {
                    var endRow = editor.session.doc.getLength() - 1;
                    var endCol = editor.session.doc.getLine(endRow).length;
                    var ranges = editor.selection.rangeList.ranges;
                    var newRanges = [];
                    if (ranges.length < 1) {
                        ranges = [editor.selection.getRange()];
                    }
                    for (var i = 0; i < ranges.length; i++) {
                        if (i == ranges.length - 1) {
                            if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                            }
                        }
                        if (i === 0) {
                            if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                            }
                        } else {
                            newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                        }
                    }
                    editor.exitMultiSelectMode();
                    editor.clearSelection();
                    for (var i = 0; i < newRanges.length; i++) {
                        editor.selection.addRange(newRanges[i], false);
                    }
                },
                readOnly: true,
                scrollIntoView: "none"
            }];

            _export("default", commands);
        }
    };
});
System.register("src/editor_protocol.js", [], function (_export) {
  "use strict";

  var COMMAND_NAME_AUTO_COMPLETE;
  return {
    setters: [],
    execute: function () {
      COMMAND_NAME_AUTO_COMPLETE = "autoComplete";

      _export("COMMAND_NAME_AUTO_COMPLETE", COMMAND_NAME_AUTO_COMPLETE);
    }
  };
});
System.register("src/hammer/recognizers/attribute.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/hammer/hammer.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, decodeEventType, INPUT_CANCEL, INPUT_END, INPUT_MOVE, INPUT_START, Recognizer, STATE_BEGAN, STATE_CANCELLED, STATE_CHANGED, STATE_FAILED, STATE_RECOGNIZED, ContinuousRecognizer;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcHammerHammerJs) {
            decodeEventType = _srcHammerHammerJs.decodeEventType;
            INPUT_CANCEL = _srcHammerHammerJs.INPUT_CANCEL;
            INPUT_END = _srcHammerHammerJs.INPUT_END;
            INPUT_MOVE = _srcHammerHammerJs.INPUT_MOVE;
            INPUT_START = _srcHammerHammerJs.INPUT_START;
            Recognizer = _srcHammerHammerJs.Recognizer;
            STATE_BEGAN = _srcHammerHammerJs.STATE_BEGAN;
            STATE_CANCELLED = _srcHammerHammerJs.STATE_CANCELLED;
            STATE_CHANGED = _srcHammerHammerJs.STATE_CHANGED;
            STATE_FAILED = _srcHammerHammerJs.STATE_FAILED;
            STATE_RECOGNIZED = _srcHammerHammerJs.STATE_RECOGNIZED;
        }],
        execute: function () {
            "use strict";

            ContinuousRecognizer = (function (_Recognizer) {
                _inherits(ContinuousRecognizer, _Recognizer);

                function ContinuousRecognizer(eventName, enabled, pointers) {
                    _classCallCheck(this, ContinuousRecognizer);

                    _get(Object.getPrototypeOf(ContinuousRecognizer.prototype), "constructor", this).call(this, eventName, enabled);
                    this.pointers = pointers;
                }

                _createClass(ContinuousRecognizer, [{
                    key: "attributeTest",
                    value: function attributeTest(input) {
                        switch (input.eventType) {
                            case INPUT_START:
                                {
                                    return input.touchesLength === this.pointers;
                                }
                                break;
                            case INPUT_MOVE:
                                {
                                    return input.touchesLength === this.pointers;
                                }
                                break;
                            case INPUT_END:
                                {
                                    return input.touchesLength === this.pointers - 1;
                                }
                                break;
                            case INPUT_CANCEL:
                                {
                                    return true;
                                }
                                break;
                            default:
                                {
                                    throw new Error(decodeEventType(input.eventType));
                                }
                        }
                    }
                }, {
                    key: "process",
                    value: function process(input) {
                        var state = this.state;
                        var eventType = input.eventType;
                        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                        var isValid = this.attributeTest(input);
                        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                            return state | STATE_CANCELLED;
                        } else if (isRecognized || isValid) {
                            if (eventType & INPUT_END) {
                                return state | STATE_RECOGNIZED;
                            } else if (!(state & STATE_BEGAN)) {
                                return STATE_BEGAN;
                            } else {
                                return state | STATE_CHANGED;
                            }
                        }
                        return STATE_FAILED;
                    }
                }]);

                return ContinuousRecognizer;
            })(Recognizer);

            _export("ContinuousRecognizer", ContinuousRecognizer);
        }
    };
});
System.register('src/hammer/recognizers/pan.js', ['npm:babel-runtime@5.8.34/helpers/get', 'npm:babel-runtime@5.8.34/helpers/inherits', 'npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'src/hammer/recognizers/attribute.js', 'src/hammer/hammer.js'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, ContinuousRecognizer, DIRECTION_ALL, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UNDEFINED, DIRECTION_UP, DIRECTION_VERTICAL, STATE_BEGAN, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, PanRecognizer;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet['default'];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits['default'];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_srcHammerRecognizersAttributeJs) {
            ContinuousRecognizer = _srcHammerRecognizersAttributeJs.ContinuousRecognizer;
        }, function (_srcHammerHammerJs) {
            DIRECTION_ALL = _srcHammerHammerJs.DIRECTION_ALL;
            DIRECTION_DOWN = _srcHammerHammerJs.DIRECTION_DOWN;
            DIRECTION_HORIZONTAL = _srcHammerHammerJs.DIRECTION_HORIZONTAL;
            DIRECTION_LEFT = _srcHammerHammerJs.DIRECTION_LEFT;
            DIRECTION_RIGHT = _srcHammerHammerJs.DIRECTION_RIGHT;
            DIRECTION_UNDEFINED = _srcHammerHammerJs.DIRECTION_UNDEFINED;
            DIRECTION_UP = _srcHammerHammerJs.DIRECTION_UP;
            DIRECTION_VERTICAL = _srcHammerHammerJs.DIRECTION_VERTICAL;
            STATE_BEGAN = _srcHammerHammerJs.STATE_BEGAN;
            TOUCH_ACTION_PAN_X = _srcHammerHammerJs.TOUCH_ACTION_PAN_X;
            TOUCH_ACTION_PAN_Y = _srcHammerHammerJs.TOUCH_ACTION_PAN_Y;
        }],
        execute: function () {
            "use strict";

            PanRecognizer = (function (_ContinuousRecognizer) {
                _inherits(PanRecognizer, _ContinuousRecognizer);

                function PanRecognizer(eventName, enabled) {
                    _classCallCheck(this, PanRecognizer);

                    _get(Object.getPrototypeOf(PanRecognizer.prototype), 'constructor', this).call(this, eventName, enabled, 1);
                    this.direction = DIRECTION_ALL;
                    this.threshold = 10;
                }

                _createClass(PanRecognizer, [{
                    key: 'setDirection',
                    value: function setDirection(direction) {
                        this.direction = direction;
                        return this;
                    }
                }, {
                    key: 'setThreshold',
                    value: function setThreshold(threshold) {
                        this.threshold = threshold;
                        return this;
                    }
                }, {
                    key: 'getTouchAction',
                    value: function getTouchAction() {
                        var actions = [];
                        if (this.direction & DIRECTION_HORIZONTAL) {
                            actions.push(TOUCH_ACTION_PAN_Y);
                        }
                        if (this.direction & DIRECTION_VERTICAL) {
                            actions.push(TOUCH_ACTION_PAN_X);
                        }
                        return actions;
                    }
                }, {
                    key: 'directionTest',
                    value: function directionTest(input) {
                        var hasMoved = true;
                        var distance = input.distance;
                        var direction = input.direction;
                        var x = input.movement.x;
                        var y = input.movement.y;
                        if (!(direction & this.direction)) {
                            if (this.direction & DIRECTION_HORIZONTAL) {
                                direction = x === 0 ? DIRECTION_UNDEFINED : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                                hasMoved = x != this.pX;
                                distance = Math.abs(input.movement.x);
                            } else {
                                direction = y === 0 ? DIRECTION_UNDEFINED : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                                hasMoved = y != this.pY;
                                distance = Math.abs(input.movement.y);
                            }
                        }
                        var directionAllowed = (direction & this.direction) > 0;
                        return hasMoved && distance > this.threshold && directionAllowed;
                    }
                }, {
                    key: 'attributeTest',
                    value: function attributeTest(input) {
                        this.movement = input.movement;
                        if (input.movement) {
                            var directionOK = this.directionTest(input);
                            var began = (this.state & STATE_BEGAN) > 0;
                            return _get(Object.getPrototypeOf(PanRecognizer.prototype), 'attributeTest', this).call(this, input) && (began || !began && directionOK);
                        } else {
                            return true;
                        }
                    }
                }, {
                    key: 'emit',
                    value: function emit() {
                        if (this.movement) {
                            this.manager.emit(this.eventName, this.movement);
                        }
                    }
                }]);

                return PanRecognizer;
            })(ContinuousRecognizer);

            _export('PanRecognizer', PanRecognizer);
        }
    };
});
System.register('src/hammer/hammer.js', ['npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'npm:babel-runtime@5.8.34/helpers/get', 'npm:babel-runtime@5.8.34/helpers/inherits', 'src/hammer/utils.js'], function (_export) {
    var _createClass, _classCallCheck, _get, _inherits, addEventListeners, each, getWindowForElement, hasParent, inArray, inStr, prefixed, removeEventListeners, splitStr, TEST_ELEMENT, toArray, uniqueArray, uniqueId, TOUCH_ACTION_COMPUTE, TOUCH_ACTION_AUTO, TOUCH_ACTION_MANIPULATION, TOUCH_ACTION_NONE, TOUCH_ACTION_PAN_X, TOUCH_ACTION_PAN_Y, STOP, FORCED_STOP, VectorE2, ClientLocation, Session, Manager, MOBILE_REGEX, SUPPORT_TOUCH, SUPPORT_POINTER_EVENTS, SUPPORT_ONLY_TOUCH, PREFIXED_TOUCH_ACTION, NATIVE_TOUCH_ACTION, TouchAction, INPUT_TYPE_TOUCH, INPUT_TYPE_PEN, INPUT_TYPE_MOUSE, INPUT_TYPE_KINECT, COMPUTE_INTERVAL, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, DIRECTION_UNDEFINED, DIRECTION_LEFT, DIRECTION_RIGHT, DIRECTION_UP, DIRECTION_DOWN, DIRECTION_HORIZONTAL, DIRECTION_VERTICAL, DIRECTION_ALL, PROPS_XY, PROPS_CLIENT_XY, Input, TOUCH_INPUT_MAP, TOUCH_TARGET_EVENTS, TouchInput, STATE_UNDEFINED, STATE_POSSIBLE, STATE_BEGAN, STATE_CHANGED, STATE_RECOGNIZED, STATE_CANCELLED, STATE_FAILED, Recognizer;

    function triggerDomEvent(event, data) {
        var gestureEvent = document.createEvent('Event');
        gestureEvent.initEvent(event, true, true);
        gestureEvent['gesture'] = data;
        data.target.dispatchEvent(gestureEvent);
    }

    function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
            return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
        }
        if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
    }

    function decodeEventType(eventType) {
        switch (eventType) {
            case INPUT_START:
                {
                    return "START";
                }
            case INPUT_MOVE:
                {
                    return "MOVE";
                }
            case INPUT_END:
                {
                    return "END";
                }
            case INPUT_CANCEL:
                {
                    return "CANCEL";
                }
            default:
                {
                    return "eventType=" + eventType;
                }
        }
    }

    function inputHandler(manager, eventType, touchEvent) {
        var compEvent = computeIComputedEvent(manager, eventType, touchEvent);
        manager.recognize(compEvent, touchEvent);
        manager.session.push(compEvent);
    }
    function computeIComputedEvent(manager, eventType, touchEvent) {
        var touchesLength = touchEvent.touches.length;
        var changedPointersLen = touchEvent.changedTouches.length;
        var isFirst = eventType & INPUT_START && touchesLength - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && touchesLength - changedPointersLen === 0;
        if (isFirst) {
            manager.session.reset();
        }
        var session = manager.session;
        var center = computeCenter(touchEvent.touches);
        var movement = session.computeMovement(center);
        var timeStamp = Date.now();
        var movementTime = timeStamp - session.startTime;
        var distance = movement ? movement.norm() : 0;
        var direction = getDirection(movement);
        var velocity = session.computeVelocity(center, movementTime);
        var compEvent = {
            center: center,
            movement: movement,
            deltaTime: movementTime,
            direction: direction,
            distance: distance,
            eventType: eventType,
            rotation: 0,
            timeStamp: timeStamp,
            touchesLength: touchEvent.touches.length,
            scale: 1,
            velocity: velocity
        };
        return compEvent;
    }
    function computeCenter(touches) {
        var touchesLength = touches.length;
        if (touchesLength === 1) {
            return ClientLocation.fromTouch(touches[0]);
        } else if (touchesLength === 0) {
            return undefined;
        } else {
            var x = 0,
                y = 0,
                i = 0;
            while (i < touchesLength) {
                x += touches[i].clientX;
                y += touches[i].clientY;
                i++;
            }
            return new ClientLocation(Math.round(x / touchesLength), Math.round(y / touchesLength));
        }
    }
    function getVelocity(deltaTime, x, y) {
        return { x: x / deltaTime || 0, y: y / deltaTime || 0 };
    }
    function getDirection(movement) {
        var N = new VectorE2(0, -1);
        var S = new VectorE2(0, +1);
        var E = new VectorE2(+1, 0);
        var W = new VectorE2(-1, 0);
        var cosineThreshold = Math.cos(7 * Math.PI / 16);
        if (movement) {
            var unit = movement.div(movement.norm());
            var direction = DIRECTION_UNDEFINED;
            if (unit.dot(N) > cosineThreshold) {
                direction |= DIRECTION_UP;
            }
            if (unit.dot(S) > cosineThreshold) {
                direction |= DIRECTION_DOWN;
            }
            if (unit.dot(E) > cosineThreshold) {
                direction |= DIRECTION_RIGHT;
            }
            if (unit.dot(W) > cosineThreshold) {
                direction |= DIRECTION_LEFT;
            }
            return direction;
        } else {
            return DIRECTION_UNDEFINED;
        }
    }

    function getDistance(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
    }

    function getAngle(p1, p2, props) {
        if (!props) {
            props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]],
            y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
    }
    function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);
    }
    function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
    }

    function getTouches(event, type) {
        var allTouches = toArray(event.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
        }
        var i,
            targetTouches,
            changedTouches = toArray(event.changedTouches),
            changedTargetTouches = [],
            target = this.target;
        targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
        });
        if (type === INPUT_START) {
            i = 0;
            while (i < targetTouches.length) {
                targetIds[targetTouches[i].identifier] = true;
                i++;
            }
        }
        i = 0;
        while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
                changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END | INPUT_CANCEL)) {
                delete targetIds[changedTouches[i].identifier];
            }
            i++;
        }
        if (!changedTargetTouches.length) {
            return;
        }
        return [uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
    }

    function stateStr(state) {
        if (state & STATE_CANCELLED) {
            return 'cancel';
        } else if (state & STATE_RECOGNIZED) {
            return 'end';
        } else if (state & STATE_CHANGED) {
            return 'move';
        } else if (state & STATE_BEGAN) {
            return 'start';
        }
        return '';
    }

    function stateDecode(state) {
        var states = [];
        if (state & STATE_POSSIBLE) {
            states.push('STATE_POSSIBLE');
        } else if (state & STATE_CANCELLED) {
            states.push('STATE_CANCELLED');
        } else if (state & STATE_RECOGNIZED) {
            states.push('STATE_RECOGNIZED');
        } else if (state & STATE_CHANGED) {
            states.push('STATE_CHANGED');
        } else if (state & STATE_BEGAN) {
            states.push('STATE_BEGAN');
        } else if (state & STATE_UNDEFINED) {
            states.push('STATE_UNDEFINED');
        } else if (state & STATE_FAILED) {
            states.push('STATE_FAILED');
        } else {
            states.push('' + state);
        }
        return states.join(' ');
    }

    function directionStr(direction) {
        var ds = [];
        if (direction & DIRECTION_DOWN) {
            ds.push('down');
        }
        if (direction & DIRECTION_UP) {
            ds.push('up');
        }
        if (direction & DIRECTION_LEFT) {
            ds.push('left');
        }
        if (direction & DIRECTION_RIGHT) {
            ds.push('right');
        }
        return ds.join(' ');
    }

    function getRecognizerByNameIfManager(recognizer, manager) {
        if (manager) {
            return manager.get(recognizer.eventName);
        }
        return recognizer;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet['default'];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits['default'];
        }, function (_srcHammerUtilsJs) {
            addEventListeners = _srcHammerUtilsJs.addEventListeners;
            each = _srcHammerUtilsJs.each;
            getWindowForElement = _srcHammerUtilsJs.getWindowForElement;
            hasParent = _srcHammerUtilsJs.hasParent;
            inArray = _srcHammerUtilsJs.inArray;
            inStr = _srcHammerUtilsJs.inStr;
            prefixed = _srcHammerUtilsJs.prefixed;
            removeEventListeners = _srcHammerUtilsJs.removeEventListeners;
            splitStr = _srcHammerUtilsJs.splitStr;
            TEST_ELEMENT = _srcHammerUtilsJs.TEST_ELEMENT;
            toArray = _srcHammerUtilsJs.toArray;
            uniqueArray = _srcHammerUtilsJs.uniqueArray;
            uniqueId = _srcHammerUtilsJs.uniqueId;
        }],
        execute: function () {
            "use strict";

            _export('decodeEventType', decodeEventType);

            _export('getDistance', getDistance);

            _export('stateStr', stateStr);

            _export('stateDecode', stateDecode);

            _export('directionStr', directionStr);

            TOUCH_ACTION_COMPUTE = 'compute';

            _export('TOUCH_ACTION_COMPUTE', TOUCH_ACTION_COMPUTE);

            TOUCH_ACTION_AUTO = 'auto';

            _export('TOUCH_ACTION_AUTO', TOUCH_ACTION_AUTO);

            TOUCH_ACTION_MANIPULATION = 'manipulation';

            _export('TOUCH_ACTION_MANIPULATION', TOUCH_ACTION_MANIPULATION);

            TOUCH_ACTION_NONE = 'none';

            _export('TOUCH_ACTION_NONE', TOUCH_ACTION_NONE);

            TOUCH_ACTION_PAN_X = 'pan-x';

            _export('TOUCH_ACTION_PAN_X', TOUCH_ACTION_PAN_X);

            TOUCH_ACTION_PAN_Y = 'pan-y';

            _export('TOUCH_ACTION_PAN_Y', TOUCH_ACTION_PAN_Y);

            STOP = 1;
            FORCED_STOP = 2;

            VectorE2 = (function () {
                function VectorE2(x, y) {
                    _classCallCheck(this, VectorE2);

                    this.x = x;
                    this.y = y;
                }

                _createClass(VectorE2, [{
                    key: 'add',
                    value: function add(other) {
                        return new VectorE2(this.x + other.x, this.y + other.y);
                    }
                }, {
                    key: 'sub',
                    value: function sub(other) {
                        return new VectorE2(this.x - other.x, this.y - other.y);
                    }
                }, {
                    key: 'div',
                    value: function div(other) {
                        return new VectorE2(this.x / other, this.y / other);
                    }
                }, {
                    key: 'dot',
                    value: function dot(other) {
                        return this.x * other.x + this.y * other.y;
                    }
                }, {
                    key: 'norm',
                    value: function norm() {
                        return Math.sqrt(this.quadrance());
                    }
                }, {
                    key: 'quadrance',
                    value: function quadrance() {
                        return this.x * this.x + this.y * this.y;
                    }
                }, {
                    key: 'toString',
                    value: function toString() {
                        return 'VectorE2(' + this.x + ', ' + this.y + ')';
                    }
                }]);

                return VectorE2;
            })();

            _export('VectorE2', VectorE2);

            ClientLocation = (function () {
                function ClientLocation(clientX, clientY) {
                    _classCallCheck(this, ClientLocation);

                    this.clientX = clientX;
                    this.clientY = clientY;
                }

                _createClass(ClientLocation, [{
                    key: 'moveTo',
                    value: function moveTo(clientX, clientY) {
                        this.clientX = clientX;
                        this.clientY = clientY;
                    }
                }, {
                    key: 'sub',
                    value: function sub(other) {
                        return new VectorE2(this.clientX - other.clientX, this.clientY - other.clientY);
                    }
                }, {
                    key: 'toString',
                    value: function toString() {
                        return 'ClientLocation(' + this.clientX + ', ' + this.clientY + ')';
                    }
                }], [{
                    key: 'fromTouch',
                    value: function fromTouch(touch) {
                        return new ClientLocation(touch.clientX, touch.clientY);
                    }
                }]);

                return ClientLocation;
            })();

            _export('ClientLocation', ClientLocation);

            Session = (function () {
                function Session() {
                    _classCallCheck(this, Session);

                    this.compEvents = [];
                    this.reset();
                }

                _createClass(Session, [{
                    key: 'reset',
                    value: function reset() {
                        this.startTime = Date.now();
                        this.compEvents = [];
                        this.curRecognizer = undefined;
                    }
                }, {
                    key: 'push',
                    value: function push(compEvent) {
                        this.compEvents.push(compEvent);
                    }
                }, {
                    key: 'computeMovement',
                    value: function computeMovement(center) {
                        if (center) {
                            if (this.compEvents.length > 0) {
                                var prev = this.compEvents[this.compEvents.length - 1];
                                return center.sub(prev.center);
                            } else {
                                return undefined;
                            }
                        } else {
                            return undefined;
                        }
                    }
                }, {
                    key: 'computeVelocity',
                    value: function computeVelocity(center, deltaTime) {
                        if (center) {
                            if (this.compEvents.length > 0) {
                                var prev = this.compEvents[this.compEvents.length - 1];
                                return center.sub(prev.center).div(deltaTime - prev.deltaTime);
                            } else {
                                return undefined;
                            }
                        } else {
                            return undefined;
                        }
                    }
                }]);

                return Session;
            })();

            _export('Session', Session);

            Manager = (function () {
                function Manager(element) {
                    _classCallCheck(this, Manager);

                    this.handlers = {};
                    this.session = new Session();
                    this.recognizers = [];
                    this.domEvents = false;
                    this.enable = true;
                    this.cssProps = {};
                    this.element = element;
                    this.inputTarget = element;
                    this.input = new TouchInput(this, inputHandler);
                    this.touchAction = new TouchAction(this, TOUCH_ACTION_COMPUTE);
                    this.toggleCssProps(true);
                }

                _createClass(Manager, [{
                    key: 'stop',
                    value: function stop(force) {
                        this.session.stopped = force ? FORCED_STOP : STOP;
                    }
                }, {
                    key: 'recognize',
                    value: function recognize(inputData, touchEvent) {
                        var session = this.session;
                        if (session.stopped) {
                            return;
                        }
                        this.touchAction.preventDefaults(inputData, touchEvent);
                        var recognizer;
                        var recognizers = this.recognizers;
                        var curRecognizer = session.curRecognizer;
                        if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                            curRecognizer = session.curRecognizer = null;
                        }
                        var i = 0;
                        while (i < recognizers.length) {
                            recognizer = recognizers[i];
                            if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                                recognizer.recognize(inputData);
                            } else {
                                recognizer.reset();
                            }
                            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_RECOGNIZED)) {
                                curRecognizer = session.curRecognizer = recognizer;
                            }
                            i++;
                        }
                    }
                }, {
                    key: 'get',
                    value: function get(eventName) {
                        var recognizers = this.recognizers;
                        for (var i = 0; i < recognizers.length; i++) {
                            if (recognizers[i].eventName === eventName) {
                                return recognizers[i];
                            }
                        }
                        return null;
                    }
                }, {
                    key: 'add',
                    value: function add(recognizer) {
                        var existing = this.get(recognizer.eventName);
                        if (existing) {
                            this.remove(existing);
                        }
                        this.recognizers.push(recognizer);
                        recognizer.manager = this;
                        this.touchAction.update();
                        return recognizer;
                    }
                }, {
                    key: 'remove',
                    value: function remove(recognizer) {
                        var recognizers = this.recognizers;
                        recognizer = this.get(recognizer.eventName);
                        recognizers.splice(inArray(recognizers, recognizer), 1);
                        this.touchAction.update();
                        return this;
                    }
                }, {
                    key: 'on',
                    value: function on(events, handler) {
                        var handlers = this.handlers;
                        each(splitStr(events), function (event) {
                            handlers[event] = handlers[event] || [];
                            handlers[event].push(handler);
                        });
                        return this;
                    }
                }, {
                    key: 'off',
                    value: function off(events, handler) {
                        var handlers = this.handlers;
                        each(splitStr(events), function (event) {
                            if (!handler) {
                                delete handlers[event];
                            } else {
                                handlers[event].splice(inArray(handlers[event], handler), 1);
                            }
                        });
                        return this;
                    }
                }, {
                    key: 'emit',
                    value: function emit(eventName, data) {
                        if (this.domEvents) {
                            triggerDomEvent(event, data);
                        }
                        var handlers = this.handlers[eventName] && this.handlers[eventName].slice();
                        if (!handlers || !handlers.length) {
                            return;
                        }
                        var i = 0;
                        while (i < handlers.length) {
                            handlers[i](data);
                            i++;
                        }
                    }
                }, {
                    key: 'updateTouchAction',
                    value: function updateTouchAction() {
                        this.touchAction.update();
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.element && this.toggleCssProps(false);
                        this.handlers = {};
                        this.session = undefined;
                        this.input.destroy();
                        this.element = null;
                    }
                }, {
                    key: 'toggleCssProps',
                    value: function toggleCssProps(add) {
                        if (!this.element.style) {
                            return;
                        }
                        var element = this.element;
                        each(this.cssProps, function (value, name) {
                            element.style[prefixed(element.style, name)] = add ? value : '';
                        });
                    }
                }, {
                    key: 'cancelContextMenu',
                    value: function cancelContextMenu() {}
                }]);

                return Manager;
            })();

            _export('Manager', Manager);

            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            SUPPORT_TOUCH = 'ontouchstart' in window;
            SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

            TouchAction = (function () {
                function TouchAction(manager, value) {
                    _classCallCheck(this, TouchAction);

                    this.manager = manager;
                    this.set(value);
                }

                _createClass(TouchAction, [{
                    key: 'set',
                    value: function set(value) {
                        if (value === TOUCH_ACTION_COMPUTE) {
                            value = this.compute();
                        }
                        if (NATIVE_TOUCH_ACTION && this.manager.element.style) {
                            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                        }
                        this.actions = value.toLowerCase().trim();
                    }
                }, {
                    key: 'update',
                    value: function update() {
                        this.set(TOUCH_ACTION_COMPUTE);
                    }
                }, {
                    key: 'compute',
                    value: function compute() {
                        var actions = [];
                        each(this.manager.recognizers, function (recognizer) {
                            if (recognizer.enabled) {
                                actions = actions.concat(recognizer.getTouchAction());
                            }
                        });
                        return cleanTouchActions(actions.join(' '));
                    }
                }, {
                    key: 'preventDefaults',
                    value: function preventDefaults(input, touchEvent) {
                        if (NATIVE_TOUCH_ACTION) {
                            return;
                        }
                        if (this.prevented) {
                            touchEvent.preventDefault();
                            return;
                        }
                    }
                }, {
                    key: 'preventSrc',
                    value: function preventSrc(srcEvent) {
                        this.prevented = true;
                        srcEvent.preventDefault();
                    }
                }]);

                return TouchAction;
            })();

            INPUT_TYPE_TOUCH = 'touch';

            _export('INPUT_TYPE_TOUCH', INPUT_TYPE_TOUCH);

            INPUT_TYPE_PEN = 'pen';

            _export('INPUT_TYPE_PEN', INPUT_TYPE_PEN);

            INPUT_TYPE_MOUSE = 'mouse';

            _export('INPUT_TYPE_MOUSE', INPUT_TYPE_MOUSE);

            INPUT_TYPE_KINECT = 'kinect';

            _export('INPUT_TYPE_KINECT', INPUT_TYPE_KINECT);

            COMPUTE_INTERVAL = 25;
            INPUT_START = 1;

            _export('INPUT_START', INPUT_START);

            INPUT_MOVE = 2;

            _export('INPUT_MOVE', INPUT_MOVE);

            INPUT_END = 4;

            _export('INPUT_END', INPUT_END);

            INPUT_CANCEL = 8;

            _export('INPUT_CANCEL', INPUT_CANCEL);

            DIRECTION_UNDEFINED = 0;

            _export('DIRECTION_UNDEFINED', DIRECTION_UNDEFINED);

            DIRECTION_LEFT = 1;

            _export('DIRECTION_LEFT', DIRECTION_LEFT);

            DIRECTION_RIGHT = 2;

            _export('DIRECTION_RIGHT', DIRECTION_RIGHT);

            DIRECTION_UP = 4;

            _export('DIRECTION_UP', DIRECTION_UP);

            DIRECTION_DOWN = 8;

            _export('DIRECTION_DOWN', DIRECTION_DOWN);

            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;

            _export('DIRECTION_HORIZONTAL', DIRECTION_HORIZONTAL);

            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;

            _export('DIRECTION_VERTICAL', DIRECTION_VERTICAL);

            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

            _export('DIRECTION_ALL', DIRECTION_ALL);

            PROPS_XY = ['x', 'y'];
            PROPS_CLIENT_XY = ['clientX', 'clientY'];

            Input = (function () {
                function Input(manager, touchElementEvents, touchTargetEvents, touchWindowEvents) {
                    _classCallCheck(this, Input);

                    var self = this;
                    this.manager = manager;
                    this.evEl = touchElementEvents;
                    this.evTarget = touchTargetEvents;
                    this.evWin = touchWindowEvents;
                    this.element = manager.element;
                    this.target = manager.inputTarget;
                    this.domHandler = function (event) {
                        if (manager.enable) {
                            self.handler(event);
                        }
                    };
                    this.init();
                }

                _createClass(Input, [{
                    key: 'handler',
                    value: function handler(event) {}
                }, {
                    key: 'init',
                    value: function init() {
                        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                    }
                }]);

                return Input;
            })();

            TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

            TouchInput = (function (_Input) {
                _inherits(TouchInput, _Input);

                function TouchInput(manager, callback) {
                    _classCallCheck(this, TouchInput);

                    _get(Object.getPrototypeOf(TouchInput.prototype), 'constructor', this).call(this, manager, undefined, TOUCH_TARGET_EVENTS, undefined);
                    this.targetIds = {};
                    this.callback = callback;
                }

                _createClass(TouchInput, [{
                    key: 'handler',
                    value: function handler(event) {
                        var eventType = TOUCH_INPUT_MAP[event.type];
                        this.callback(this.manager, eventType, event);
                    }
                }]);

                return TouchInput;
            })(Input);

            STATE_UNDEFINED = 0;

            _export('STATE_UNDEFINED', STATE_UNDEFINED);

            STATE_POSSIBLE = 1;

            _export('STATE_POSSIBLE', STATE_POSSIBLE);

            STATE_BEGAN = 2;

            _export('STATE_BEGAN', STATE_BEGAN);

            STATE_CHANGED = 4;

            _export('STATE_CHANGED', STATE_CHANGED);

            STATE_RECOGNIZED = 8;

            _export('STATE_RECOGNIZED', STATE_RECOGNIZED);

            STATE_CANCELLED = 16;

            _export('STATE_CANCELLED', STATE_CANCELLED);

            STATE_FAILED = 32;

            _export('STATE_FAILED', STATE_FAILED);

            Recognizer = (function () {
                function Recognizer(eventName, enabled) {
                    _classCallCheck(this, Recognizer);

                    this.simultaneous = {};
                    this.requireFail = [];
                    this.eventName = eventName;
                    this.enabled = enabled;
                    this.id = uniqueId();
                    this.manager = null;
                    this.state = STATE_POSSIBLE;
                }

                _createClass(Recognizer, [{
                    key: 'set',
                    value: function set(options) {
                        this.manager && this.manager.updateTouchAction();
                        return this;
                    }
                }, {
                    key: 'recognizeWith',
                    value: function recognizeWith(otherRecognizer) {
                        var simultaneous = this.simultaneous;
                        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
                        if (!simultaneous[otherRecognizer.id]) {
                            simultaneous[otherRecognizer.id] = otherRecognizer;
                            otherRecognizer.recognizeWith(this);
                        }
                        return this;
                    }
                }, {
                    key: 'dropRecognizeWith',
                    value: function dropRecognizeWith(otherRecognizer) {
                        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
                        delete this.simultaneous[otherRecognizer.id];
                        return this;
                    }
                }, {
                    key: 'requireFailure',
                    value: function requireFailure(otherRecognizer) {
                        var requireFail = this.requireFail;
                        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
                        if (inArray(requireFail, otherRecognizer) === -1) {
                            requireFail.push(otherRecognizer);
                            otherRecognizer.requireFailure(this);
                        }
                        return this;
                    }
                }, {
                    key: 'dropRequireFailure',
                    value: function dropRequireFailure(otherRecognizer) {
                        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this.manager);
                        var index = inArray(this.requireFail, otherRecognizer);
                        if (index > -1) {
                            this.requireFail.splice(index, 1);
                        }
                        return this;
                    }
                }, {
                    key: 'hasRequireFailures',
                    value: function hasRequireFailures() {
                        return this.requireFail.length > 0;
                    }
                }, {
                    key: 'canRecognizeWith',
                    value: function canRecognizeWith(otherRecognizer) {
                        return !!this.simultaneous[otherRecognizer.id];
                    }
                }, {
                    key: 'emit',
                    value: function emit() {
                        var self = this;
                        var state = this.state;
                        function emit(withState) {
                            var eventName = self.eventName + (withState ? stateStr(state) : '');
                            self.manager.emit(eventName, undefined);
                        }
                        if (state < STATE_RECOGNIZED) {
                            emit(true);
                        }
                        emit(false);
                        if (state >= STATE_RECOGNIZED) {
                            emit(true);
                        }
                    }
                }, {
                    key: 'tryEmit',
                    value: function tryEmit() {
                        if (this.canEmit()) {
                            return this.emit();
                        } else {}
                        this.state = STATE_FAILED;
                    }
                }, {
                    key: 'canEmit',
                    value: function canEmit() {
                        var i = 0;
                        while (i < this.requireFail.length) {
                            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                                return false;
                            }
                            i++;
                        }
                        return true;
                    }
                }, {
                    key: 'recognize',
                    value: function recognize(compEvent) {
                        if (!this.enabled) {
                            this.reset();
                            this.state = STATE_FAILED;
                            return;
                        }
                        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                            this.state = STATE_POSSIBLE;
                        }
                        this.state = this.process(compEvent);
                        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_RECOGNIZED | STATE_CANCELLED)) {
                            this.tryEmit();
                        }
                    }
                }, {
                    key: 'process',
                    value: function process(inputData) {
                        return STATE_UNDEFINED;
                    }
                }, {
                    key: 'getTouchAction',
                    value: function getTouchAction() {
                        return [];
                    }
                }, {
                    key: 'reset',
                    value: function reset() {}
                }]);

                return Recognizer;
            })();

            _export('Recognizer', Recognizer);
        }
    };
});
System.register('src/hammer/utils.js', ['npm:babel-runtime@5.8.34/core-js/object/keys', 'npm:babel-runtime@5.8.34/core-js/object/create'], function (_export) {
    var _Object$keys, _Object$create, VENDOR_PREFIXES, TEST_ELEMENT, TYPE_FUNCTION, round, abs, now, _uniqueId;

    function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
    }

    function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
        }
        return false;
    }

    function each(obj, iterator, context) {
        var i;
        if (!obj) {
            return;
        }
        if (obj.forEach) {
            obj.forEach(iterator, context);
        } else if (obj.length !== undefined) {
            i = 0;
            while (i < obj.length) {
                iterator.call(context, obj[i], i, obj);
                i++;
            }
        } else {
            for (i in obj) {
                obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
        }
    }

    function extend(dest, src, merge) {
        var keys = _Object$keys(src);
        var i = 0;
        while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
                dest[keys[i]] = src[keys[i]];
            }
            i++;
        }
        return dest;
    }

    function merge(dest, src) {
        return extend(dest, src, true);
    }

    function inherit(child, base, properties) {
        var baseP = base.prototype,
            childP;
        childP = child.prototype = _Object$create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
            extend(childP, properties);
        }
    }

    function bindFn(fn, context) {
        return function boundFn() {
            return fn.apply(context, arguments);
        };
    }

    function ifUndefined(val1, val2) {
        return val1 === undefined ? val2 : val1;
    }

    function addEventListeners(eventTarget, types, handler) {
        each(splitStr(types), function (type) {
            eventTarget.addEventListener(type, handler, false);
        });
    }

    function removeEventListeners(eventTarget, types, handler) {
        each(splitStr(types), function (type) {
            eventTarget.removeEventListener(type, handler, false);
        });
    }

    function hasParent(node, parent) {
        while (node) {
            if (node == parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    function inStr(str, find) {
        return str.indexOf(find) > -1;
    }

    function splitStr(str) {
        return str.trim().split(/\s+/g);
    }

    function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
            return src.indexOf(find);
        } else {
            var i = 0;
            while (i < src.length) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                    return i;
                }
                i++;
            }
            return -1;
        }
    }

    function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
    }

    function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
            var val = key ? src[i][key] : src[i];
            if (inArray(values, val) < 0) {
                results.push(src[i]);
            }
            values[i] = val;
            i++;
        }
        if (sort) {
            if (!key) {
                results = results.sort();
            } else {
                results = results.sort(function sortUniqueArray(a, b) {
                    return a[key] > b[key] ? 1 : 0;
                });
            }
        }
        return results;
    }

    function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
                return prop;
            }
            i++;
        }
        return undefined;
    }

    function uniqueId() {
        return _uniqueId++;
    }

    function getWindowForElement(element) {
        var doc = element.ownerDocument;
        if (doc) {
            return doc.defaultView || window;
        } else {
            return window;
        }
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys['default'];
        }, function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate['default'];
        }],
        execute: function () {
            'use strict';

            _export('setTimeoutContext', setTimeoutContext);

            _export('invokeArrayArg', invokeArrayArg);

            _export('each', each);

            _export('extend', extend);

            _export('merge', merge);

            _export('inherit', inherit);

            _export('bindFn', bindFn);

            _export('ifUndefined', ifUndefined);

            _export('addEventListeners', addEventListeners);

            _export('removeEventListeners', removeEventListeners);

            _export('hasParent', hasParent);

            _export('inStr', inStr);

            _export('splitStr', splitStr);

            _export('inArray', inArray);

            _export('toArray', toArray);

            _export('uniqueArray', uniqueArray);

            _export('prefixed', prefixed);

            _export('uniqueId', uniqueId);

            _export('getWindowForElement', getWindowForElement);

            VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];
            TEST_ELEMENT = document.createElement('div');

            _export('TEST_ELEMENT', TEST_ELEMENT);

            TYPE_FUNCTION = 'function';
            round = Math.round;
            abs = Math.abs;
            now = Date.now;
            _uniqueId = 1;
        }
    };
});
System.register('src/hammer/recognizers/tap.js', ['npm:babel-runtime@5.8.34/helpers/get', 'npm:babel-runtime@5.8.34/helpers/inherits', 'npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'src/hammer/hammer.js', 'src/hammer/utils.js'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, decodeEventType, getDistance, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, Recognizer, STATE_BEGAN, STATE_FAILED, STATE_RECOGNIZED, TOUCH_ACTION_MANIPULATION, setTimeoutContext, TapRecognizer;

    function isCorrectTouchCount(input) {
        switch (input.eventType) {
            case INPUT_START:
                {
                    return input.touchesLength === 1;
                }
                break;
            case INPUT_MOVE:
                {
                    return input.touchesLength === 1;
                }
                break;
            case INPUT_END:
                {
                    return input.touchesLength === 0;
                }
                break;
            case INPUT_CANCEL:
                {
                    return true;
                }
                break;
            default:
                {
                    throw new Error(decodeEventType(input.eventType));
                }
        }
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet['default'];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits['default'];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_srcHammerHammerJs) {
            decodeEventType = _srcHammerHammerJs.decodeEventType;
            getDistance = _srcHammerHammerJs.getDistance;
            INPUT_START = _srcHammerHammerJs.INPUT_START;
            INPUT_MOVE = _srcHammerHammerJs.INPUT_MOVE;
            INPUT_END = _srcHammerHammerJs.INPUT_END;
            INPUT_CANCEL = _srcHammerHammerJs.INPUT_CANCEL;
            Recognizer = _srcHammerHammerJs.Recognizer;
            STATE_BEGAN = _srcHammerHammerJs.STATE_BEGAN;
            STATE_FAILED = _srcHammerHammerJs.STATE_FAILED;
            STATE_RECOGNIZED = _srcHammerHammerJs.STATE_RECOGNIZED;
            TOUCH_ACTION_MANIPULATION = _srcHammerHammerJs.TOUCH_ACTION_MANIPULATION;
        }, function (_srcHammerUtilsJs) {
            setTimeoutContext = _srcHammerUtilsJs.setTimeoutContext;
        }],
        execute: function () {
            "use strict";

            TapRecognizer = (function (_Recognizer) {
                _inherits(TapRecognizer, _Recognizer);

                function TapRecognizer(eventName, enabled) {
                    _classCallCheck(this, TapRecognizer);

                    _get(Object.getPrototypeOf(TapRecognizer.prototype), 'constructor', this).call(this, eventName ? eventName : 'tap', enabled);
                    this.count = 0;
                    this.taps = 1;
                    this.pointers = 1;
                    this.time = 250;
                    this.threshold = 6;
                    this.interval = 300;
                    this.posThreshold = 10;
                }

                _createClass(TapRecognizer, [{
                    key: 'getTouchAction',
                    value: function getTouchAction() {
                        return [TOUCH_ACTION_MANIPULATION];
                    }
                }, {
                    key: 'process',
                    value: function process(input) {
                        this.reset();
                        if (!isCorrectTouchCount(input)) {
                            return STATE_FAILED;
                        }
                        if (input.eventType & INPUT_START && this.count === 0) {
                            this.center = input.center;
                            return this.failTimeout();
                        }
                        if (input.distance >= this.threshold) {
                            return STATE_FAILED;
                        }
                        if (input.deltaTime >= this.time) {
                            return STATE_FAILED;
                        }
                        if (input.eventType !== INPUT_END) {
                            this.center = input.center;
                            return this.failTimeout();
                        } else {}
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < this.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < this.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        var tapCount = this.count % this.taps;
                        if (tapCount === 0) {
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function () {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, this.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                        return STATE_FAILED;
                    }
                }, {
                    key: 'failTimeout',
                    value: function failTimeout() {
                        this._timer = setTimeoutContext(function () {
                            this.state = STATE_FAILED;
                        }, this.interval, this);
                        return STATE_FAILED;
                    }
                }, {
                    key: 'reset',
                    value: function reset() {
                        clearTimeout(this._timer);
                    }
                }, {
                    key: 'emit',
                    value: function emit() {
                        if (this.state === STATE_RECOGNIZED) {
                            this.manager.emit(this.eventName, this.center);
                        }
                    }
                }]);

                return TapRecognizer;
            })(Recognizer);

            _export('TapRecognizer', TapRecognizer);
        }
    };
});
System.register('src/touch/touch.js', ['src/hammer/hammer.js', 'src/hammer/recognizers/pan.js', 'src/hammer/recognizers/tap.js'], function (_export) {
    'use strict';

    var DIRECTION_VERTICAL, Manager, PanRecognizer, TapRecognizer;

    _export('touchManager', touchManager);

    function touchManager(editor) {
        var target = editor.renderer.getMouseEventTarget();
        var manager = new Manager(target);
        manager.add(new PanRecognizer('pan', true).setDirection(DIRECTION_VERTICAL).setThreshold(20));
        manager.add(new TapRecognizer('tap', true));
        manager.on('pan', function (movement) {
            editor.renderer.scrollBy(-movement.x, -movement.y);
        });
        manager.on('tap', function (event) {
            var pos = editor.renderer.screenToTextCoordinates(event.clientX, event.clientY);
            pos.row = Math.max(0, Math.min(pos.row, editor.getSession().getLength() - 1));
            editor.moveCursorToPosition(pos);
            editor.renderer.scrollCursorIntoView();
            editor.focus();
        });
        return manager;
    }

    return {
        setters: [function (_srcHammerHammerJs) {
            DIRECTION_VERTICAL = _srcHammerHammerJs.DIRECTION_VERTICAL;
            Manager = _srcHammerHammerJs.Manager;
        }, function (_srcHammerRecognizersPanJs) {
            PanRecognizer = _srcHammerRecognizersPanJs.PanRecognizer;
        }, function (_srcHammerRecognizersTapJs) {
            TapRecognizer = _srcHammerRecognizersTapJs.TapRecognizer;
        }],
        execute: function () {}
    };
});
System.register("src/Tooltip.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js"], function (_export) {
    var _createClass, _classCallCheck, addCssClass, createElement, setInnerText, Tooltip;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            addCssClass = _srcLibDomJs.addCssClass;
            createElement = _srcLibDomJs.createElement;
            setInnerText = _srcLibDomJs.setInnerText;
        }],
        execute: function () {
            "use strict";

            Tooltip = (function () {
                function Tooltip(parentElement) {
                    _classCallCheck(this, Tooltip);

                    this.isOpen = false;
                    this.$element = null;
                    this.$parentElement = parentElement;
                }

                _createClass(Tooltip, [{
                    key: "$init",
                    value: function $init() {
                        this.$element = createElement('div');
                        this.$element.className = "ace_tooltip";
                        this.$element.style.display = "none";
                        this.$parentElement.appendChild(this.$element);
                        return this.$element;
                    }
                }, {
                    key: "getElement",
                    value: function getElement() {
                        return this.$element || this.$init();
                    }
                }, {
                    key: "setText",
                    value: function setText(text) {
                        setInnerText(this.getElement(), text);
                    }
                }, {
                    key: "setHtml",
                    value: function setHtml(html) {
                        this.getElement().innerHTML = html;
                    }
                }, {
                    key: "setPosition",
                    value: function setPosition(left, top) {
                        var style = this.getElement().style;
                        style.left = left + "px";
                        style.top = top + "px";
                    }
                }, {
                    key: "setClassName",
                    value: function setClassName(className) {
                        addCssClass(this.getElement(), className);
                    }
                }, {
                    key: "show",
                    value: function show(text, left, top) {
                        if (typeof text === 'string') {
                            this.setText(text);
                        }
                        if (typeof left === 'number' && typeof top === 'number') {
                            this.setPosition(left, top);
                        }
                        if (!this.isOpen) {
                            this.getElement().style.display = 'block';
                            this.isOpen = true;
                        }
                    }
                }, {
                    key: "hide",
                    value: function hide() {
                        if (this.isOpen) {
                            this.getElement().style.display = 'none';
                            this.isOpen = false;
                        }
                    }
                }, {
                    key: "getHeight",
                    value: function getHeight() {
                        return this.getElement().offsetHeight;
                    }
                }, {
                    key: "getWidth",
                    value: function getWidth() {
                        return this.getElement().offsetWidth;
                    }
                }]);

                return Tooltip;
            })();

            _export("default", Tooltip);
        }
    };
});
System.register("src/Editor.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "src/lib/oop.js", "src/lib/dom.js", "src/lib/lang.js", "src/lib/useragent.js", "src/keyboard/KeyBinding.js", "src/keyboard/TextInput.js", "src/Search.js", "src/Range.js", "src/lib/EventEmitterClass.js", "src/commands/CommandManager.js", "src/commands/default_commands.js", "src/config.js", "src/TokenIterator.js", "src/editor_protocol.js", "src/lib/event.js", "src/touch/touch.js", "src/Tooltip.js"], function (_export) {
    var _createClass, _classCallCheck, _get, _inherits, mixin, computedStyle, hasCssClass, setCssClass, delayedCall, stringRepeat, isIE, isMac, isMobile, isOldIE, isWebKit, KeyBinding, TextInput, Search, Range, EventEmitterClass, CommandManager, defaultCommands, defineOptions, loadModule, resetOptions, TokenIterator, COMMAND_NAME_AUTO_COMPLETE, addListener, addMouseWheelListener, addMultiMouseDownListener, capture, _getButton, _preventDefault, stopEvent, _stopPropagation, touchManager, Tooltip, Editor, FoldHandler, MouseHandler, EditorMouseEvent, DRAG_OFFSET, GutterHandler, GutterTooltip;

    function makeMouseDownHandler(editor, mouseHandler) {
        return function (ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            mouseHandler.mousedownEvent = ev;
            var button = ev.getButton();
            if (button !== 0) {
                var selectionRange = editor.getSelectionRange();
                var selectionEmpty = selectionRange.isEmpty();
                if (selectionEmpty) editor.selection.moveToPosition(pos);
                editor.textInput.onContextMenu(ev.domEvent);
                return;
            }
            mouseHandler.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
                editor.focus();
                if (mouseHandler.$focusTimout && !mouseHandler.$clickSelection && !editor.inMultiSelectMode) {
                    mouseHandler.setState("focusWait");
                    mouseHandler.captureMouse(ev);
                    return;
                }
            }
            mouseHandler.captureMouse(ev);
            mouseHandler.startSelect(pos, ev.domEvent['_clicks'] > 1);
            return ev.preventDefault();
        };
    }
    function makeMouseWheelHandler(editor, mouseHandler) {
        return function (ev) {
            if (ev.getAccelKey()) {
                return;
            }
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                ev.wheelX = ev.wheelY;
                ev.wheelY = 0;
            }
            var t = ev.domEvent.timeStamp;
            var dt = t - (mouseHandler.$lastScrollTime || 0);
            var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            if (isScrolable || dt < 200) {
                mouseHandler.$lastScrollTime = t;
                editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                return ev.stop();
            }
        };
    }
    function makeDoubleClickHandler(editor, mouseHandler) {
        return function (editorMouseEvent) {
            var pos = editorMouseEvent.getDocumentPosition();
            var session = editor.getSession();
            var range = session.getBracketRange(pos);
            if (range) {
                if (range.isEmpty()) {
                    range.start.column--;
                    range.end.column++;
                }
                mouseHandler.setState("select");
            } else {
                range = editor.selection.getWordRange(pos.row, pos.column);
                mouseHandler.setState("selectByWords");
            }
            mouseHandler.$clickSelection = range;
            mouseHandler.select();
        };
    }
    function makeTripleClickHandler(editor, mouseHandler) {
        return function (editorMouseEvent) {
            var pos = editorMouseEvent.getDocumentPosition();
            mouseHandler.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                mouseHandler.$clickSelection = editor.selection.getLineRange(range.start.row);
                mouseHandler.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
                mouseHandler.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            mouseHandler.select();
        };
    }
    function makeQuadClickHandler(editor, mouseHandler) {
        return function (editorMouseEvent) {
            editor.selectAll();
            mouseHandler.$clickSelection = editor.getSelectionRange();
            mouseHandler.setState("selectAll");
        };
    }
    function makeExtendSelectionBy(editor, mouseHandler, unitName) {
        return function () {
            var anchor;
            var cursor = mouseHandler.textCoordinates();
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (mouseHandler.$clickSelection) {
                var cmpStart = mouseHandler.$clickSelection.comparePoint(range.start);
                var cmpEnd = mouseHandler.$clickSelection.comparePoint(range.end);
                if (cmpStart == -1 && cmpEnd <= 0) {
                    anchor = mouseHandler.$clickSelection.end;
                    if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                } else if (cmpEnd == 1 && cmpStart >= 0) {
                    anchor = mouseHandler.$clickSelection.start;
                    if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                } else if (cmpStart == -1 && cmpEnd == 1) {
                    cursor = range.end;
                    anchor = range.start;
                } else {
                    var orientedRange = calcRangeOrientation(mouseHandler.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };
    }
    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row) {
            var cmp = 2 * cursor.column - range.start.column - range.end.column;
        } else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) {
            var cmp = cursor.column - 4;
        } else {
            var cmp = 2 * cursor.row - range.start.row - range.end.row;
        }
        if (cmp < 0) {
            return { cursor: range.start, anchor: range.end };
        } else {
            return { cursor: range.end, anchor: range.start };
        }
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_srcLibOopJs) {
            mixin = _srcLibOopJs.mixin;
        }, function (_srcLibDomJs) {
            computedStyle = _srcLibDomJs.computedStyle;
            hasCssClass = _srcLibDomJs.hasCssClass;
            setCssClass = _srcLibDomJs.setCssClass;
        }, function (_srcLibLangJs) {
            delayedCall = _srcLibLangJs.delayedCall;
            stringRepeat = _srcLibLangJs.stringRepeat;
        }, function (_srcLibUseragentJs) {
            isIE = _srcLibUseragentJs.isIE;
            isMac = _srcLibUseragentJs.isMac;
            isMobile = _srcLibUseragentJs.isMobile;
            isOldIE = _srcLibUseragentJs.isOldIE;
            isWebKit = _srcLibUseragentJs.isWebKit;
        }, function (_srcKeyboardKeyBindingJs) {
            KeyBinding = _srcKeyboardKeyBindingJs["default"];
        }, function (_srcKeyboardTextInputJs) {
            TextInput = _srcKeyboardTextInputJs["default"];
        }, function (_srcSearchJs) {
            Search = _srcSearchJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }, function (_srcCommandsCommandManagerJs) {
            CommandManager = _srcCommandsCommandManagerJs["default"];
        }, function (_srcCommandsDefault_commandsJs) {
            defaultCommands = _srcCommandsDefault_commandsJs["default"];
        }, function (_srcConfigJs) {
            defineOptions = _srcConfigJs.defineOptions;
            loadModule = _srcConfigJs.loadModule;
            resetOptions = _srcConfigJs.resetOptions;
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }, function (_srcEditor_protocolJs) {
            COMMAND_NAME_AUTO_COMPLETE = _srcEditor_protocolJs.COMMAND_NAME_AUTO_COMPLETE;
        }, function (_srcLibEventJs) {
            addListener = _srcLibEventJs.addListener;
            addMouseWheelListener = _srcLibEventJs.addMouseWheelListener;
            addMultiMouseDownListener = _srcLibEventJs.addMultiMouseDownListener;
            capture = _srcLibEventJs.capture;
            _getButton = _srcLibEventJs.getButton;
            _preventDefault = _srcLibEventJs.preventDefault;
            stopEvent = _srcLibEventJs.stopEvent;
            _stopPropagation = _srcLibEventJs.stopPropagation;
        }, function (_srcTouchTouchJs) {
            touchManager = _srcTouchTouchJs.touchManager;
        }, function (_srcTooltipJs) {
            Tooltip = _srcTooltipJs["default"];
        }],
        execute: function () {
            "use strict";

            Editor = (function () {
                function Editor(renderer, session) {
                    _classCallCheck(this, Editor);

                    this.eventBus = new EventEmitterClass(this);
                    this.curOp = null;
                    this.prevOp = {};
                    this.$mergeableCommands = ["backspace", "del", "insertstring"];
                    this.commands = new CommandManager(isMac ? "mac" : "win", defaultCommands);
                    this.container = renderer.getContainerElement();
                    this.renderer = renderer;
                    this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                    this.renderer.textarea = this.textInput.getElement();
                    this.keyBinding = new KeyBinding(this);
                    if (isMobile) {
                        this.$touchHandler = touchManager(this);
                        this.$mouseHandler = new MouseHandler(this);
                    } else {
                        this.$touchHandler = touchManager(this);
                        this.$mouseHandler = new MouseHandler(this);
                    }
                    new FoldHandler(this);
                    this.$blockScrolling = 0;
                    this.$search = new Search().set({ wrap: true });
                    this.$historyTracker = this.$historyTracker.bind(this);
                    this.commands.on("exec", this.$historyTracker);
                    this.$initOperationListeners();
                    this._$emitInputEvent = delayedCall((function () {
                        this._signal("input", {});
                        this.session.bgTokenizer && this.session.bgTokenizer.scheduleStart();
                    }).bind(this));
                    var self = this;
                    this.on("change", function () {
                        self._$emitInputEvent.schedule(31);
                    });
                    this.setSession(session);
                    resetOptions(this);
                }

                _createClass(Editor, [{
                    key: "cancelMouseContextMenu",
                    value: function cancelMouseContextMenu() {
                        this.$mouseHandler.cancelContextMenu();
                    }
                }, {
                    key: "$initOperationListeners",
                    value: function $initOperationListeners() {
                        var _this = this;

                        function last(a) {
                            return a[a.length - 1];
                        }
                        this.selections = [];
                        this.commands.on("exec", function (e) {
                            _this.startOperation(e);
                            var command = e.command;
                            if (command.aceCommandGroup === "fileJump") {
                                var prev = _this.prevOp;
                                if (!prev || prev.command.aceCommandGroup !== "fileJump") {
                                    _this.lastFileJumpPos = last(_this.selections);
                                }
                            } else {
                                _this.lastFileJumpPos = null;
                            }
                        }, true);
                        this.commands.on("afterExec", function (e, cm) {
                            var command = e.command;
                            if (command.aceCommandGroup === "fileJump") {
                                if (_this.lastFileJumpPos && !_this.curOp.selectionChanged) {
                                    _this.selection.fromJSON(_this.lastFileJumpPos);
                                }
                            }
                            _this.endOperation(e);
                        }, true);
                        this.$opResetTimer = delayedCall(this.endOperation.bind(this));
                        this.eventBus.on("change", function () {
                            _this.curOp || _this.startOperation();
                            _this.curOp.docChanged = true;
                        }, true);
                        this.eventBus.on("changeSelection", function () {
                            _this.curOp || _this.startOperation();
                            _this.curOp.selectionChanged = true;
                        }, true);
                    }
                }, {
                    key: "startOperation",
                    value: function startOperation(commandEvent) {
                        if (this.curOp) {
                            if (!commandEvent || this.curOp.command) return;
                            this.prevOp = this.curOp;
                        }
                        if (!commandEvent) {
                            this.previousCommand = null;
                            commandEvent = {};
                        }
                        this.$opResetTimer.schedule();
                        this.curOp = {
                            command: commandEvent.command || {},
                            args: commandEvent.args,
                            scrollTop: this.renderer.scrollTop
                        };
                        var command = this.curOp.command;
                        if (command && command.scrollIntoView) this.$blockScrolling++;
                        this.selections.push(this.selection.toJSON());
                    }
                }, {
                    key: "endOperation",
                    value: function endOperation(unused) {
                        if (this.curOp) {
                            var command = this.curOp.command;
                            if (command && command.scrollIntoView) {
                                this.$blockScrolling--;
                                switch (command.scrollIntoView) {
                                    case "center":
                                        this.renderer.scrollCursorIntoView(null, 0.5);
                                        break;
                                    case "animate":
                                    case "cursor":
                                        this.renderer.scrollCursorIntoView();
                                        break;
                                    case "selectionPart":
                                        var range = this.selection.getRange();
                                        var config = this.renderer.layerConfig;
                                        if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                                            this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                                        }
                                        break;
                                    default:
                                        break;
                                }
                                if (command.scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                            }
                            this.prevOp = this.curOp;
                            this.curOp = null;
                        }
                    }
                }, {
                    key: "$historyTracker",
                    value: function $historyTracker(e) {
                        if (!this.$mergeUndoDeltas) return;
                        var prev = this.prevOp;
                        var mergeableCommands = this.$mergeableCommands;
                        var shouldMerge = prev.command && e.command.name == prev.command.name;
                        if (e.command.name == "insertstring") {
                            var text = e.args;
                            if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;
                            shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
                            this.mergeNextCommand = true;
                        } else {
                            shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
                        }
                        if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
                            shouldMerge = false;
                        }
                        if (shouldMerge) this.session.mergeUndoDeltas = true;else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
                    }
                }, {
                    key: "setKeyboardHandler",
                    value: function setKeyboardHandler(keyboardHandler) {
                        if (!keyboardHandler) {
                            this.keyBinding.setKeyboardHandler(null);
                        } else if (typeof keyboardHandler === "string") {
                            this.$keybindingId = keyboardHandler;
                            var _self = this;
                            loadModule(["keybinding", keyboardHandler], function (module) {
                                if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module && module.handler);
                            }, this.container.ownerDocument);
                        } else {
                            this.$keybindingId = null;
                            this.keyBinding.setKeyboardHandler(keyboardHandler);
                        }
                    }
                }, {
                    key: "getKeyboardHandler",
                    value: function getKeyboardHandler() {
                        return this.keyBinding.getKeyboardHandler();
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        if (this.session === session) {
                            return;
                        }
                        var oldSession = this.session;
                        if (oldSession) {
                            this.session.off("change", this.$onDocumentChange);
                            this.session.off("changeMode", this.$onChangeMode);
                            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                            this.session.off("changeTabSize", this.$onChangeTabSize);
                            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                            this.session.off("changeWrapMode", this.$onChangeWrapMode);
                            this.session.off("onChangeFold", this.$onChangeFold);
                            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                            this.session.off("changeBackMarker", this.$onChangeBackMarker);
                            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                            this.session.off("changeAnnotation", this.$onChangeAnnotation);
                            this.session.off("changeOverwrite", this.$onCursorChange);
                            this.session.off("changeScrollTop", this.$onScrollTopChange);
                            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
                            var selection = this.session.getSelection();
                            selection.off("changeCursor", this.$onCursorChange);
                            selection.off("changeSelection", this.$onSelectionChange);
                        }
                        this.session = session;
                        if (session) {
                            this.$onDocumentChange = this.onDocumentChange.bind(this);
                            session.on("change", this.$onDocumentChange);
                            this.renderer.setSession(session);
                            this.$onChangeMode = this.onChangeMode.bind(this);
                            session.on("changeMode", this.$onChangeMode);
                            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
                            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                            session.on("changeTabSize", this.$onChangeTabSize);
                            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                            session.on("changeWrapLimit", this.$onChangeWrapLimit);
                            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                            session.on("changeWrapMode", this.$onChangeWrapMode);
                            this.$onChangeFold = this.onChangeFold.bind(this);
                            session.on("changeFold", this.$onChangeFold);
                            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                            session.on("changeFrontMarker", this.$onChangeFrontMarker);
                            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                            session.on("changeBackMarker", this.$onChangeBackMarker);
                            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                            session.on("changeBreakpoint", this.$onChangeBreakpoint);
                            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                            session.on("changeAnnotation", this.$onChangeAnnotation);
                            this.$onCursorChange = this.onCursorChange.bind(this);
                            session.on("changeOverwrite", this.$onCursorChange);
                            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                            session.on("changeScrollTop", this.$onScrollTopChange);
                            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                            session.on("changeScrollLeft", this.$onScrollLeftChange);
                            this.selection = session.getSelection();
                            this.selection.on("changeCursor", this.$onCursorChange);
                            this.$onSelectionChange = this.onSelectionChange.bind(this);
                            this.selection.on("changeSelection", this.$onSelectionChange);
                            this.onChangeMode(void 0, this.session);
                            this.$blockScrolling += 1;
                            this.onCursorChange(void 0, this.session);
                            this.$blockScrolling -= 1;
                            this.onScrollTopChange(void 0, this.session);
                            this.onScrollLeftChange(void 0, this.session);
                            this.onSelectionChange(void 0, this.selection);
                            this.onChangeFrontMarker(void 0, this.session);
                            this.onChangeBackMarker(void 0, this.session);
                            this.onChangeBreakpoint(void 0, this.session);
                            this.onChangeAnnotation(void 0, this.session);
                            session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                            this.renderer.updateFull();
                        }
                        this.eventBus._signal("changeSession", {
                            session: session,
                            oldSession: oldSession
                        });
                        oldSession && oldSession._signal("changeEditor", { oldEditor: this });
                        session && session._signal("changeEditor", { editor: this });
                    }
                }, {
                    key: "getSession",
                    value: function getSession() {
                        return this.session;
                    }
                }, {
                    key: "setValue",
                    value: function setValue(text, cursorPos) {
                        this.session.doc.setValue(text);
                        if (!cursorPos) {
                            this.selectAll();
                        } else if (cursorPos == +1) {
                            this.navigateFileEnd();
                        } else if (cursorPos == -1) {
                            this.navigateFileStart();
                        }
                    }
                }, {
                    key: "getValue",
                    value: function getValue() {
                        return this.session.getValue();
                    }
                }, {
                    key: "getSelection",
                    value: function getSelection() {
                        return this.selection;
                    }
                }, {
                    key: "resize",
                    value: function resize(force) {
                        this.renderer.onResize(force);
                    }
                }, {
                    key: "getTheme",
                    value: function getTheme() {
                        return this.renderer.getTheme();
                    }
                }, {
                    key: "setStyle",
                    value: function setStyle(style) {
                        this.renderer.setStyle(style);
                    }
                }, {
                    key: "unsetStyle",
                    value: function unsetStyle(style) {
                        this.renderer.unsetStyle(style);
                    }
                }, {
                    key: "getFontSize",
                    value: function getFontSize() {
                        return this.getOption("fontSize") || computedStyle(this.container, "fontSize");
                    }
                }, {
                    key: "setFontSize",
                    value: function setFontSize(fontSize) {
                        this.setOption("fontSize", fontSize);
                    }
                }, {
                    key: "$highlightBrackets",
                    value: function $highlightBrackets() {
                        if (this.session.$bracketHighlight) {
                            this.session.removeMarker(this.session.$bracketHighlight);
                            this.session.$bracketHighlight = void 0;
                        }
                        if (this.$highlightPending) {
                            return;
                        }
                        var self = this;
                        this.$highlightPending = true;
                        setTimeout(function () {
                            self.$highlightPending = false;
                            var pos = self.session.findMatchingBracket(self.getCursorPosition());
                            if (pos) {
                                var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
                            } else if (self.session.$mode && self.session.$mode.getMatching) {
                                var range = self.session.$mode.getMatching(self.session);
                            }
                            if (range) {
                                self.session.$bracketHighlight = self.session.addMarker(range, "ace_bracket", "text");
                            }
                        }, 50);
                    }
                }, {
                    key: "$highlightTags",
                    value: function $highlightTags() {
                        var session = this.session;
                        if (this.$highlightTagPending) {
                            return;
                        }
                        var self = this;
                        this.$highlightTagPending = true;
                        setTimeout(function () {
                            self.$highlightTagPending = false;
                            var pos = self.getCursorPosition();
                            var iterator = new TokenIterator(self.session, pos.row, pos.column);
                            var token = iterator.getCurrentToken();
                            if (!token || token.type.indexOf('tag-name') === -1) {
                                session.removeMarker(session.$tagHighlight);
                                session.$tagHighlight = null;
                                return;
                            }
                            var tag = token.value;
                            var depth = 0;
                            var prevToken = iterator.stepBackward();
                            if (prevToken.value == '<') {
                                do {
                                    prevToken = token;
                                    token = iterator.stepForward();
                                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                        if (prevToken.value === '<') {
                                            depth++;
                                        } else if (prevToken.value === '</') {
                                            depth--;
                                        }
                                    }
                                } while (token && depth >= 0);
                            } else {
                                do {
                                    token = prevToken;
                                    prevToken = iterator.stepBackward();
                                    if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                        if (prevToken.value === '<') {
                                            depth++;
                                        } else if (prevToken.value === '</') {
                                            depth--;
                                        }
                                    }
                                } while (prevToken && depth <= 0);
                                iterator.stepForward();
                            }
                            if (!token) {
                                session.removeMarker(session.$tagHighlight);
                                session.$tagHighlight = null;
                                return;
                            }
                            var row = iterator.getCurrentTokenRow();
                            var column = iterator.getCurrentTokenColumn();
                            var range = new Range(row, column, row, column + token.value.length);
                            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
                                session.removeMarker(session.$tagHighlight);
                                session.$tagHighlight = null;
                            }
                            if (range && !session.$tagHighlight) session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
                        }, 50);
                    }
                }, {
                    key: "focus",
                    value: function focus() {
                        var _self = this;
                        setTimeout(function () {
                            _self.textInput.focus();
                        });
                        this.textInput.focus();
                    }
                }, {
                    key: "isFocused",
                    value: function isFocused() {
                        return this.textInput.isFocused();
                    }
                }, {
                    key: "blur",
                    value: function blur() {
                        this.textInput.blur();
                    }
                }, {
                    key: "onFocus",
                    value: function onFocus() {
                        if (this.$isFocused) {
                            return;
                        }
                        this.$isFocused = true;
                        this.renderer.showCursor();
                        this.renderer.visualizeFocus();
                        this.eventBus._emit("focus");
                    }
                }, {
                    key: "onBlur",
                    value: function onBlur() {
                        if (!this.$isFocused) {
                            return;
                        }
                        this.$isFocused = false;
                        this.renderer.hideCursor();
                        this.renderer.visualizeBlur();
                        this.eventBus._emit("blur");
                    }
                }, {
                    key: "$cursorChange",
                    value: function $cursorChange() {
                        this.renderer.updateCursor();
                    }
                }, {
                    key: "onDocumentChange",
                    value: function onDocumentChange(event, session) {
                        var delta = event.data;
                        var range = delta.range;
                        var lastRow;
                        if (range.start.row === range.end.row && delta.action !== "insertLines" && delta.action !== "removeLines") {
                            lastRow = range.end.row;
                        } else {
                            lastRow = Infinity;
                        }
                        var renderer = this.renderer;
                        renderer.updateLines(range.start.row, lastRow, session.$useWrapMode);
                        this.eventBus._signal("change", event);
                        this.$cursorChange();
                        this.$updateHighlightActiveLine();
                    }
                }, {
                    key: "onTokenizerUpdate",
                    value: function onTokenizerUpdate(event, session) {
                        var rows = event.data;
                        this.renderer.updateLines(rows.first, rows.last);
                    }
                }, {
                    key: "onScrollTopChange",
                    value: function onScrollTopChange(event, session) {
                        this.renderer.scrollToY(session.getScrollTop());
                    }
                }, {
                    key: "onScrollLeftChange",
                    value: function onScrollLeftChange(event, session) {
                        this.renderer.scrollToX(session.getScrollLeft());
                    }
                }, {
                    key: "onCursorChange",
                    value: function onCursorChange(event, session) {
                        this.$cursorChange();
                        if (!this.$blockScrolling) {
                            this.renderer.scrollCursorIntoView();
                        }
                        this.$highlightBrackets();
                        this.$highlightTags();
                        this.$updateHighlightActiveLine();
                        this.eventBus._signal("changeSelection");
                    }
                }, {
                    key: "$updateHighlightActiveLine",
                    value: function $updateHighlightActiveLine() {
                        var session = this.session;
                        var renderer = this.renderer;
                        var highlight;
                        if (this.$highlightActiveLine) {
                            if (this.$selectionStyle !== "line" || !this.selection.isMultiLine()) {
                                highlight = this.getCursorPosition();
                            }
                            if (renderer.$maxLines && session.getLength() === 1 && !(renderer.$minLines > 1)) {
                                highlight = false;
                            }
                        }
                        if (session.$highlightLineMarker && !highlight) {
                            session.removeMarker(session.$highlightLineMarker.markerId);
                            session.$highlightLineMarker = null;
                        } else if (!session.$highlightLineMarker && highlight) {
                            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                            range.markerId = session.addMarker(range, "ace_active-line", "screenLine");
                            session.$highlightLineMarker = range;
                        } else if (highlight) {
                            session.$highlightLineMarker.start.row = highlight.row;
                            session.$highlightLineMarker.end.row = highlight.row;
                            session.$highlightLineMarker.start.column = highlight.column;
                            session._signal("changeBackMarker");
                        }
                    }
                }, {
                    key: "onSelectionChange",
                    value: function onSelectionChange(event, selection) {
                        var session = this.session;
                        if (typeof session.$selectionMarker === 'number') {
                            session.removeMarker(session.$selectionMarker);
                            session.$selectionMarker = null;
                        }
                        if (!this.selection.isEmpty()) {
                            var range = this.selection.getRange();
                            var style = this.getSelectionStyle();
                            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
                        } else {
                            this.$updateHighlightActiveLine();
                        }
                        var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
                        this.session.highlight(re);
                        this.eventBus._signal("changeSelection");
                    }
                }, {
                    key: "$getSelectionHighLightRegexp",
                    value: function $getSelectionHighLightRegexp() {
                        var session = this.session;
                        var selection = this.getSelectionRange();
                        if (selection.isEmpty() || selection.isMultiLine()) return;
                        var startOuter = selection.start.column - 1;
                        var endOuter = selection.end.column + 1;
                        var line = session.getLine(selection.start.row);
                        var lineCols = line.length;
                        var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
                        if (startOuter >= 0 && /^[\w\d]/.test(needle) || endOuter <= lineCols && /[\w\d]$/.test(needle)) return;
                        needle = line.substring(selection.start.column, selection.end.column);
                        if (!/^[\w\d]+$/.test(needle)) return;
                        var re = this.$search.$assembleRegExp({
                            wholeWord: true,
                            caseSensitive: true,
                            needle: needle
                        });
                        return re;
                    }
                }, {
                    key: "onChangeFrontMarker",
                    value: function onChangeFrontMarker(event, session) {
                        this.updateFrontMarkers();
                    }
                }, {
                    key: "updateFrontMarkers",
                    value: function updateFrontMarkers() {
                        this.renderer.updateFrontMarkers();
                    }
                }, {
                    key: "onChangeBackMarker",
                    value: function onChangeBackMarker(event, session) {
                        this.renderer.updateBackMarkers();
                    }
                }, {
                    key: "updateBackMarkers",
                    value: function updateBackMarkers() {
                        this.renderer.updateBackMarkers();
                    }
                }, {
                    key: "onChangeBreakpoint",
                    value: function onChangeBreakpoint(event, editSession) {
                        this.renderer.updateBreakpoints();
                        this.eventBus._emit("changeBreakpoint", event);
                    }
                }, {
                    key: "onChangeAnnotation",
                    value: function onChangeAnnotation(event, session) {
                        this.renderer.setAnnotations(session.getAnnotations());
                        this.eventBus._emit("changeAnnotation", event);
                    }
                }, {
                    key: "onChangeMode",
                    value: function onChangeMode(event, session) {
                        this.renderer.updateText();
                        this.eventBus._emit("changeMode", event);
                    }
                }, {
                    key: "onChangeWrapLimit",
                    value: function onChangeWrapLimit(event, session) {
                        this.renderer.updateFull();
                    }
                }, {
                    key: "onChangeWrapMode",
                    value: function onChangeWrapMode(event, session) {
                        this.renderer.onResize(true);
                    }
                }, {
                    key: "onChangeFold",
                    value: function onChangeFold(event, session) {
                        this.$updateHighlightActiveLine();
                        this.renderer.updateFull();
                    }
                }, {
                    key: "getSelectedText",
                    value: function getSelectedText() {
                        return this.session.getTextRange(this.getSelectionRange());
                    }
                }, {
                    key: "getCopyText",
                    value: function getCopyText() {
                        var text = this.getSelectedText();
                        this.eventBus._signal("copy", text);
                        return text;
                    }
                }, {
                    key: "onCopy",
                    value: function onCopy() {
                        this.commands.exec("copy", this);
                    }
                }, {
                    key: "onCut",
                    value: function onCut() {
                        this.commands.exec("cut", this);
                    }
                }, {
                    key: "onPaste",
                    value: function onPaste(text) {
                        if (this.$readOnly) return;
                        var e = { text: text };
                        this.eventBus._signal("paste", e);
                        this.insert(e.text, true);
                    }
                }, {
                    key: "execCommand",
                    value: function execCommand(command, args) {
                        this.commands.exec(command, this, args);
                    }
                }, {
                    key: "insert",
                    value: function insert(text, pasted) {
                        var session = this.session;
                        var mode = session.getMode();
                        var cursor = this.getCursorPosition();
                        var transform;
                        if (this.getBehavioursEnabled() && !pasted) {
                            transform = mode && mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
                            if (transform) {
                                if (text !== transform.text) {
                                    this.session.mergeUndoDeltas = false;
                                    this.$mergeNextCommand = false;
                                }
                                text = transform.text;
                            }
                        }
                        if (text === "\t") {
                            text = this.session.getTabString();
                        }
                        if (!this.selection.isEmpty()) {
                            var range = this.getSelectionRange();
                            cursor = this.session.remove(range);
                            this.clearSelection();
                        } else if (this.session.getOverwrite()) {
                            var range = Range.fromPoints(cursor, cursor);
                            range.end.column += text.length;
                            this.session.remove(range);
                        }
                        if (text === "\n" || text === "\r\n") {
                            var line = session.getLine(cursor.row);
                            if (cursor.column > line.search(/\S|$/)) {
                                var d = line.substr(cursor.column).search(/\S|$/);
                                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                            }
                        }
                        this.clearSelection();
                        var start = cursor.column;
                        var lineState = session.getState(cursor.row);
                        var line = session.getLine(cursor.row);
                        var shouldOutdent = mode.checkOutdent(lineState, line, text);
                        var end = session.insert(cursor, text);
                        if (transform && transform.selection) {
                            if (transform.selection.length === 2) {
                                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                            } else {
                                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
                            }
                        }
                        if (session.getDocument().isNewLine(text)) {
                            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                            session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
                        }
                        if (shouldOutdent) {
                            mode.autoOutdent(lineState, session, cursor.row);
                        }
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback, capturing) {
                        this.eventBus.on(eventName, callback, capturing);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "setDefaultHandler",
                    value: function setDefaultHandler(eventName, callback) {
                        this.eventBus.setDefaultHandler(eventName, callback);
                    }
                }, {
                    key: "_emit",
                    value: function _emit(eventName, event) {
                        this.eventBus._emit(eventName, event);
                    }
                }, {
                    key: "_signal",
                    value: function _signal(eventName, event) {
                        this.eventBus._signal(eventName, event);
                    }
                }, {
                    key: "hasListeners",
                    value: function hasListeners(eventName) {
                        return this.eventBus.hasListeners(eventName);
                    }
                }, {
                    key: "onTextInput",
                    value: function onTextInput(text) {
                        this.keyBinding.onTextInput(text);
                        if (text === '.') {
                            this.commands.exec(COMMAND_NAME_AUTO_COMPLETE);
                        } else if (this.getSession().getDocument().isNewLine(text)) {
                            var lineNumber = this.getCursorPosition().row;
                        }
                    }
                }, {
                    key: "onCommandKey",
                    value: function onCommandKey(e, hashId, keyCode) {
                        this.keyBinding.onCommandKey(e, hashId, keyCode);
                    }
                }, {
                    key: "setOverwrite",
                    value: function setOverwrite(overwrite) {
                        this.session.setOverwrite(overwrite);
                    }
                }, {
                    key: "getOverwrite",
                    value: function getOverwrite() {
                        return this.session.getOverwrite();
                    }
                }, {
                    key: "toggleOverwrite",
                    value: function toggleOverwrite() {
                        this.session.toggleOverwrite();
                    }
                }, {
                    key: "setScrollSpeed",
                    value: function setScrollSpeed(speed) {
                        this.setOption("scrollSpeed", speed);
                    }
                }, {
                    key: "getScrollSpeed",
                    value: function getScrollSpeed() {
                        return this.getOption("scrollSpeed");
                    }
                }, {
                    key: "setDragDelay",
                    value: function setDragDelay(dragDelay) {
                        this.setOption("dragDelay", dragDelay);
                    }
                }, {
                    key: "getDragDelay",
                    value: function getDragDelay() {
                        return this.getOption("dragDelay");
                    }
                }, {
                    key: "setSelectionStyle",
                    value: function setSelectionStyle(selectionStyle) {
                        this.setOption("selectionStyle", selectionStyle);
                    }
                }, {
                    key: "getSelectionStyle",
                    value: function getSelectionStyle() {
                        return this.getOption("selectionStyle");
                    }
                }, {
                    key: "setHighlightActiveLine",
                    value: function setHighlightActiveLine(shouldHighlight) {
                        this.setOption("highlightActiveLine", shouldHighlight);
                    }
                }, {
                    key: "getHighlightActiveLine",
                    value: function getHighlightActiveLine() {
                        return this.getOption("highlightActiveLine");
                    }
                }, {
                    key: "setHighlightGutterLine",
                    value: function setHighlightGutterLine(shouldHighlight) {
                        this.setOption("highlightGutterLine", shouldHighlight);
                    }
                }, {
                    key: "getHighlightGutterLine",
                    value: function getHighlightGutterLine() {
                        return this.getOption("highlightGutterLine");
                    }
                }, {
                    key: "setHighlightSelectedWord",
                    value: function setHighlightSelectedWord(shouldHighlight) {
                        this.setOption("highlightSelectedWord", shouldHighlight);
                    }
                }, {
                    key: "getHighlightSelectedWord",
                    value: function getHighlightSelectedWord() {
                        return this.$highlightSelectedWord;
                    }
                }, {
                    key: "setAnimatedScroll",
                    value: function setAnimatedScroll(shouldAnimate) {
                        this.renderer.setAnimatedScroll(shouldAnimate);
                    }
                }, {
                    key: "getAnimatedScroll",
                    value: function getAnimatedScroll() {
                        return this.renderer.getAnimatedScroll();
                    }
                }, {
                    key: "setShowInvisibles",
                    value: function setShowInvisibles(showInvisibles) {
                        this.renderer.setShowInvisibles(showInvisibles);
                    }
                }, {
                    key: "getShowInvisibles",
                    value: function getShowInvisibles() {
                        return this.renderer.getShowInvisibles();
                    }
                }, {
                    key: "setDisplayIndentGuides",
                    value: function setDisplayIndentGuides(displayIndentGuides) {
                        this.renderer.setDisplayIndentGuides(displayIndentGuides);
                    }
                }, {
                    key: "getDisplayIndentGuides",
                    value: function getDisplayIndentGuides() {
                        return this.renderer.getDisplayIndentGuides();
                    }
                }, {
                    key: "setShowPrintMargin",
                    value: function setShowPrintMargin(showPrintMargin) {
                        this.renderer.setShowPrintMargin(showPrintMargin);
                    }
                }, {
                    key: "getShowPrintMargin",
                    value: function getShowPrintMargin() {
                        return this.renderer.getShowPrintMargin();
                    }
                }, {
                    key: "setPrintMarginColumn",
                    value: function setPrintMarginColumn(showPrintMargin) {
                        this.renderer.setPrintMarginColumn(showPrintMargin);
                    }
                }, {
                    key: "getPrintMarginColumn",
                    value: function getPrintMarginColumn() {
                        return this.renderer.getPrintMarginColumn();
                    }
                }, {
                    key: "setReadOnly",
                    value: function setReadOnly(readOnly) {
                        this.setOption("readOnly", readOnly);
                    }
                }, {
                    key: "getReadOnly",
                    value: function getReadOnly() {
                        return this.getOption("readOnly");
                    }
                }, {
                    key: "setBehavioursEnabled",
                    value: function setBehavioursEnabled(enabled) {
                        this.setOption("behavioursEnabled", enabled);
                    }
                }, {
                    key: "getBehavioursEnabled",
                    value: function getBehavioursEnabled() {
                        return this.getOption("behavioursEnabled");
                    }
                }, {
                    key: "setWrapBehavioursEnabled",
                    value: function setWrapBehavioursEnabled(enabled) {
                        this.setOption("wrapBehavioursEnabled", enabled);
                    }
                }, {
                    key: "getWrapBehavioursEnabled",
                    value: function getWrapBehavioursEnabled() {
                        return this.getOption("wrapBehavioursEnabled");
                    }
                }, {
                    key: "setShowFoldWidgets",
                    value: function setShowFoldWidgets(show) {
                        this.setOption("showFoldWidgets", show);
                    }
                }, {
                    key: "getShowFoldWidgets",
                    value: function getShowFoldWidgets() {
                        return this.getOption("showFoldWidgets");
                    }
                }, {
                    key: "setFadeFoldWidgets",
                    value: function setFadeFoldWidgets(fade) {
                        this.setOption("fadeFoldWidgets", fade);
                    }
                }, {
                    key: "getFadeFoldWidgets",
                    value: function getFadeFoldWidgets() {
                        return this.getOption("fadeFoldWidgets");
                    }
                }, {
                    key: "remove",
                    value: function remove(direction) {
                        if (this.selection.isEmpty()) {
                            if (direction === "left") this.selection.selectLeft();else this.selection.selectRight();
                        }
                        var selectionRange = this.getSelectionRange();
                        if (this.getBehavioursEnabled()) {
                            var session = this.session;
                            var state = session.getState(selectionRange.start.row);
                            var newRange = session.getMode().transformAction(state, 'deletion', this, session, selectionRange);
                            if (selectionRange.end.column === 0) {
                                var text = session.getTextRange(selectionRange);
                                if (text[text.length - 1] === "\n") {
                                    var line = session.getLine(selectionRange.end.row);
                                    if (/^\s+$/.test(line)) {
                                        selectionRange.end.column = line.length;
                                    }
                                }
                            }
                            if (newRange) {
                                selectionRange = newRange;
                            }
                        }
                        this.session.remove(selectionRange);
                        this.clearSelection();
                    }
                }, {
                    key: "removeWordRight",
                    value: function removeWordRight() {
                        if (this.selection.isEmpty()) {
                            this.selection.selectWordRight();
                        }
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }
                }, {
                    key: "removeWordLeft",
                    value: function removeWordLeft() {
                        if (this.selection.isEmpty()) this.selection.selectWordLeft();
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }
                }, {
                    key: "removeToLineStart",
                    value: function removeToLineStart() {
                        if (this.selection.isEmpty()) this.selection.selectLineStart();
                        this.session.remove(this.getSelectionRange());
                        this.clearSelection();
                    }
                }, {
                    key: "removeToLineEnd",
                    value: function removeToLineEnd() {
                        if (this.selection.isEmpty()) this.selection.selectLineEnd();
                        var range = this.getSelectionRange();
                        if (range.start.column === range.end.column && range.start.row === range.end.row) {
                            range.end.column = 0;
                            range.end.row++;
                        }
                        this.session.remove(range);
                        this.clearSelection();
                    }
                }, {
                    key: "splitLine",
                    value: function splitLine() {
                        if (!this.selection.isEmpty()) {
                            this.session.remove(this.getSelectionRange());
                            this.clearSelection();
                        }
                        var cursor = this.getCursorPosition();
                        this.insert("\n", false);
                        this.moveCursorToPosition(cursor);
                    }
                }, {
                    key: "transposeLetters",
                    value: function transposeLetters() {
                        if (!this.selection.isEmpty()) {
                            return;
                        }
                        var cursor = this.getCursorPosition();
                        var column = cursor.column;
                        if (column === 0) return;
                        var line = this.session.getLine(cursor.row);
                        var swap, range;
                        if (column < line.length) {
                            swap = line.charAt(column) + line.charAt(column - 1);
                            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
                        } else {
                            swap = line.charAt(column - 1) + line.charAt(column - 2);
                            range = new Range(cursor.row, column - 2, cursor.row, column);
                        }
                        this.session.replace(range, swap);
                    }
                }, {
                    key: "toLowerCase",
                    value: function toLowerCase() {
                        var originalRange = this.getSelectionRange();
                        if (this.selection.isEmpty()) {
                            this.selection.selectWord();
                        }
                        var range = this.getSelectionRange();
                        var text = this.session.getTextRange(range);
                        this.session.replace(range, text.toLowerCase());
                        this.selection.setSelectionRange(originalRange);
                    }
                }, {
                    key: "toUpperCase",
                    value: function toUpperCase() {
                        var originalRange = this.getSelectionRange();
                        if (this.selection.isEmpty()) {
                            this.selection.selectWord();
                        }
                        var range = this.getSelectionRange();
                        var text = this.session.getTextRange(range);
                        this.session.replace(range, text.toUpperCase());
                        this.selection.setSelectionRange(originalRange);
                    }
                }, {
                    key: "indent",
                    value: function indent() {
                        var session = this.session;
                        var range = this.getSelectionRange();
                        if (range.start.row < range.end.row) {
                            var rows = this.$getSelectedRows();
                            session.indentRows(rows.first, rows.last, "\t");
                            return;
                        } else if (range.start.column < range.end.column) {
                            var text = session.getTextRange(range);
                            if (!/^\s+$/.test(text)) {
                                var rows = this.$getSelectedRows();
                                session.indentRows(rows.first, rows.last, "\t");
                                return;
                            }
                        }
                        var line = session.getLine(range.start.row);
                        var position = range.start;
                        var size = session.getTabSize();
                        var column = session.documentToScreenColumn(position.row, position.column);
                        if (this.session.getUseSoftTabs()) {
                            var count = size - column % size;
                            var indentString = stringRepeat(" ", count);
                        } else {
                            var count = column % size;
                            while (line[range.start.column] === " " && count) {
                                range.start.column--;
                                count--;
                            }
                            this.selection.setSelectionRange(range);
                            indentString = "\t";
                        }
                        return this.insert(indentString, false);
                    }
                }, {
                    key: "blockIndent",
                    value: function blockIndent() {
                        var rows = this.$getSelectedRows();
                        this.session.indentRows(rows.first, rows.last, "\t");
                    }
                }, {
                    key: "blockOutdent",
                    value: function blockOutdent() {
                        var selection = this.session.getSelection();
                        this.session.outdentRows(selection.getRange());
                    }
                }, {
                    key: "sortLines",
                    value: function sortLines() {
                        var rows = this.$getSelectedRows();
                        var session = this.session;
                        var lines = [];
                        for (i = rows.first; i <= rows.last; i++) lines.push(session.getLine(i));
                        lines.sort(function (a, b) {
                            if (a.toLowerCase() < b.toLowerCase()) return -1;
                            if (a.toLowerCase() > b.toLowerCase()) return 1;
                            return 0;
                        });
                        var deleteRange = new Range(0, 0, 0, 0);
                        for (var i = rows.first; i <= rows.last; i++) {
                            var line = session.getLine(i);
                            deleteRange.start.row = i;
                            deleteRange.end.row = i;
                            deleteRange.end.column = line.length;
                            session.replace(deleteRange, lines[i - rows.first]);
                        }
                    }
                }, {
                    key: "toggleCommentLines",
                    value: function toggleCommentLines() {
                        var state = this.session.getState(this.getCursorPosition().row);
                        var rows = this.$getSelectedRows();
                        this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
                    }
                }, {
                    key: "toggleBlockComment",
                    value: function toggleBlockComment() {
                        var cursor = this.getCursorPosition();
                        var state = this.session.getState(cursor.row);
                        var range = this.getSelectionRange();
                        this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
                    }
                }, {
                    key: "getNumberAt",
                    value: function getNumberAt(row, column) {
                        var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
                        _numberRx.lastIndex = 0;
                        var s = this.session.getLine(row);
                        while (_numberRx.lastIndex < column) {
                            var m = _numberRx.exec(s);
                            if (m.index <= column && m.index + m[0].length >= column) {
                                var retval = {
                                    value: m[0],
                                    start: m.index,
                                    end: m.index + m[0].length
                                };
                                return retval;
                            }
                        }
                        return null;
                    }
                }, {
                    key: "modifyNumber",
                    value: function modifyNumber(amount) {
                        var row = this.selection.getCursor().row;
                        var column = this.selection.getCursor().column;
                        var charRange = new Range(row, column - 1, row, column);
                        var c = parseFloat(this.session.getTextRange(charRange));
                        if (!isNaN(c) && isFinite(c)) {
                            var nr = this.getNumberAt(row, column);
                            if (nr) {
                                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                                var decimals = nr.start + nr.value.length - fp;
                                var t = parseFloat(nr.value);
                                t *= Math.pow(10, decimals);
                                if (fp !== nr.end && column < fp) {
                                    amount *= Math.pow(10, nr.end - column - 1);
                                } else {
                                    amount *= Math.pow(10, nr.end - column);
                                }
                                t += amount;
                                t /= Math.pow(10, decimals);
                                var nnr = t.toFixed(decimals);
                                var replaceRange = new Range(row, nr.start, row, nr.end);
                                this.session.replace(replaceRange, nnr);
                                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                            }
                        }
                    }
                }, {
                    key: "removeLines",
                    value: function removeLines() {
                        var rows = this.$getSelectedRows();
                        var range;
                        if (rows.first === 0 || rows.last + 1 < this.session.getLength()) range = new Range(rows.first, 0, rows.last + 1, 0);else range = new Range(rows.first - 1, this.session.getLine(rows.first - 1).length, rows.last, this.session.getLine(rows.last).length);
                        this.session.remove(range);
                        this.clearSelection();
                    }
                }, {
                    key: "duplicateSelection",
                    value: function duplicateSelection() {
                        var sel = this.selection;
                        var doc = this.session;
                        var range = sel.getRange();
                        var reverse = sel.isBackwards();
                        if (range.isEmpty()) {
                            var row = range.start.row;
                            doc.duplicateLines(row, row);
                        } else {
                            var point = reverse ? range.start : range.end;
                            var endPoint = doc.insert(point, doc.getTextRange(range));
                            range.start = point;
                            range.end = endPoint;
                            sel.setSelectionRange(range, reverse);
                        }
                    }
                }, {
                    key: "moveLinesDown",
                    value: function moveLinesDown() {
                        this.$moveLines(function (firstRow, lastRow) {
                            return this.session.moveLinesDown(firstRow, lastRow);
                        });
                    }
                }, {
                    key: "moveLinesUp",
                    value: function moveLinesUp() {
                        this.$moveLines(function (firstRow, lastRow) {
                            return this.session.moveLinesUp(firstRow, lastRow);
                        });
                    }
                }, {
                    key: "moveText",
                    value: function moveText(range, toPosition, copy) {
                        return this.session.moveText(range, toPosition, copy);
                    }
                }, {
                    key: "copyLinesUp",
                    value: function copyLinesUp() {
                        this.$moveLines(function (firstRow, lastRow) {
                            this.session.duplicateLines(firstRow, lastRow);
                            return 0;
                        });
                    }
                }, {
                    key: "copyLinesDown",
                    value: function copyLinesDown() {
                        this.$moveLines(function (firstRow, lastRow) {
                            return this.session.duplicateLines(firstRow, lastRow);
                        });
                    }
                }, {
                    key: "$moveLines",
                    value: function $moveLines(mover) {
                        var selection = this.selection;
                        if (!selection['inMultiSelectMode'] || this.inVirtualSelectionMode) {
                            var range = selection.toOrientedRange();
                            var selectedRows = this.$getSelectedRows();
                            var linesMoved = mover.call(this, selectedRows.first, selectedRows.last);
                            range.moveBy(linesMoved, 0);
                            selection.fromOrientedRange(range);
                        } else {
                            var ranges = selection.rangeList.ranges;
                            selection.rangeList.detach();
                            for (var i = ranges.length; i--;) {
                                var rangeIndex = i;
                                var collapsedRows = ranges[i].collapseRows();
                                var last = collapsedRows.end.row;
                                var first = collapsedRows.start.row;
                                while (i--) {
                                    collapsedRows = ranges[i].collapseRows();
                                    if (first - collapsedRows.end.row <= 1) first = collapsedRows.end.row;else break;
                                }
                                i++;
                                var linesMoved = mover.call(this, first, last);
                                while (rangeIndex >= i) {
                                    ranges[rangeIndex].moveBy(linesMoved, 0);
                                    rangeIndex--;
                                }
                            }
                            selection.fromOrientedRange(selection.ranges[0]);
                            selection.rangeList.attach(this.session);
                        }
                    }
                }, {
                    key: "$getSelectedRows",
                    value: function $getSelectedRows() {
                        var range = this.getSelectionRange().collapseRows();
                        return {
                            first: this.session.getRowFoldStart(range.start.row),
                            last: this.session.getRowFoldEnd(range.end.row)
                        };
                    }
                }, {
                    key: "onCompositionStart",
                    value: function onCompositionStart(text) {
                        this.renderer.showComposition(this.getCursorPosition());
                    }
                }, {
                    key: "onCompositionUpdate",
                    value: function onCompositionUpdate(text) {
                        this.renderer.setCompositionText(text);
                    }
                }, {
                    key: "onCompositionEnd",
                    value: function onCompositionEnd() {
                        this.renderer.hideComposition();
                    }
                }, {
                    key: "getFirstVisibleRow",
                    value: function getFirstVisibleRow() {
                        return this.renderer.getFirstVisibleRow();
                    }
                }, {
                    key: "getLastVisibleRow",
                    value: function getLastVisibleRow() {
                        return this.renderer.getLastVisibleRow();
                    }
                }, {
                    key: "isRowVisible",
                    value: function isRowVisible(row) {
                        return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
                    }
                }, {
                    key: "isRowFullyVisible",
                    value: function isRowFullyVisible(row) {
                        return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
                    }
                }, {
                    key: "$getVisibleRowCount",
                    value: function $getVisibleRowCount() {
                        return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
                    }
                }, {
                    key: "$moveByPage",
                    value: function $moveByPage(direction, select) {
                        var renderer = this.renderer;
                        var config = this.renderer.layerConfig;
                        var rows = direction * Math.floor(config.height / config.lineHeight);
                        this.$blockScrolling++;
                        if (select === true) {
                            this.selection.$moveSelection(function () {
                                this.moveCursorBy(rows, 0);
                            });
                        } else if (select === false) {
                            this.selection.moveCursorBy(rows, 0);
                            this.selection.clearSelection();
                        }
                        this.$blockScrolling--;
                        var scrollTop = renderer.scrollTop;
                        renderer.scrollBy(0, rows * config.lineHeight);
                        if (select != null) {
                            renderer.scrollCursorIntoView(null, 0.5);
                        }
                        renderer.animateScrolling(scrollTop);
                    }
                }, {
                    key: "selectPageDown",
                    value: function selectPageDown() {
                        this.$moveByPage(+1, true);
                    }
                }, {
                    key: "selectPageUp",
                    value: function selectPageUp() {
                        this.$moveByPage(-1, true);
                    }
                }, {
                    key: "gotoPageDown",
                    value: function gotoPageDown() {
                        this.$moveByPage(+1, false);
                    }
                }, {
                    key: "gotoPageUp",
                    value: function gotoPageUp() {
                        this.$moveByPage(-1, false);
                    }
                }, {
                    key: "scrollPageDown",
                    value: function scrollPageDown() {
                        this.$moveByPage(1);
                    }
                }, {
                    key: "scrollPageUp",
                    value: function scrollPageUp() {
                        this.$moveByPage(-1);
                    }
                }, {
                    key: "scrollToRow",
                    value: function scrollToRow(row) {
                        this.renderer.scrollToRow(row);
                    }
                }, {
                    key: "scrollToLine",
                    value: function scrollToLine(line, center, animate, callback) {
                        this.renderer.scrollToLine(line, center, animate, callback);
                    }
                }, {
                    key: "centerSelection",
                    value: function centerSelection() {
                        var range = this.getSelectionRange();
                        var pos = {
                            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
                        };
                        this.renderer.alignCursor(pos, 0.5);
                    }
                }, {
                    key: "getCursorPosition",
                    value: function getCursorPosition() {
                        return this.selection.getCursor();
                    }
                }, {
                    key: "getCursorPositionScreen",
                    value: function getCursorPositionScreen() {
                        var cursor = this.getCursorPosition();
                        return this.session.documentToScreenPosition(cursor.row, cursor.column);
                    }
                }, {
                    key: "getSelectionRange",
                    value: function getSelectionRange() {
                        return this.selection.getRange();
                    }
                }, {
                    key: "selectAll",
                    value: function selectAll() {
                        this.$blockScrolling += 1;
                        this.selection.selectAll();
                        this.$blockScrolling -= 1;
                    }
                }, {
                    key: "clearSelection",
                    value: function clearSelection() {
                        this.selection.clearSelection();
                    }
                }, {
                    key: "moveCursorTo",
                    value: function moveCursorTo(row, column, animate) {
                        this.selection.moveCursorTo(row, column, animate);
                    }
                }, {
                    key: "moveCursorToPosition",
                    value: function moveCursorToPosition(position) {
                        return this.selection.moveCursorToPosition(position);
                    }
                }, {
                    key: "jumpToMatching",
                    value: function jumpToMatching(select) {
                        var cursor = this.getCursorPosition();
                        var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
                        var prevToken = iterator.getCurrentToken();
                        var token = prevToken;
                        if (!token) token = iterator.stepForward();
                        if (!token) return;
                        var matchType;
                        var found = false;
                        var depth = {};
                        var i = cursor.column - token.start;
                        var bracketType;
                        var brackets = {
                            ")": "(",
                            "(": "(",
                            "]": "[",
                            "[": "[",
                            "{": "{",
                            "}": "{"
                        };
                        do {
                            if (token.value.match(/[{}()\[\]]/g)) {
                                for (; i < token.value.length && !found; i++) {
                                    if (!brackets[token.value[i]]) {
                                        continue;
                                    }
                                    bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                                    if (isNaN(depth[bracketType])) {
                                        depth[bracketType] = 0;
                                    }
                                    switch (token.value[i]) {
                                        case '(':
                                        case '[':
                                        case '{':
                                            depth[bracketType]++;
                                            break;
                                        case ')':
                                        case ']':
                                        case '}':
                                            depth[bracketType]--;
                                            if (depth[bracketType] === -1) {
                                                matchType = 'bracket';
                                                found = true;
                                            }
                                            break;
                                    }
                                }
                            } else if (token && token.type.indexOf('tag-name') !== -1) {
                                if (isNaN(depth[token.value])) {
                                    depth[token.value] = 0;
                                }
                                if (prevToken.value === '<') {
                                    depth[token.value]++;
                                } else if (prevToken.value === '</') {
                                    depth[token.value]--;
                                }
                                if (depth[token.value] === -1) {
                                    matchType = 'tag';
                                    found = true;
                                }
                            }
                            if (!found) {
                                prevToken = token;
                                token = iterator.stepForward();
                                i = 0;
                            }
                        } while (token && !found);
                        if (!matchType) {
                            return;
                        }
                        var range;
                        if (matchType === 'bracket') {
                            range = this.session.getBracketRange(cursor);
                            if (!range) {
                                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                                if (!range) return;
                                var pos = range.start;
                                if (pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                            }
                        } else if (matchType === 'tag') {
                            if (token && token.type.indexOf('tag-name') !== -1) var tag = token.value;else return;
                            var range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                            if (range.compare(cursor.row, cursor.column) === 0) {
                                found = false;
                                do {
                                    token = prevToken;
                                    prevToken = iterator.stepBackward();
                                    if (prevToken) {
                                        if (prevToken.type.indexOf('tag-close') !== -1) {
                                            range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                                        }
                                        if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                                            if (prevToken.value === '<') {
                                                depth[tag]++;
                                            } else if (prevToken.value === '</') {
                                                depth[tag]--;
                                            }
                                            if (depth[tag] === 0) found = true;
                                        }
                                    }
                                } while (prevToken && !found);
                            }
                            if (token && token.type.indexOf('tag-name')) {
                                var pos = range.start;
                                if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2) pos = range.end;
                            }
                        }
                        pos = range && range['cursor'] || pos;
                        if (pos) {
                            if (select) {
                                if (range && range.isEqual(this.getSelectionRange())) this.clearSelection();else this.selection.selectTo(pos.row, pos.column);
                            } else {
                                this.selection.moveTo(pos.row, pos.column);
                            }
                        }
                    }
                }, {
                    key: "gotoLine",
                    value: function gotoLine(lineNumber, column, animate) {
                        this.selection.clearSelection();
                        this.session.unfold({ row: lineNumber - 1, column: column || 0 });
                        this.$blockScrolling += 1;
                        this.exitMultiSelectMode && this.exitMultiSelectMode();
                        this.moveCursorTo(lineNumber - 1, column || 0);
                        this.$blockScrolling -= 1;
                        if (!this.isRowFullyVisible(lineNumber - 1)) {
                            this.scrollToLine(lineNumber - 1, true, animate);
                        }
                    }
                }, {
                    key: "navigateTo",
                    value: function navigateTo(row, column) {
                        this.selection.moveTo(row, column);
                    }
                }, {
                    key: "navigateUp",
                    value: function navigateUp(times) {
                        if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                            var selectionStart = this.selection.anchor.getPosition();
                            return this.moveCursorToPosition(selectionStart);
                        }
                        this.selection.clearSelection();
                        this.selection.moveCursorBy(-times || -1, 0);
                    }
                }, {
                    key: "navigateDown",
                    value: function navigateDown(times) {
                        if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                            var selectionEnd = this.selection.anchor.getPosition();
                            return this.moveCursorToPosition(selectionEnd);
                        }
                        this.selection.clearSelection();
                        this.selection.moveCursorBy(times || 1, 0);
                    }
                }, {
                    key: "navigateLeft",
                    value: function navigateLeft(times) {
                        if (!this.selection.isEmpty()) {
                            var selectionStart = this.getSelectionRange().start;
                            this.moveCursorToPosition(selectionStart);
                        } else {
                            times = times || 1;
                            while (times--) {
                                this.selection.moveCursorLeft();
                            }
                        }
                        this.clearSelection();
                    }
                }, {
                    key: "navigateRight",
                    value: function navigateRight(times) {
                        if (!this.selection.isEmpty()) {
                            var selectionEnd = this.getSelectionRange().end;
                            this.moveCursorToPosition(selectionEnd);
                        } else {
                            times = times || 1;
                            while (times--) {
                                this.selection.moveCursorRight();
                            }
                        }
                        this.clearSelection();
                    }
                }, {
                    key: "navigateLineStart",
                    value: function navigateLineStart() {
                        this.selection.moveCursorLineStart();
                        this.clearSelection();
                    }
                }, {
                    key: "navigateLineEnd",
                    value: function navigateLineEnd() {
                        this.selection.moveCursorLineEnd();
                        this.clearSelection();
                    }
                }, {
                    key: "navigateFileEnd",
                    value: function navigateFileEnd() {
                        this.selection.moveCursorFileEnd();
                        this.clearSelection();
                    }
                }, {
                    key: "navigateFileStart",
                    value: function navigateFileStart() {
                        this.selection.moveCursorFileStart();
                        this.clearSelection();
                    }
                }, {
                    key: "navigateWordRight",
                    value: function navigateWordRight() {
                        this.selection.moveCursorWordRight();
                        this.clearSelection();
                    }
                }, {
                    key: "navigateWordLeft",
                    value: function navigateWordLeft() {
                        this.selection.moveCursorWordLeft();
                        this.clearSelection();
                    }
                }, {
                    key: "replace",
                    value: function replace(replacement, options) {
                        if (options) this.$search.set(options);
                        var range = this.$search.find(this.session);
                        var replaced = 0;
                        if (!range) return replaced;
                        if (this.$tryReplace(range, replacement)) {
                            replaced = 1;
                        }
                        if (range !== null) {
                            this.selection.setSelectionRange(range);
                            this.renderer.scrollSelectionIntoView(range.start, range.end);
                        }
                        return replaced;
                    }
                }, {
                    key: "replaceAll",
                    value: function replaceAll(replacement, options) {
                        if (options) {
                            this.$search.set(options);
                        }
                        var ranges = this.$search.findAll(this.session);
                        var replaced = 0;
                        if (!ranges.length) return replaced;
                        this.$blockScrolling += 1;
                        var selection = this.getSelectionRange();
                        this.selection.moveTo(0, 0);
                        for (var i = ranges.length - 1; i >= 0; --i) {
                            if (this.$tryReplace(ranges[i], replacement)) {
                                replaced++;
                            }
                        }
                        this.selection.setSelectionRange(selection);
                        this.$blockScrolling -= 1;
                        return replaced;
                    }
                }, {
                    key: "$tryReplace",
                    value: function $tryReplace(range, replacement) {
                        var input = this.session.getTextRange(range);
                        replacement = this.$search.replace(input, replacement);
                        if (replacement !== null) {
                            range.end = this.session.replace(range, replacement);
                            return range;
                        } else {
                            return null;
                        }
                    }
                }, {
                    key: "getLastSearchOptions",
                    value: function getLastSearchOptions() {
                        return this.$search.getOptions();
                    }
                }, {
                    key: "find",
                    value: function find(needle, options, animate) {
                        if (options === undefined) options = {};

                        if (typeof needle === "string" || needle instanceof RegExp) {
                            options.needle = needle;
                        } else if (typeof needle == "object") {
                            mixin(options, needle);
                        }
                        var range = this.selection.getRange();
                        if (options.needle == null) {
                            needle = this.session.getTextRange(range) || this.$search.$options.needle;
                            if (!needle) {
                                range = this.session.getWordRange(range.start.row, range.start.column);
                                needle = this.session.getTextRange(range);
                            }
                            this.$search.set({ needle: needle });
                        }
                        this.$search.set(options);
                        if (!options.start) {
                            this.$search.set({ start: range.start });
                        }
                        var newRange = this.$search.find(this.session);
                        if (options.preventScroll) {
                            return newRange;
                        }
                        if (newRange) {
                            this.revealRange(newRange, animate);
                            return newRange;
                        }
                        if (options.backwards) range.start = range.end;else range.end = range.start;
                        this.selection.setRange(range);
                    }
                }, {
                    key: "findNext",
                    value: function findNext(needle, animate) {
                        this.find(needle, { skipCurrent: true, backwards: false }, animate);
                    }
                }, {
                    key: "findPrevious",
                    value: function findPrevious(needle, animate) {
                        this.find(needle, { skipCurrent: true, backwards: true }, animate);
                    }
                }, {
                    key: "revealRange",
                    value: function revealRange(range, animate) {
                        this.$blockScrolling += 1;
                        this.session.unfold(range);
                        this.selection.setSelectionRange(range);
                        this.$blockScrolling -= 1;
                        var scrollTop = this.renderer.scrollTop;
                        this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
                        if (animate !== false) {
                            this.renderer.animateScrolling(scrollTop);
                        }
                    }
                }, {
                    key: "undo",
                    value: function undo() {
                        this.$blockScrolling++;
                        this.session.getUndoManager().undo();
                        this.$blockScrolling--;
                        this.renderer.scrollCursorIntoView(void 0, 0.5);
                    }
                }, {
                    key: "redo",
                    value: function redo() {
                        this.$blockScrolling++;
                        this.session.getUndoManager().redo();
                        this.$blockScrolling--;
                        this.renderer.scrollCursorIntoView(void 0, 0.5);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.renderer.destroy();
                        this._signal("destroy", this);
                    }
                }, {
                    key: "setAutoScrollEditorIntoView",
                    value: function setAutoScrollEditorIntoView(enable) {
                        if (!enable) return;
                        var rect;
                        var self = this;
                        var shouldScroll = false;
                        if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
                        var scrollAnchor = this.$scrollAnchor;
                        scrollAnchor.style.cssText = "position:absolute";
                        this.container.insertBefore(scrollAnchor, this.container.firstChild);
                        var onChangeSelection = this.on("changeSelection", function () {
                            shouldScroll = true;
                        });
                        var onBeforeRender = this.renderer.on("beforeRender", function () {
                            if (shouldScroll) rect = self.renderer.container.getBoundingClientRect();
                        });
                        var onAfterRender = this.renderer.on("afterRender", function () {
                            if (shouldScroll && rect && self.isFocused()) {
                                var renderer = self.renderer;
                                var pos = renderer.$cursorLayer.$pixelPos;
                                var config = renderer.layerConfig;
                                var top = pos.top - config.offset;
                                if (pos.top >= 0 && top + rect.top < 0) {
                                    shouldScroll = true;
                                } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                                    shouldScroll = false;
                                } else {
                                    shouldScroll = null;
                                }
                                if (shouldScroll != null) {
                                    scrollAnchor.style.top = top + "px";
                                    scrollAnchor.style.left = pos.left + "px";
                                    scrollAnchor.style.height = config.lineHeight + "px";
                                    scrollAnchor.scrollIntoView(shouldScroll);
                                }
                                shouldScroll = rect = null;
                            }
                        });
                        this.setAutoScrollEditorIntoView = function (enable) {
                            if (enable) return;
                            delete this.setAutoScrollEditorIntoView;
                            this.removeEventListener("changeSelection", onChangeSelection);
                            this.renderer.removeEventListener("afterRender", onAfterRender);
                            this.renderer.removeEventListener("beforeRender", onBeforeRender);
                        };
                    }
                }, {
                    key: "$resetCursorStyle",
                    value: function $resetCursorStyle() {
                        var style = this.$cursorStyle || "ace";
                        var cursorLayer = this.renderer.$cursorLayer;
                        if (!cursorLayer) {
                            return;
                        }
                        cursorLayer.setSmoothBlinking(/smooth/.test(style));
                        cursorLayer.isBlinking = !this.$readOnly && style != "wide";
                        setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
                    }
                }, {
                    key: "selection",
                    get: function get() {
                        return this.session.getSelection();
                    },
                    set: function set(selection) {
                        this.session.setSelection(selection);
                    }
                }]);

                return Editor;
            })();

            _export("default", Editor);

            defineOptions(Editor.prototype, "editor", {
                selectionStyle: {
                    set: function set(style) {
                        var that = this;
                        that.$onSelectionChange(void 0, that.selection);
                        that._signal("changeSelectionStyle", { data: style });
                    },
                    initialValue: "line"
                },
                highlightActiveLine: {
                    set: function set() {
                        var that = this;
                        that.$updateHighlightActiveLine();
                    },
                    initialValue: true
                },
                highlightSelectedWord: {
                    set: function set(shouldHighlight) {
                        var that = this;
                        that.$onSelectionChange(void 0, that.selection);
                    },
                    initialValue: true
                },
                readOnly: {
                    set: function set(readOnly) {
                        this.$resetCursorStyle();
                    },
                    initialValue: false
                },
                cursorStyle: {
                    set: function set(val) {
                        var that = this;
                        that.$resetCursorStyle();
                    },
                    values: ["ace", "slim", "smooth", "wide"],
                    initialValue: "ace"
                },
                mergeUndoDeltas: {
                    values: [false, true, "always"],
                    initialValue: true
                },
                behavioursEnabled: { initialValue: true },
                wrapBehavioursEnabled: { initialValue: true },
                autoScrollEditorIntoView: {
                    set: function set(enable) {
                        var that = this;
                        that.setAutoScrollEditorIntoView(enable);
                    }
                },
                hScrollBarAlwaysVisible: "renderer",
                vScrollBarAlwaysVisible: "renderer",
                highlightGutterLine: "renderer",
                animatedScroll: "renderer",
                showInvisibles: "renderer",
                showPrintMargin: "renderer",
                printMarginColumn: "renderer",
                printMargin: "renderer",
                fadeFoldWidgets: "renderer",
                showFoldWidgets: "renderer",
                showLineNumbers: "renderer",
                showGutter: "renderer",
                displayIndentGuides: "renderer",
                fontSize: "renderer",
                fontFamily: "renderer",
                maxLines: "renderer",
                minLines: "renderer",
                scrollPastEnd: "renderer",
                fixedWidthGutter: "renderer",
                theme: "renderer",
                scrollSpeed: "$mouseHandler",
                dragDelay: "$mouseHandler",
                dragEnabled: "$mouseHandler",
                focusTimout: "$mouseHandler",
                tooltipFollowsMouse: "$mouseHandler",
                firstLineNumber: "session",
                overwrite: "session",
                newLineMode: "session",
                useWorker: "session",
                useSoftTabs: "session",
                tabSize: "session",
                wrap: "session",
                foldStyle: "session",
                mode: "session"
            });

            FoldHandler = function FoldHandler(editor) {
                _classCallCheck(this, FoldHandler);

                editor.on("click", function (e) {
                    var position = e.getDocumentPosition();
                    var session = editor.getSession();
                    var fold = session.getFoldAt(position.row, position.column, 1);
                    if (fold) {
                        if (e.getAccelKey()) {
                            session.removeFold(fold);
                        } else {
                            session.expandFold(fold);
                        }
                        e.stop();
                    } else {}
                });
                editor.on('gutterclick', function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                    if (gutterRegion === 'foldWidgets') {
                        var row = e.getDocumentPosition().row;
                        var session = editor.getSession();
                        if (session['foldWidgets'] && session['foldWidgets'][row]) {
                            session['onFoldWidgetClick'](row, e);
                        }
                        if (!editor.isFocused()) {
                            editor.focus();
                        }
                        e.stop();
                    }
                });
                editor.on('gutterdblclick', function (e) {
                    var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                    if (gutterRegion == 'foldWidgets') {
                        var row = e.getDocumentPosition().row;
                        var session = editor.getSession();
                        var data = session['getParentFoldRangeData'](row, true);
                        var range = data.range || data.firstRange;
                        if (range) {
                            row = range.start.row;
                            var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                            if (fold) {
                                session.removeFold(fold);
                            } else {
                                session['addFold']("...", range);
                                editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                            }
                        }
                        e.stop();
                    }
                });
            };

            MouseHandler = (function () {
                function MouseHandler(editor) {
                    _classCallCheck(this, MouseHandler);

                    this.$scrollSpeed = 2;
                    this.$dragDelay = 0;
                    this.$dragEnabled = true;
                    this.$focusTimout = 0;
                    this.$tooltipFollowsMouse = true;
                    this.$clickSelection = null;
                    var _self = this;
                    this.editor = editor;
                    editor.setDefaultHandler('mousedown', makeMouseDownHandler(editor, this));
                    editor.setDefaultHandler('mousewheel', makeMouseWheelHandler(editor, this));
                    editor.setDefaultHandler("dblclick", makeDoubleClickHandler(editor, this));
                    editor.setDefaultHandler("tripleclick", makeTripleClickHandler(editor, this));
                    editor.setDefaultHandler("quadclick", makeQuadClickHandler(editor, this));
                    this.selectByLines = makeExtendSelectionBy(editor, this, "getLineRange");
                    this.selectByWords = makeExtendSelectionBy(editor, this, "getWordRange");
                    new GutterHandler(this);
                    var onMouseDown = function onMouseDown(e) {
                        if (!editor.isFocused() && editor.textInput) {
                            editor.textInput.moveToMouse(e);
                        }
                        editor.focus();
                    };
                    var mouseTarget = editor.renderer.getMouseEventTarget();
                    addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
                    addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
                    addMultiMouseDownListener(mouseTarget, [400, 300, 250], this, "onMouseEvent");
                    if (editor.renderer.scrollBarV) {
                        addMultiMouseDownListener(editor.renderer.scrollBarV.inner, [400, 300, 250], this, "onMouseEvent");
                        addMultiMouseDownListener(editor.renderer.scrollBarH.inner, [400, 300, 250], this, "onMouseEvent");
                        if (isIE) {
                            addListener(editor.renderer.scrollBarV.element, "mousedown", onMouseDown);
                            addListener(editor.renderer.scrollBarH.element, "mousemove", onMouseDown);
                        }
                    }
                    addMouseWheelListener(editor.container, this.emitEditorMouseWheelEvent.bind(this, "mousewheel"));
                    var gutterEl = editor.renderer.$gutter;
                    addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
                    addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
                    addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
                    addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
                    addListener(mouseTarget, "mousedown", onMouseDown);
                    addListener(gutterEl, "mousedown", function (e) {
                        editor.focus();
                        return _preventDefault(e);
                    });
                    editor.on('mousemove', function (e) {
                        if (_self.state || _self.$dragDelay || !_self.$dragEnabled) {
                            return;
                        }
                        var char = editor.renderer.screenToTextCoordinates(e.x, e.y);
                        var range = editor.getSession().getSelection().getRange();
                        var renderer = editor.renderer;
                        if (!range.isEmpty() && range.insideStart(char.row, char.column)) {
                            renderer.setCursorStyle('default');
                        } else {
                            renderer.setCursorStyle("");
                        }
                    });
                }

                _createClass(MouseHandler, [{
                    key: "onMouseEvent",
                    value: function onMouseEvent(name, e) {
                        this.editor._emit(name, new EditorMouseEvent(e, this.editor));
                    }
                }, {
                    key: "onMouseMove",
                    value: function onMouseMove(name, e) {
                        if (this.editor.hasListeners('mousemove')) {
                            this.editor._emit(name, new EditorMouseEvent(e, this.editor));
                        }
                    }
                }, {
                    key: "emitEditorMouseWheelEvent",
                    value: function emitEditorMouseWheelEvent(name, e) {
                        var mouseEvent = new EditorMouseEvent(e, this.editor);
                        mouseEvent.speed = this.$scrollSpeed * 2;
                        mouseEvent.wheelX = e['wheelX'];
                        mouseEvent.wheelY = e['wheelY'];
                        this.editor._emit(name, mouseEvent);
                    }
                }, {
                    key: "setState",
                    value: function setState(state) {
                        this.state = state;
                    }
                }, {
                    key: "textCoordinates",
                    value: function textCoordinates() {
                        return this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                    }
                }, {
                    key: "captureMouse",
                    value: function captureMouse(ev, mouseMoveHandler) {
                        this.clientX = ev.clientX;
                        this.clientY = ev.clientY;
                        this.isMousePressed = true;
                        var renderer = this.editor.renderer;
                        if (renderer.$keepTextAreaAtCursor) {
                            renderer.$keepTextAreaAtCursor = null;
                        }
                        var onMouseMove = (function (editor, mouseHandler) {
                            return function (mouseEvent) {
                                if (!mouseEvent) return;
                                if (isWebKit && !mouseEvent.which && mouseHandler.releaseMouse) {
                                    return mouseHandler.releaseMouse(undefined);
                                }
                                mouseHandler.clientX = mouseEvent.clientX;
                                mouseHandler.clientY = mouseEvent.clientY;
                                mouseMoveHandler && mouseMoveHandler(mouseEvent);
                                mouseHandler.mouseEvent = new EditorMouseEvent(mouseEvent, editor);
                                mouseHandler.$mouseMoved = true;
                            };
                        })(this.editor, this);
                        var onCaptureEnd = (function (mouseHandler) {
                            return function (e) {
                                clearInterval(timerId);
                                onCaptureInterval();
                                mouseHandler[mouseHandler.state + "End"] && mouseHandler[mouseHandler.state + "End"](e);
                                mouseHandler.state = "";
                                if (renderer.$keepTextAreaAtCursor == null) {
                                    renderer.$keepTextAreaAtCursor = true;
                                    renderer.$moveTextAreaToCursor();
                                }
                                mouseHandler.isMousePressed = false;
                                mouseHandler.$onCaptureMouseMove = mouseHandler.releaseMouse = null;
                                e && mouseHandler.onMouseEvent("mouseup", e);
                            };
                        })(this);
                        var onCaptureInterval = (function (mouseHandler) {
                            return function () {
                                mouseHandler[mouseHandler.state] && mouseHandler[mouseHandler.state]();
                                mouseHandler.$mouseMoved = false;
                            };
                        })(this);
                        if (isOldIE && ev.domEvent.type == "dblclick") {
                            return setTimeout(function () {
                                onCaptureEnd(ev);
                            });
                        }
                        this.$onCaptureMouseMove = onMouseMove;
                        this.releaseMouse = capture(this.editor.container, onMouseMove, onCaptureEnd);
                        var timerId = setInterval(onCaptureInterval, 20);
                    }
                }, {
                    key: "cancelContextMenu",
                    value: function cancelContextMenu() {
                        var stop = (function (e) {
                            if (e && e.domEvent && e.domEvent.type != "contextmenu") {
                                return;
                            }
                            this.editor.off("nativecontextmenu", stop);
                            if (e && e.domEvent) {
                                stopEvent(e.domEvent);
                            }
                        }).bind(this);
                        setTimeout(stop, 10);
                        this.editor.on("nativecontextmenu", stop);
                    }
                }, {
                    key: "select",
                    value: function select() {
                        var anchor;
                        var cursor = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                        if (this.$clickSelection) {
                            var cmp = this.$clickSelection.comparePoint(cursor);
                            if (cmp == -1) {
                                anchor = this.$clickSelection.end;
                            } else if (cmp == 1) {
                                anchor = this.$clickSelection.start;
                            } else {
                                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                                cursor = orientedRange.cursor;
                                anchor = orientedRange.anchor;
                            }
                            this.editor.selection.setSelectionAnchor(anchor.row, anchor.column);
                        }
                        this.editor.selection.selectToPosition(cursor);
                        this.editor.renderer.scrollCursorIntoView();
                    }
                }, {
                    key: "selectByLinesEnd",
                    value: function selectByLinesEnd() {
                        this.$clickSelection = null;
                        this.editor.unsetStyle("ace_selecting");
                        if (this.editor.renderer.scroller['releaseCapture']) {
                            this.editor.renderer.scroller['releaseCapture']();
                        }
                    }
                }, {
                    key: "startSelect",
                    value: function startSelect(pos, waitForClickSelection) {
                        pos = pos || this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                        var editor = this.editor;
                        if (this.mousedownEvent.getShiftKey()) {
                            editor.selection.selectToPosition(pos);
                        } else if (!waitForClickSelection) {
                            editor.selection.moveToPosition(pos);
                        }
                        if (!waitForClickSelection) {
                            this.select();
                        }
                        if (this.editor.renderer.scroller['setCapture']) {
                            this.editor.renderer.scroller['setCapture']();
                        }
                        editor.setStyle("ace_selecting");
                        this.setState("select");
                    }
                }, {
                    key: "selectEnd",
                    value: function selectEnd() {
                        this.selectByLinesEnd();
                    }
                }, {
                    key: "selectAllEnd",
                    value: function selectAllEnd() {
                        this.selectByLinesEnd();
                    }
                }, {
                    key: "selectByWordsEnd",
                    value: function selectByWordsEnd() {
                        this.selectByLinesEnd();
                    }
                }, {
                    key: "focusWait",
                    value: function focusWait() {
                        var distance = calcDistance(this.mousedownEvent.clientX, this.mousedownEvent.clientY, this.clientX, this.clientY);
                        var time = Date.now();
                        if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout) {
                            this.startSelect(this.mousedownEvent.getDocumentPosition());
                        }
                    }
                }]);

                return MouseHandler;
            })();

            defineOptions(MouseHandler.prototype, "mouseHandler", {
                scrollSpeed: { initialValue: 2 },
                dragDelay: { initialValue: isMac ? 150 : 0 },
                dragEnabled: { initialValue: true },
                focusTimout: { initialValue: 0 },
                tooltipFollowsMouse: { initialValue: true }
            });

            EditorMouseEvent = (function () {
                function EditorMouseEvent(domEvent, editor) {
                    _classCallCheck(this, EditorMouseEvent);

                    this.propagationStopped = false;
                    this.defaultPrevented = false;
                    this.getAccelKey = isMac ? function () {
                        return this.domEvent.metaKey;
                    } : function () {
                        return this.domEvent.ctrlKey;
                    };
                    this.domEvent = domEvent;
                    this.editor = editor;
                    this.clientX = domEvent.clientX;
                    this.clientY = domEvent.clientY;
                    this.$pos = null;
                    this.$inSelection = null;
                }

                _createClass(EditorMouseEvent, [{
                    key: "stopPropagation",
                    value: function stopPropagation() {
                        _stopPropagation(this.domEvent);
                        this.propagationStopped = true;
                    }
                }, {
                    key: "preventDefault",
                    value: function preventDefault() {
                        _preventDefault(this.domEvent);
                        this.defaultPrevented = true;
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        this.stopPropagation();
                        this.preventDefault();
                    }
                }, {
                    key: "getDocumentPosition",
                    value: function getDocumentPosition() {
                        if (!this.$pos) {
                            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
                        }
                        return this.$pos;
                    }
                }, {
                    key: "inSelection",
                    value: function inSelection() {
                        if (this.$inSelection !== null) return this.$inSelection;
                        var editor = this.editor;
                        var selectionRange = editor.getSelectionRange();
                        if (selectionRange.isEmpty()) this.$inSelection = false;else {
                            var pos = this.getDocumentPosition();
                            this.$inSelection = selectionRange.contains(pos.row, pos.column);
                        }
                        return this.$inSelection;
                    }
                }, {
                    key: "getButton",
                    value: function getButton() {
                        return _getButton(this.domEvent);
                    }
                }, {
                    key: "getShiftKey",
                    value: function getShiftKey() {
                        return this.domEvent.shiftKey;
                    }
                }, {
                    key: "toElement",
                    get: function get() {
                        return this.domEvent.toElement;
                    }
                }]);

                return EditorMouseEvent;
            })();

            DRAG_OFFSET = 0;

            GutterHandler = function GutterHandler(mouseHandler) {
                _classCallCheck(this, GutterHandler);

                var editor = mouseHandler.editor;
                var gutter = editor.renderer.$gutterLayer;
                var tooltip = new GutterTooltip(editor.container);
                mouseHandler.editor.setDefaultHandler("guttermousedown", function (e) {
                    if (!editor.isFocused() || e.getButton() != 0) {
                        return;
                    }
                    var gutterRegion = gutter.getRegion(e);
                    if (gutterRegion === "foldWidgets") {
                        return;
                    }
                    var row = e.getDocumentPosition().row;
                    var selection = editor.getSession().getSelection();
                    if (e.getShiftKey()) {
                        selection.selectTo(row, 0);
                    } else {
                        if (e.domEvent.detail == 2) {
                            editor.selectAll();
                            return e.preventDefault();
                        }
                        mouseHandler.$clickSelection = editor.selection.getLineRange(row);
                    }
                    mouseHandler.setState("selectByLines");
                    mouseHandler.captureMouse(e);
                    return e.preventDefault();
                });
                var tooltipTimeout;
                var mouseEvent;
                var tooltipAnnotation;
                function showTooltip() {
                    var row = mouseEvent.getDocumentPosition().row;
                    var annotation = gutter.$annotations[row];
                    if (!annotation) {
                        return hideTooltip(void 0, editor);
                    }
                    var session = editor.getSession();
                    var maxRow = session.getLength();
                    if (row == maxRow) {
                        var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.clientY).row;
                        var pos = mouseEvent.getDocumentPosition();
                        if (screenRow > session.documentToScreenRow(pos.row, pos.column)) {
                            return hideTooltip(void 0, editor);
                        }
                    }
                    if (tooltipAnnotation == annotation) {
                        return;
                    }
                    tooltipAnnotation = annotation.text.join("<br/>");
                    tooltip.setHtml(tooltipAnnotation);
                    tooltip.show();
                    editor.on("mousewheel", hideTooltip);
                    if (mouseHandler.$tooltipFollowsMouse) {
                        moveTooltip(mouseEvent);
                    } else {
                        var gutterElement = gutter.$cells[editor.getSession().documentToScreenRow(row, 0)].element;
                        var rect = gutterElement.getBoundingClientRect();
                        var style = tooltip.getElement().style;
                        style.left = rect.right + "px";
                        style.top = rect.bottom + "px";
                    }
                }
                function hideTooltip(event, editor) {
                    if (tooltipTimeout) {
                        clearTimeout(tooltipTimeout);
                        tooltipTimeout = undefined;
                    }
                    if (tooltipAnnotation) {
                        tooltip.hide();
                        tooltipAnnotation = null;
                        editor.off("mousewheel", hideTooltip);
                    }
                }
                function moveTooltip(event) {
                    tooltip.setPosition(event.clientX, event.clientY);
                }
                mouseHandler.editor.setDefaultHandler("guttermousemove", function (e) {
                    var target = e.domEvent.target || e.domEvent.srcElement;
                    if (hasCssClass(target, "ace_fold-widget")) {
                        return hideTooltip(void 0, editor);
                    }
                    if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse) {
                        moveTooltip(e);
                    }
                    mouseEvent = e;
                    if (tooltipTimeout) {
                        return;
                    }
                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();else hideTooltip(void 0, editor);
                    }, 50);
                });
                addListener(editor.renderer.$gutter, "mouseout", function (e) {
                    mouseEvent = null;
                    if (!tooltipAnnotation || tooltipTimeout) return;
                    tooltipTimeout = setTimeout(function () {
                        tooltipTimeout = null;
                        hideTooltip(void 0, editor);
                    }, 50);
                });
                editor.on("changeSession", hideTooltip);
            };

            GutterTooltip = (function (_Tooltip) {
                _inherits(GutterTooltip, _Tooltip);

                function GutterTooltip(parentNode) {
                    _classCallCheck(this, GutterTooltip);

                    _get(Object.getPrototypeOf(GutterTooltip.prototype), "constructor", this).call(this, parentNode);
                }

                _createClass(GutterTooltip, [{
                    key: "setPosition",
                    value: function setPosition(x, y) {
                        var windowWidth = window.innerWidth || document.documentElement.clientWidth;
                        var windowHeight = window.innerHeight || document.documentElement.clientHeight;
                        var width = this.getWidth();
                        var height = this.getHeight();
                        x += 15;
                        y += 15;
                        if (x + width > windowWidth) {
                            x -= x + width - windowWidth;
                        }
                        if (y + height > windowHeight) {
                            y -= 20 + height;
                        }
                        _get(Object.getPrototypeOf(GutterTooltip.prototype), "setPosition", this).call(this, x, y);
                    }
                }]);

                return GutterTooltip;
            })(Tooltip);
        }
    };
});
System.register("src/FoldLine.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, Range, FoldLine;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            FoldLine = (function () {
                function FoldLine(foldData, folds) {
                    _classCallCheck(this, FoldLine);

                    this.foldData = foldData;
                    if (Array.isArray(folds)) {
                        this.folds = folds;
                    } else {
                        throw new Error("folds must have type Fold[]");
                    }
                    var last = folds[folds.length - 1];
                    this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
                    this.start = this.range.start;
                    this.end = this.range.end;
                    this.folds.forEach(function (fold) {
                        fold.setFoldLine(this);
                    }, this);
                }

                _createClass(FoldLine, [{
                    key: "shiftRow",
                    value: function shiftRow(shift) {
                        this.start.row += shift;
                        this.end.row += shift;
                        this.folds.forEach(function (fold) {
                            fold.start.row += shift;
                            fold.end.row += shift;
                        });
                    }
                }, {
                    key: "addFold",
                    value: function addFold(fold) {
                        if (fold.sameRow) {
                            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                                throw new Error("Can't add a fold to this FoldLine as it has no connection");
                            }
                            this.folds.push(fold);
                            this.folds.sort(function (a, b) {
                                return -a.range.compareEnd(b.start.row, b.start.column);
                            });
                            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                                this.end.row = fold.end.row;
                                this.end.column = fold.end.column;
                            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                                this.start.row = fold.start.row;
                                this.start.column = fold.start.column;
                            }
                        } else if (fold.start.row == this.end.row) {
                            this.folds.push(fold);
                            this.end.row = fold.end.row;
                            this.end.column = fold.end.column;
                        } else if (fold.end.row == this.start.row) {
                            this.folds.unshift(fold);
                            this.start.row = fold.start.row;
                            this.start.column = fold.start.column;
                        } else {
                            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                        }
                        fold.foldLine = this;
                    }
                }, {
                    key: "containsRow",
                    value: function containsRow(row) {
                        return row >= this.start.row && row <= this.end.row;
                    }
                }, {
                    key: "walk",
                    value: function walk(callback, endRow, endColumn) {
                        var lastEnd = 0,
                            folds = this.folds,
                            fold,
                            cmp,
                            stop,
                            isNewRow = true;
                        if (endRow == null) {
                            endRow = this.end.row;
                            endColumn = this.end.column;
                        }
                        for (var i = 0; i < folds.length; i++) {
                            fold = folds[i];
                            cmp = fold.range.compareStart(endRow, endColumn);
                            if (cmp == -1) {
                                callback(null, endRow, endColumn, lastEnd, isNewRow);
                                return;
                            }
                            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                            if (stop || cmp === 0) {
                                return;
                            }
                            isNewRow = !fold.sameRow;
                            lastEnd = fold.end.column;
                        }
                        callback(null, endRow, endColumn, lastEnd, isNewRow);
                    }
                }, {
                    key: "getNextFoldTo",
                    value: function getNextFoldTo(row, column) {
                        var fold;
                        var cmp;
                        for (var i = 0; i < this.folds.length; i++) {
                            fold = this.folds[i];
                            cmp = fold.range.compareEnd(row, column);
                            if (cmp == -1) {
                                return {
                                    fold: fold,
                                    kind: "after"
                                };
                            } else if (cmp === 0) {
                                return {
                                    fold: fold,
                                    kind: "inside"
                                };
                            }
                        }
                        return null;
                    }
                }, {
                    key: "addRemoveChars",
                    value: function addRemoveChars(row, column, len) {
                        var ret = this.getNextFoldTo(row, column);
                        var fold;
                        var folds;
                        if (ret) {
                            fold = ret.fold;
                            if (ret.kind === "inside" && fold.start.column !== column && fold.start.row !== row) {
                                window.console && window.console.warn(row, column, fold);
                            } else if (fold.start.row == row) {
                                folds = this.folds;
                                var i = folds.indexOf(fold);
                                if (i === 0) {
                                    this.start.column += len;
                                }
                                for (i; i < folds.length; i++) {
                                    fold = folds[i];
                                    fold.start.column += len;
                                    if (!fold.sameRow) {
                                        return;
                                    }
                                    fold.end.column += len;
                                }
                                this.end.column += len;
                            }
                        }
                    }
                }, {
                    key: "split",
                    value: function split(row, column) {
                        var pos = this.getNextFoldTo(row, column);
                        if (!pos || pos.kind == "inside") return null;
                        var fold = pos.fold;
                        var folds = this.folds;
                        var foldData = this.foldData;
                        var i = folds.indexOf(fold);
                        var foldBefore = folds[i - 1];
                        this.end.row = foldBefore.end.row;
                        this.end.column = foldBefore.end.column;
                        folds = folds.splice(i, folds.length - i);
                        var newFoldLine = new FoldLine(foldData, folds);
                        foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
                        return newFoldLine;
                    }
                }, {
                    key: "merge",
                    value: function merge(foldLineNext) {
                        var folds = foldLineNext.folds;
                        for (var i = 0; i < folds.length; i++) {
                            this.addFold(folds[i]);
                        }
                        var foldData = this.foldData;
                        foldData.splice(foldData.indexOf(foldLineNext), 1);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var ret = [this.range.toString() + ": ["];
                        this.folds.forEach(function (fold) {
                            ret.push("  " + fold.toString());
                        });
                        ret.push("]");
                        return ret.join("\n");
                    }
                }, {
                    key: "idxToPosition",
                    value: function idxToPosition(idx) {
                        var lastFoldEndColumn = 0;
                        for (var i = 0; i < this.folds.length; i++) {
                            var fold = this.folds[i];
                            idx -= fold.start.column - lastFoldEndColumn;
                            if (idx < 0) {
                                return {
                                    row: fold.start.row,
                                    column: fold.start.column + idx
                                };
                            }
                            idx -= fold.placeholder.length;
                            if (idx < 0) {
                                return fold.start;
                            }
                            lastFoldEndColumn = fold.end.column;
                        }
                        return {
                            row: this.end.row,
                            column: this.end.column + idx
                        };
                    }
                }]);

                return FoldLine;
            })();

            _export("default", FoldLine);
        }
    };
});
System.register("src/comparePoints.js", [], function (_export) {
    "use strict";

    _export("default", comparePoints);

    function comparePoints(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    }

    return {
        setters: [],
        execute: function () {
            ;
        }
    };
});
System.register('src/range_list.js', ['npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'src/comparePoints.js'], function (_export) {
    var _createClass, _classCallCheck, comparePoints, RangeList;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_srcComparePointsJs) {
            comparePoints = _srcComparePointsJs['default'];
        }],
        execute: function () {
            'use strict';

            RangeList = (function () {
                function RangeList() {
                    _classCallCheck(this, RangeList);

                    this.ranges = [];
                }

                _createClass(RangeList, [{
                    key: 'pointIndex',
                    value: function pointIndex(pos, excludeEdges, startIndex) {
                        var list = this.ranges;
                        for (var i = startIndex || 0; i < list.length; i++) {
                            var range = list[i];
                            var cmpEnd = comparePoints(pos, range.end);
                            if (cmpEnd > 0) {
                                continue;
                            }
                            var cmpStart = comparePoints(pos, range.start);
                            if (cmpEnd === 0) {
                                return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                            }
                            if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) {
                                return i;
                            }
                            return -i - 1;
                        }
                        return -i - 1;
                    }
                }, {
                    key: 'add',
                    value: function add(range) {
                        var excludeEdges = !range.isEmpty();
                        var startIndex = this.pointIndex(range.start, excludeEdges);
                        if (startIndex < 0) startIndex = -startIndex - 1;
                        var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
                        if (endIndex < 0) {
                            endIndex = -endIndex - 1;
                        } else {
                            endIndex++;
                        }
                        return this.ranges.splice(startIndex, endIndex - startIndex, range);
                    }
                }, {
                    key: 'addList',
                    value: function addList(list) {
                        var removed = [];
                        for (var i = list.length; i--;) {
                            removed.push.call(removed, this.add(list[i]));
                        }
                        return removed;
                    }
                }, {
                    key: 'substractPoint',
                    value: function substractPoint(pos) {
                        var i = this.pointIndex(pos);
                        if (i >= 0) {
                            return this.ranges.splice(i, 1);
                        }
                    }
                }, {
                    key: 'merge',
                    value: function merge() {
                        var removed = [];
                        var list = this.ranges;
                        list = list.sort(function (a, b) {
                            return comparePoints(a.start, b.start);
                        });
                        var next = list[0],
                            range;
                        for (var i = 1; i < list.length; i++) {
                            range = next;
                            next = list[i];
                            var cmp = comparePoints(range.end, next.start);
                            if (cmp < 0) continue;
                            if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                            if (comparePoints(range.end, next.end) < 0) {
                                range.end.row = next.end.row;
                                range.end.column = next.end.column;
                            }
                            list.splice(i, 1);
                            removed.push(next);
                            next = range;
                            i--;
                        }
                        this.ranges = list;
                        return removed;
                    }
                }, {
                    key: 'contains',
                    value: function contains(row, column) {
                        return this.pointIndex({ row: row, column: column }) >= 0;
                    }
                }, {
                    key: 'containsPoint',
                    value: function containsPoint(pos) {
                        return this.pointIndex(pos) >= 0;
                    }
                }, {
                    key: 'rangeAtPoint',
                    value: function rangeAtPoint(pos) {
                        var i = this.pointIndex(pos);
                        if (i >= 0) {
                            return this.ranges[i];
                        }
                    }
                }, {
                    key: 'clipRows',
                    value: function clipRows(startRow, endRow) {
                        var list = this.ranges;
                        if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) {
                            return [];
                        }
                        var startIndex = this.pointIndex({ row: startRow, column: 0 });
                        if (startIndex < 0) {
                            startIndex = -startIndex - 1;
                        }
                        var excludeEdges = true;
                        var endIndex = this.pointIndex({ row: endRow, column: 0 }, excludeEdges, startIndex);
                        if (endIndex < 0) {
                            endIndex = -endIndex - 1;
                        }
                        var clipped = [];
                        for (var i = startIndex; i < endIndex; i++) {
                            clipped.push(list[i]);
                        }
                        return clipped;
                    }
                }, {
                    key: 'removeAll',
                    value: function removeAll() {
                        return this.ranges.splice(0, this.ranges.length);
                    }
                }, {
                    key: 'attach',
                    value: function attach(session) {
                        if (this.session) {
                            this.detach();
                        }
                        this.session = session;
                        this.onChange = this.$onChange.bind(this);
                        this.session.on('change', this.onChange);
                    }
                }, {
                    key: 'detach',
                    value: function detach() {
                        if (!this.session) {
                            return;
                        }
                        this.session.off('change', this.onChange);
                        this.session = null;
                    }
                }, {
                    key: '$onChange',
                    value: function $onChange(e, session) {
                        var changeRange = e.data.range;
                        if (e.data.action[0] == "i") {
                            var start = changeRange.start;
                            var end = changeRange.end;
                        } else {
                            var end = changeRange.start;
                            var start = changeRange.end;
                        }
                        var startRow = start.row;
                        var endRow = end.row;
                        var lineDif = endRow - startRow;
                        var colDiff = -start.column + end.column;
                        var ranges = this.ranges;
                        for (var i = 0, n = ranges.length; i < n; i++) {
                            var r = ranges[i];
                            if (r.end.row < startRow) {
                                continue;
                            }
                            if (r.start.row > startRow) {
                                break;
                            }
                            if (r.start.row == startRow && r.start.column >= start.column) {
                                if (r.start.column == start.column && this['$insertRight']) {} else {
                                    r.start.column += colDiff;
                                    r.start.row += lineDif;
                                }
                            }
                            if (r.end.row == startRow && r.end.column >= start.column) {
                                if (r.end.column == start.column && this['$insertRight']) {
                                    continue;
                                }
                                if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                                    if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) {
                                        r.end.column -= colDiff;
                                    }
                                }
                                r.end.column += colDiff;
                                r.end.row += lineDif;
                            }
                        }
                        if (lineDif != 0 && i < n) {
                            for (; i < n; i++) {
                                var r = ranges[i];
                                r.start.row += lineDif;
                                r.end.row += lineDif;
                            }
                        }
                    }
                }]);

                return RangeList;
            })();

            _export('RangeList', RangeList);
        }
    };
});
System.register("src/Fold.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/range_list.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, RangeList, Fold;

    function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0) point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
        if (point.row == 0) point.column += anchor.column;
        point.row += anchor.row;
    }
    function _restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcRange_listJs) {
            RangeList = _srcRange_listJs.RangeList;
        }],
        execute: function () {
            "use strict";

            Fold = (function (_RangeList) {
                _inherits(Fold, _RangeList);

                function Fold(range, placeholder) {
                    _classCallCheck(this, Fold);

                    _get(Object.getPrototypeOf(Fold.prototype), "constructor", this).call(this);
                    this.foldLine = null;
                    this.placeholder = placeholder;
                    this.range = range;
                    this.start = range.start;
                    this.end = range.end;
                    this.sameRow = range.start.row === range.end.row;
                    this.subFolds = this.ranges = [];
                }

                _createClass(Fold, [{
                    key: "toString",
                    value: function toString() {
                        return '"' + this.placeholder + '" ' + this.range.toString();
                    }
                }, {
                    key: "setFoldLine",
                    value: function setFoldLine(foldLine) {
                        this.foldLine = foldLine;
                        this.subFolds.forEach(function (fold) {
                            fold.setFoldLine(foldLine);
                        });
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        var range = this.range.clone();
                        var fold = new Fold(range, this.placeholder);
                        this.subFolds.forEach(function (subFold) {
                            fold.subFolds.push(subFold.clone());
                        });
                        fold.collapseChildren = this.collapseChildren;
                        return fold;
                    }
                }, {
                    key: "addSubFold",
                    value: function addSubFold(fold) {
                        if (this.range.isEqual(fold)) return;
                        if (!this.range.containsRange(fold)) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
                        consumeRange(fold, this.start);
                        var row = fold.start.row,
                            column = fold.start.column;
                        for (var i = 0, cmp = -1; i < this.subFolds.length; i++) {
                            cmp = this.subFolds[i].range.compare(row, column);
                            if (cmp != 1) break;
                        }
                        var afterStart = this.subFolds[i];
                        if (cmp == 0) return afterStart.addSubFold(fold);
                        var row = fold.range.end.row,
                            column = fold.range.end.column;
                        for (var j = i, cmp = -1; j < this.subFolds.length; j++) {
                            cmp = this.subFolds[j].range.compare(row, column);
                            if (cmp != 1) break;
                        }
                        var afterEnd = this.subFolds[j];
                        if (cmp == 0) throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
                        var consumedFolds = this.subFolds.splice(i, j - i, fold);
                        fold.setFoldLine(this.foldLine);
                        return fold;
                    }
                }, {
                    key: "restoreRange",
                    value: function restoreRange(range) {
                        return _restoreRange(range, this.start);
                    }
                }]);

                return Fold;
            })(RangeList);

            _export("default", Fold);
        }
    };
});
System.register('src/Anchor.js', ['npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'src/lib/EventEmitterClass.js', 'src/lib/asserts.js'], function (_export) {
    var _createClass, _classCallCheck, EventEmitterClass, assert, Anchor;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs['default'];
        }, function (_srcLibAssertsJs) {
            assert = _srcLibAssertsJs.assert;
        }],
        execute: function () {
            "use strict";

            Anchor = (function () {
                function Anchor(doc, row, column) {
                    _classCallCheck(this, Anchor);

                    assert(typeof row === 'number', "row must be a number");
                    assert(typeof column === 'number', "column must be a number");
                    this.eventBus = new EventEmitterClass(this);
                    this.$onChange = this.onChange.bind(this);
                    this.attach(doc);
                    this.setPosition(row, column);
                    this.$insertRight = false;
                }

                _createClass(Anchor, [{
                    key: 'getPosition',
                    value: function getPosition() {
                        return this.$clipPositionToDocument(this.row, this.column);
                    }
                }, {
                    key: 'getDocument',
                    value: function getDocument() {
                        return this.document;
                    }
                }, {
                    key: 'onChange',
                    value: function onChange(e, doc) {
                        var delta = e.data;
                        var range = delta.range;
                        if (range.start.row == range.end.row && range.start.row != this.row) return;
                        if (range.start.row > this.row) return;
                        if (range.start.row == this.row && range.start.column > this.column) return;
                        var row = this.row;
                        var column = this.column;
                        var start = range.start;
                        var end = range.end;
                        if (delta.action === "insertText") {
                            if (start.row === row && start.column <= column) {
                                if (start.column === column && this.$insertRight) {} else if (start.row === end.row) {
                                    column += end.column - start.column;
                                } else {
                                    column -= start.column;
                                    row += end.row - start.row;
                                }
                            } else if (start.row !== end.row && start.row < row) {
                                row += end.row - start.row;
                            }
                        } else if (delta.action === "insertLines") {
                            if (start.row === row && column === 0 && this.$insertRight) {} else if (start.row <= row) {
                                row += end.row - start.row;
                            }
                        } else if (delta.action === "removeText") {
                            if (start.row === row && start.column < column) {
                                if (end.column >= column) column = start.column;else column = Math.max(0, column - (end.column - start.column));
                            } else if (start.row !== end.row && start.row < row) {
                                if (end.row === row) column = Math.max(0, column - end.column) + start.column;
                                row -= end.row - start.row;
                            } else if (end.row === row) {
                                row -= end.row - start.row;
                                column = Math.max(0, column - end.column) + start.column;
                            }
                        } else if (delta.action == "removeLines") {
                            if (start.row <= row) {
                                if (end.row <= row) row -= end.row - start.row;else {
                                    row = start.row;
                                    column = 0;
                                }
                            }
                        }
                        this.setPosition(row, column, true);
                    }
                }, {
                    key: 'setPosition',
                    value: function setPosition(row, column, noClip) {
                        var pos;
                        if (noClip) {
                            pos = { row: row, column: column };
                        } else {
                            pos = this.$clipPositionToDocument(row, column);
                        }
                        if (this.row === pos.row && this.column === pos.column) {
                            return;
                        }
                        var old = { row: this.row, column: this.column };
                        this.row = pos.row;
                        this.column = pos.column;
                        this.eventBus._signal("change", { old: old, value: pos });
                    }
                }, {
                    key: 'detach',
                    value: function detach() {
                        this.document.off("change", this.$onChange);
                    }
                }, {
                    key: 'attach',
                    value: function attach(doc) {
                        this.document = doc || this.document;
                        this.document.on("change", this.$onChange);
                    }
                }, {
                    key: 'on',
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: 'off',
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: '$clipPositionToDocument',
                    value: function $clipPositionToDocument(row, column) {
                        var pos = { row: 0, column: 0 };
                        if (row >= this.document.getLength()) {
                            pos.row = Math.max(0, this.document.getLength() - 1);
                            pos.column = this.document.getLine(pos.row).length;
                        } else if (row < 0) {
                            pos.row = 0;
                            pos.column = 0;
                        } else {
                            pos.row = row;
                            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
                        }
                        if (column < 0) {
                            pos.column = 0;
                        }
                        return pos;
                    }
                }]);

                return Anchor;
            })();

            _export('default', Anchor);
        }
    };
});
System.register("src/Selection.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/lang.js", "src/lib/EventEmitterClass.js", "src/Range.js", "src/Anchor.js"], function (_export) {
    var _createClass, _classCallCheck, stringReverse, EventEmitterClass, Range, Anchor, Selection;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibLangJs) {
            stringReverse = _srcLibLangJs.stringReverse;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcAnchorJs) {
            Anchor = _srcAnchorJs["default"];
        }],
        execute: function () {
            "use strict";

            Selection = (function () {
                function Selection(session) {
                    _classCallCheck(this, Selection);

                    this.eventBus = new EventEmitterClass(this);
                    this.session = session;
                    this.doc = session.getDocument();
                    this.clearSelection();
                    this.lead = this.selectionLead = new Anchor(this.doc, 0, 0);
                    this.anchor = this.selectionAnchor = new Anchor(this.doc, 0, 0);
                    var self = this;
                    this.lead.on("change", function (e) {
                        self.eventBus._emit("changeCursor");
                        if (!self.$isEmpty) {
                            self.eventBus._emit("changeSelection");
                        }
                        if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column) self.$desiredColumn = null;
                    });
                    this.selectionAnchor.on("change", function () {
                        if (!self.$isEmpty) {
                            self.eventBus._emit("changeSelection");
                        }
                    });
                }

                _createClass(Selection, [{
                    key: "isEmpty",
                    value: function isEmpty() {
                        return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
                    }
                }, {
                    key: "isMultiLine",
                    value: function isMultiLine() {
                        if (this.isEmpty()) {
                            return false;
                        }
                        return this.getRange().isMultiLine();
                    }
                }, {
                    key: "getCursor",
                    value: function getCursor() {
                        return this.lead.getPosition();
                    }
                }, {
                    key: "setSelectionAnchor",
                    value: function setSelectionAnchor(row, column) {
                        this.anchor.setPosition(row, column);
                        if (this.$isEmpty) {
                            this.$isEmpty = false;
                            this.eventBus._emit("changeSelection");
                        }
                    }
                }, {
                    key: "getSelectionAnchor",
                    value: function getSelectionAnchor() {
                        if (this.$isEmpty) {
                            return this.getSelectionLead();
                        } else {
                            return this.anchor.getPosition();
                        }
                    }
                }, {
                    key: "getSelectionLead",
                    value: function getSelectionLead() {
                        return this.lead.getPosition();
                    }
                }, {
                    key: "shiftSelection",
                    value: function shiftSelection(columns) {
                        if (this.$isEmpty) {
                            this.moveCursorTo(this.lead.row, this.lead.column + columns);
                            return;
                        }
                        var anchor = this.getSelectionAnchor();
                        var lead = this.getSelectionLead();
                        var isBackwards = this.isBackwards();
                        if (!isBackwards || anchor.column !== 0) this.setSelectionAnchor(anchor.row, anchor.column + columns);
                        if (isBackwards || lead.column !== 0) {
                            this.$moveSelection(function () {
                                this.moveCursorTo(lead.row, lead.column + columns);
                            });
                        }
                    }
                }, {
                    key: "isBackwards",
                    value: function isBackwards() {
                        var anchor = this.anchor;
                        var lead = this.lead;
                        return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
                    }
                }, {
                    key: "getRange",
                    value: function getRange() {
                        var anchor = this.anchor;
                        var lead = this.lead;
                        if (this.isEmpty()) return Range.fromPoints(lead, lead);
                        if (this.isBackwards()) {
                            return Range.fromPoints(lead, anchor);
                        } else {
                            return Range.fromPoints(anchor, lead);
                        }
                    }
                }, {
                    key: "clearSelection",
                    value: function clearSelection() {
                        if (!this.$isEmpty) {
                            this.$isEmpty = true;
                            this.eventBus._emit("changeSelection");
                        }
                    }
                }, {
                    key: "selectAll",
                    value: function selectAll() {
                        var lastRow = this.doc.getLength() - 1;
                        this.setSelectionAnchor(0, 0);
                        this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
                    }
                }, {
                    key: "setRange",
                    value: function setRange(range, reverse) {
                        this.setSelectionRange(range, reverse);
                    }
                }, {
                    key: "setSelectionRange",
                    value: function setSelectionRange(range, reverse) {
                        if (reverse) {
                            this.setSelectionAnchor(range.end.row, range.end.column);
                            this.selectTo(range.start.row, range.start.column);
                        } else {
                            this.setSelectionAnchor(range.start.row, range.start.column);
                            this.selectTo(range.end.row, range.end.column);
                        }
                        if (this.getRange().isEmpty()) this.$isEmpty = true;
                        this.$desiredColumn = null;
                    }
                }, {
                    key: "$moveSelection",
                    value: function $moveSelection(mover) {
                        var lead = this.lead;
                        if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);
                        mover.call(this);
                    }
                }, {
                    key: "selectTo",
                    value: function selectTo(row, column) {
                        this.$moveSelection(function () {
                            this.moveCursorTo(row, column);
                        });
                    }
                }, {
                    key: "selectToPosition",
                    value: function selectToPosition(position) {
                        var self = this;
                        this.$moveSelection(function () {
                            self.moveCursorToPosition(position);
                        });
                    }
                }, {
                    key: "moveTo",
                    value: function moveTo(row, column) {
                        this.clearSelection();
                        this.moveCursorTo(row, column);
                    }
                }, {
                    key: "moveToPosition",
                    value: function moveToPosition(pos) {
                        this.clearSelection();
                        this.moveCursorToPosition(pos);
                    }
                }, {
                    key: "selectUp",
                    value: function selectUp() {
                        this.$moveSelection(this.moveCursorUp);
                    }
                }, {
                    key: "selectDown",
                    value: function selectDown() {
                        this.$moveSelection(this.moveCursorDown);
                    }
                }, {
                    key: "selectRight",
                    value: function selectRight() {
                        this.$moveSelection(this.moveCursorRight);
                    }
                }, {
                    key: "selectLeft",
                    value: function selectLeft() {
                        this.$moveSelection(this.moveCursorLeft);
                    }
                }, {
                    key: "selectLineStart",
                    value: function selectLineStart() {
                        this.$moveSelection(this.moveCursorLineStart);
                    }
                }, {
                    key: "selectLineEnd",
                    value: function selectLineEnd() {
                        this.$moveSelection(this.moveCursorLineEnd);
                    }
                }, {
                    key: "selectFileEnd",
                    value: function selectFileEnd() {
                        this.$moveSelection(this.moveCursorFileEnd);
                    }
                }, {
                    key: "selectFileStart",
                    value: function selectFileStart() {
                        this.$moveSelection(this.moveCursorFileStart);
                    }
                }, {
                    key: "selectWordRight",
                    value: function selectWordRight() {
                        this.$moveSelection(this.moveCursorWordRight);
                    }
                }, {
                    key: "selectWordLeft",
                    value: function selectWordLeft() {
                        this.$moveSelection(this.moveCursorWordLeft);
                    }
                }, {
                    key: "getWordRange",
                    value: function getWordRange(row, column) {
                        return this.session.getWordRange(row, column);
                    }
                }, {
                    key: "selectWord",
                    value: function selectWord() {
                        this.setSelectionRange(this.getWordRange(this.lead.row, this.lead.column));
                    }
                }, {
                    key: "selectAWord",
                    value: function selectAWord() {
                        var cursor = this.getCursor();
                        var range = this.session.getAWordRange(cursor.row, cursor.column);
                        this.setSelectionRange(range);
                    }
                }, {
                    key: "getLineRange",
                    value: function getLineRange(row, excludeLastChar) {
                        var rowStart = typeof row == "number" ? row : this.lead.row;
                        var rowEnd;
                        var foldLine = this.session.getFoldLine(rowStart);
                        if (foldLine) {
                            rowStart = foldLine.start.row;
                            rowEnd = foldLine.end.row;
                        } else {
                            rowEnd = rowStart;
                        }
                        if (excludeLastChar) {
                            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
                        } else {
                            return new Range(rowStart, 0, rowEnd + 1, 0);
                        }
                    }
                }, {
                    key: "selectLine",
                    value: function selectLine() {
                        this.setSelectionRange(this.getLineRange());
                    }
                }, {
                    key: "moveCursorUp",
                    value: function moveCursorUp() {
                        this.moveCursorBy(-1, 0);
                    }
                }, {
                    key: "moveCursorDown",
                    value: function moveCursorDown() {
                        this.moveCursorBy(1, 0);
                    }
                }, {
                    key: "moveCursorLeft",
                    value: function moveCursorLeft() {
                        var cursor = this.lead.getPosition(),
                            fold;
                        if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
                            this.moveCursorTo(fold.start.row, fold.start.column);
                        } else if (cursor.column === 0) {
                            if (cursor.row > 0) {
                                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
                            }
                        } else {
                            var tabSize = this.session.getTabSize();
                            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize) this.moveCursorBy(0, -tabSize);else this.moveCursorBy(0, -1);
                        }
                    }
                }, {
                    key: "moveCursorRight",
                    value: function moveCursorRight() {
                        var pos = this.lead.getPosition();
                        var fold = this.session.getFoldAt(pos.row, pos.column, 1);
                        if (fold) {
                            this.moveCursorTo(fold.end.row, fold.end.column);
                        } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                            if (this.lead.row < this.doc.getLength() - 1) {
                                this.moveCursorTo(this.lead.row + 1, 0);
                            }
                        } else {
                            var tabSize = this.session.getTabSize();
                            var cursor = this.lead;
                            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize) {
                                this.moveCursorBy(0, tabSize);
                            } else {
                                this.moveCursorBy(0, 1);
                            }
                        }
                    }
                }, {
                    key: "moveCursorLineStart",
                    value: function moveCursorLineStart() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var screenRow = this.session.documentToScreenRow(row, column);
                        var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
                        var beforeCursor = this.session['getDisplayLine'](row, null, firstColumnPosition.row, firstColumnPosition.column);
                        var leadingSpace = beforeCursor.match(/^\s*/);
                        if (leadingSpace[0].length != column && !this.session['$useEmacsStyleLineStart']) firstColumnPosition.column += leadingSpace[0].length;
                        this.moveCursorToPosition(firstColumnPosition);
                    }
                }, {
                    key: "moveCursorLineEnd",
                    value: function moveCursorLineEnd() {
                        var lead = this.lead;
                        var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
                        if (this.lead.column == lineEnd.column) {
                            var line = this.session.getLine(lineEnd.row);
                            if (lineEnd.column == line.length) {
                                var textEnd = line.search(/\s+$/);
                                if (textEnd > 0) lineEnd.column = textEnd;
                            }
                        }
                        this.moveCursorTo(lineEnd.row, lineEnd.column);
                    }
                }, {
                    key: "moveCursorFileEnd",
                    value: function moveCursorFileEnd() {
                        var row = this.doc.getLength() - 1;
                        var column = this.doc.getLine(row).length;
                        this.moveCursorTo(row, column);
                    }
                }, {
                    key: "moveCursorFileStart",
                    value: function moveCursorFileStart() {
                        this.moveCursorTo(0, 0);
                    }
                }, {
                    key: "moveCursorLongWordRight",
                    value: function moveCursorLongWordRight() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var line = this.doc.getLine(row);
                        var rightOfCursor = line.substring(column);
                        var match;
                        this.session.nonTokenRe.lastIndex = 0;
                        this.session.tokenRe.lastIndex = 0;
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) {
                            this.moveCursorTo(fold.end.row, fold.end.column);
                            return;
                        }
                        if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
                            column += this.session.nonTokenRe.lastIndex;
                            this.session.nonTokenRe.lastIndex = 0;
                            rightOfCursor = line.substring(column);
                        }
                        if (column >= line.length) {
                            this.moveCursorTo(row, line.length);
                            this.moveCursorRight();
                            if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                            return;
                        }
                        if (match = this.session.tokenRe.exec(rightOfCursor)) {
                            column += this.session.tokenRe.lastIndex;
                            this.session.tokenRe.lastIndex = 0;
                        }
                        this.moveCursorTo(row, column);
                    }
                }, {
                    key: "moveCursorLongWordLeft",
                    value: function moveCursorLongWordLeft() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var fold;
                        if (fold = this.session.getFoldAt(row, column, -1)) {
                            this.moveCursorTo(fold.start.row, fold.start.column);
                            return;
                        }
                        var str = this.session.getFoldStringAt(row, column, -1);
                        if (str == null) {
                            str = this.doc.getLine(row).substring(0, column);
                        }
                        var leftOfCursor = stringReverse(str);
                        var match;
                        this.session.nonTokenRe.lastIndex = 0;
                        this.session.tokenRe.lastIndex = 0;
                        if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
                            column -= this.session.nonTokenRe.lastIndex;
                            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                            this.session.nonTokenRe.lastIndex = 0;
                        }
                        if (column <= 0) {
                            this.moveCursorTo(row, 0);
                            this.moveCursorLeft();
                            if (row > 0) this.moveCursorWordLeft();
                            return;
                        }
                        if (match = this.session.tokenRe.exec(leftOfCursor)) {
                            column -= this.session.tokenRe.lastIndex;
                            this.session.tokenRe.lastIndex = 0;
                        }
                        this.moveCursorTo(row, column);
                    }
                }, {
                    key: "$shortWordEndIndex",
                    value: function $shortWordEndIndex(rightOfCursor) {
                        var match,
                            index = 0,
                            ch;
                        var whitespaceRe = /\s/;
                        var tokenRe = this.session.tokenRe;
                        tokenRe.lastIndex = 0;
                        if (match = this.session.tokenRe.exec(rightOfCursor)) {
                            index = this.session.tokenRe.lastIndex;
                        } else {
                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                            if (index < 1) {
                                tokenRe.lastIndex = 0;
                                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                                    tokenRe.lastIndex = 0;
                                    index++;
                                    if (whitespaceRe.test(ch)) {
                                        if (index > 2) {
                                            index--;
                                            break;
                                        } else {
                                            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch)) index++;
                                            if (index > 2) break;
                                        }
                                    }
                                }
                            }
                        }
                        tokenRe.lastIndex = 0;
                        return index;
                    }
                }, {
                    key: "moveCursorShortWordRight",
                    value: function moveCursorShortWordRight() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var line = this.doc.getLine(row);
                        var rightOfCursor = line.substring(column);
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);
                        if (column == line.length) {
                            var l = this.doc.getLength();
                            do {
                                row++;
                                rightOfCursor = this.doc.getLine(row);
                            } while (row < l && /^\s*$/.test(rightOfCursor));
                            if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                            column = 0;
                        }
                        var index = this.$shortWordEndIndex(rightOfCursor);
                        this.moveCursorTo(row, column + index);
                    }
                }, {
                    key: "moveCursorShortWordLeft",
                    value: function moveCursorShortWordLeft() {
                        var row = this.lead.row;
                        var column = this.lead.column;
                        var fold;
                        if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);
                        var line = this.session.getLine(row).substring(0, column);
                        if (column == 0) {
                            do {
                                row--;
                                line = this.doc.getLine(row);
                            } while (row > 0 && /^\s*$/.test(line));
                            column = line.length;
                            if (!/\s+$/.test(line)) line = "";
                        }
                        var leftOfCursor = stringReverse(line);
                        var index = this.$shortWordEndIndex(leftOfCursor);
                        return this.moveCursorTo(row, column - index);
                    }
                }, {
                    key: "moveCursorWordRight",
                    value: function moveCursorWordRight() {
                        if (this.session['$selectLongWords']) {
                            this.moveCursorLongWordRight();
                        } else {
                            this.moveCursorShortWordRight();
                        }
                    }
                }, {
                    key: "moveCursorWordLeft",
                    value: function moveCursorWordLeft() {
                        if (this.session['$selectLongWords']) {
                            this.moveCursorLongWordLeft();
                        } else {
                            this.moveCursorShortWordLeft();
                        }
                    }
                }, {
                    key: "moveCursorBy",
                    value: function moveCursorBy(rows, chars) {
                        var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
                        if (chars === 0) {
                            if (this.$desiredColumn) screenPos.column = this.$desiredColumn;else this.$desiredColumn = screenPos.column;
                        }
                        var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
                        if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
                            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) docPos.row++;
                        }
                        this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
                    }
                }, {
                    key: "moveCursorToPosition",
                    value: function moveCursorToPosition(position) {
                        this.moveCursorTo(position.row, position.column);
                    }
                }, {
                    key: "moveCursorTo",
                    value: function moveCursorTo(row, column, keepDesiredColumn) {
                        var fold = this.session.getFoldAt(row, column, 1);
                        if (fold) {
                            row = fold.start.row;
                            column = fold.start.column;
                        }
                        this.$keepDesiredColumnOnChange = true;
                        this.lead.setPosition(row, column);
                        this.$keepDesiredColumnOnChange = false;
                        if (!keepDesiredColumn) this.$desiredColumn = null;
                    }
                }, {
                    key: "moveCursorToScreen",
                    value: function moveCursorToScreen(row, column, keepDesiredColumn) {
                        var pos = this.session.screenToDocumentPosition(row, column);
                        this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "detach",
                    value: function detach() {
                        this.lead.detach();
                        this.anchor.detach();
                        this.session = this.doc = null;
                    }
                }, {
                    key: "fromOrientedRange",
                    value: function fromOrientedRange(range) {
                        this.setSelectionRange(range, range.cursor == range.start);
                        this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
                    }
                }, {
                    key: "toOrientedRange",
                    value: function toOrientedRange(range) {
                        var r = this.getRange();
                        if (range) {
                            range.start.column = r.start.column;
                            range.start.row = r.start.row;
                            range.end.column = r.end.column;
                            range.end.row = r.end.row;
                        } else {
                            range = r;
                        }
                        range.cursor = this.isBackwards() ? range.start : range.end;
                        range.desiredColumn = this.$desiredColumn;
                        return range;
                    }
                }, {
                    key: "getRangeOfMovements",
                    value: function getRangeOfMovements(func) {
                        var start = this.getCursor();
                        try {
                            func.call(null, this);
                            var end = this.getCursor();
                            return Range.fromPoints(start, end);
                        } catch (e) {
                            return Range.fromPoints(start, start);
                        } finally {
                            this.moveCursorToPosition(start);
                        }
                    }
                }, {
                    key: "toJSON",
                    value: function toJSON() {
                        if (this.rangeCount) {
                            var data = this.ranges.map(function (r) {
                                var r1 = r.clone();
                                r1.isBackwards = r.cursor == r.start;
                                return r1;
                            });
                        } else {
                            var data = this.getRange();
                            data.isBackwards = this.isBackwards();
                        }
                        return data;
                    }
                }, {
                    key: "toSingleRange",
                    value: function toSingleRange(data) {
                        throw new Error("Selection.toSingleRange is unsupported");
                    }
                }, {
                    key: "addRange",
                    value: function addRange(data, something) {
                        throw new Error("Selection.addRange is unsupported");
                    }
                }, {
                    key: "fromJSON",
                    value: function fromJSON(data) {
                        if (data.start == undefined) {
                            if (this.rangeList) {
                                this.toSingleRange(data[0]);
                                for (var i = data.length; i--;) {
                                    var r = Range.fromPoints(data[i].start, data[i].end);
                                    if (data.isBackwards) r.cursor = r.start;
                                    this.addRange(r, true);
                                }
                                return;
                            } else data = data[0];
                        }
                        if (this.rangeList) this.toSingleRange(data);
                        this.setSelectionRange(data, data.isBackwards);
                    }
                }, {
                    key: "isEqual",
                    value: function isEqual(data) {
                        if ((data.length || this.rangeCount) && data.length !== this.rangeCount) return false;
                        if (!data.length || !this.ranges) return this.getRange().isEqual(data);
                        for (var i = this.ranges.length; i--;) {
                            if (!this.ranges[i].isEqual(data[i])) return false;
                        }
                        return true;
                    }
                }]);

                return Selection;
            })();

            _export("default", Selection);
        }
    };
});
System.register('src/Document.js', ['npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'src/lib/EventEmitterClass.js', 'src/Range.js'], function (_export) {
    var _createClass, _classCallCheck, EventEmitterClass, Range, $split, Document;

    function $clipPosition(doc, position) {
        var length = doc.getLength();
        if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = doc.getLine(length - 1).length;
        } else if (position.row < 0) {
            position.row = 0;
        }
        return position;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs['default'];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs['default'];
        }],
        execute: function () {
            "use strict";

            $split = (function () {
                function foo(text) {
                    return text.replace(/\r\n|\r/g, "\n").split("\n");
                }
                function bar(text) {
                    return text.split(/\r\n|\r|\n/);
                }
                if ("aaa".split(/a/).length === 0) {
                    return foo;
                } else {
                    return bar;
                }
            })();

            Document = (function () {
                function Document(text) {
                    _classCallCheck(this, Document);

                    this.$lines = [];
                    this.$autoNewLine = "";
                    this.$newLineMode = "auto";
                    this.eventBus = new EventEmitterClass(this);
                    if (text.length === 0) {
                        this.$lines = [""];
                    } else if (Array.isArray(text)) {
                        this._insertLines(0, text);
                    } else {
                        this.insert({ row: 0, column: 0 }, text);
                    }
                }

                _createClass(Document, [{
                    key: 'setValue',
                    value: function setValue(text) {
                        var len = this.getLength();
                        this.remove(new Range(0, 0, len, this.getLine(len - 1).length));
                        this.insert({ row: 0, column: 0 }, text);
                    }
                }, {
                    key: 'getValue',
                    value: function getValue() {
                        return this.getAllLines().join(this.getNewLineCharacter());
                    }
                }, {
                    key: '$detectNewLine',
                    value: function $detectNewLine(text) {
                        var match = text.match(/^.*?(\r\n|\r|\n)/m);
                        this.$autoNewLine = match ? match[1] : "\n";
                        this.eventBus._signal("changeNewLineMode");
                    }
                }, {
                    key: 'getNewLineCharacter',
                    value: function getNewLineCharacter() {
                        switch (this.$newLineMode) {
                            case "windows":
                                return "\r\n";
                            case "unix":
                                return "\n";
                            default:
                                return this.$autoNewLine || "\n";
                        }
                    }
                }, {
                    key: 'setNewLineMode',
                    value: function setNewLineMode(newLineMode) {
                        if (this.$newLineMode === newLineMode) {
                            return;
                        }
                        this.$newLineMode = newLineMode;
                        this.eventBus._signal("changeNewLineMode");
                    }
                }, {
                    key: 'getNewLineMode',
                    value: function getNewLineMode() {
                        return this.$newLineMode;
                    }
                }, {
                    key: 'isNewLine',
                    value: function isNewLine(text) {
                        return text == "\r\n" || text == "\r" || text == "\n";
                    }
                }, {
                    key: 'getLine',
                    value: function getLine(row) {
                        return this.$lines[row] || "";
                    }
                }, {
                    key: 'getLines',
                    value: function getLines(firstRow, lastRow) {
                        return this.$lines.slice(firstRow, lastRow + 1);
                    }
                }, {
                    key: 'getAllLines',
                    value: function getAllLines() {
                        return this.getLines(0, this.getLength());
                    }
                }, {
                    key: 'getLength',
                    value: function getLength() {
                        return this.$lines.length;
                    }
                }, {
                    key: 'getTextRange',
                    value: function getTextRange(range) {
                        if (range.start.row === range.end.row) {
                            return this.getLine(range.start.row).substring(range.start.column, range.end.column);
                        }
                        var lines = this.getLines(range.start.row, range.end.row);
                        lines[0] = (lines[0] || "").substring(range.start.column);
                        var l = lines.length - 1;
                        if (range.end.row - range.start.row == l) {
                            lines[l] = lines[l].substring(0, range.end.column);
                        }
                        return lines.join(this.getNewLineCharacter());
                    }
                }, {
                    key: 'insert',
                    value: function insert(position, text) {
                        if (!text || text.length === 0) {
                            return position;
                        }
                        position = $clipPosition(this, position);
                        if (this.getLength() <= 1) {
                            this.$detectNewLine(text);
                        }
                        var lines = $split(text);
                        var firstLine = lines.splice(0, 1)[0];
                        var lastLine = lines.length == 0 ? null : lines.splice(lines.length - 1, 1)[0];
                        position = this.insertInLine(position, firstLine);
                        if (lastLine !== null) {
                            position = this.insertNewLine(position);
                            position = this._insertLines(position.row, lines);
                            position = this.insertInLine(position, lastLine || "");
                        }
                        return position;
                    }
                }, {
                    key: 'insertLines',
                    value: function insertLines(row, lines) {
                        if (row >= this.getLength()) return this.insert({ row: row, column: 0 }, "\n" + lines.join("\n"));
                        return this._insertLines(Math.max(row, 0), lines);
                    }
                }, {
                    key: '_insertLines',
                    value: function _insertLines(row, lines) {
                        if (lines.length == 0) return { row: row, column: 0 };
                        while (lines.length > 0xF000) {
                            var end = this._insertLines(row, lines.slice(0, 0xF000));
                            lines = lines.slice(0xF000);
                            row = end.row;
                        }
                        var args = [row, 0];
                        args.push.apply(args, lines);
                        this.$lines.splice.apply(this.$lines, args);
                        var range = new Range(row, 0, row + lines.length, 0);
                        var delta = {
                            action: "insertLines",
                            range: range,
                            lines: lines
                        };
                        this.eventBus._signal("change", { data: delta });
                        return range.end;
                    }
                }, {
                    key: 'insertNewLine',
                    value: function insertNewLine(position) {
                        position = $clipPosition(this, position);
                        var line = this.$lines[position.row] || "";
                        this.$lines[position.row] = line.substring(0, position.column);
                        this.$lines.splice(position.row + 1, 0, line.substring(position.column, line.length));
                        var end = {
                            row: position.row + 1,
                            column: 0
                        };
                        var delta = {
                            action: "insertText",
                            range: Range.fromPoints(position, end),
                            text: this.getNewLineCharacter()
                        };
                        this.eventBus._signal("change", { data: delta });
                        return end;
                    }
                }, {
                    key: 'insertInLine',
                    value: function insertInLine(position, text) {
                        if (text.length === 0) {
                            return position;
                        }
                        var line = this.$lines[position.row] || "";
                        this.$lines[position.row] = line.substring(0, position.column) + text + line.substring(position.column);
                        var end = {
                            row: position.row,
                            column: position.column + text.length
                        };
                        var delta = { action: "insertText", range: Range.fromPoints(position, end), text: text };
                        this.eventBus._signal("change", { data: delta });
                        return end;
                    }
                }, {
                    key: 'on',
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: 'off',
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: 'remove',
                    value: function remove(range) {
                        if (!(range instanceof Range)) {
                            range = Range.fromPoints(range.start, range.end);
                        }
                        range.start = $clipPosition(this, range.start);
                        range.end = $clipPosition(this, range.end);
                        if (range.isEmpty()) return range.start;
                        var firstRow = range.start.row;
                        var lastRow = range.end.row;
                        if (range.isMultiLine()) {
                            var firstFullRow = range.start.column == 0 ? firstRow : firstRow + 1;
                            var lastFullRow = lastRow - 1;
                            if (range.end.column > 0) this.removeInLine(lastRow, 0, range.end.column);
                            if (lastFullRow >= firstFullRow) this._removeLines(firstFullRow, lastFullRow);
                            if (firstFullRow != firstRow) {
                                this.removeInLine(firstRow, range.start.column, this.getLine(firstRow).length);
                                this.removeNewLine(range.start.row);
                            }
                        } else {
                            this.removeInLine(firstRow, range.start.column, range.end.column);
                        }
                        return range.start;
                    }
                }, {
                    key: 'removeInLine',
                    value: function removeInLine(row, startColumn, endColumn) {
                        if (startColumn === endColumn) return;
                        var range = new Range(row, startColumn, row, endColumn);
                        var line = this.getLine(row);
                        var removed = line.substring(startColumn, endColumn);
                        var newLine = line.substring(0, startColumn) + line.substring(endColumn, line.length);
                        this.$lines.splice(row, 1, newLine);
                        var delta = {
                            action: "removeText",
                            range: range,
                            text: removed
                        };
                        this.eventBus._signal("change", { data: delta });
                        return range.start;
                    }
                }, {
                    key: 'removeLines',
                    value: function removeLines(firstRow, lastRow) {
                        if (firstRow < 0 || lastRow >= this.getLength()) {
                            throw new Error("Document.removeLines");
                        }
                        return this._removeLines(firstRow, lastRow);
                    }
                }, {
                    key: '_removeLines',
                    value: function _removeLines(firstRow, lastRow) {
                        var range = new Range(firstRow, 0, lastRow + 1, 0);
                        var removed = this.$lines.splice(firstRow, lastRow - firstRow + 1);
                        var delta = {
                            action: "removeLines",
                            range: range,
                            nl: this.getNewLineCharacter(),
                            lines: removed
                        };
                        this.eventBus._signal("change", { data: delta });
                        return removed;
                    }
                }, {
                    key: 'removeNewLine',
                    value: function removeNewLine(row) {
                        var firstLine = this.getLine(row);
                        var secondLine = this.getLine(row + 1);
                        var range = new Range(row, firstLine.length, row + 1, 0);
                        var line = firstLine + secondLine;
                        this.$lines.splice(row, 2, line);
                        var delta = {
                            action: "removeText",
                            range: range,
                            text: this.getNewLineCharacter()
                        };
                        this.eventBus._signal("change", { data: delta });
                    }
                }, {
                    key: 'replace',
                    value: function replace(range, text) {
                        if (text.length === 0 && range.isEmpty()) {
                            return range.start;
                        }
                        if (text === this.getTextRange(range)) {
                            return range.end;
                        }
                        this.remove(range);
                        if (text) {
                            var end = this.insert(range.start, text);
                        } else {
                            end = range.start;
                        }
                        return end;
                    }
                }, {
                    key: 'applyDeltas',
                    value: function applyDeltas(deltas) {
                        for (var i = 0; i < deltas.length; i++) {
                            var delta = deltas[i];
                            var range = Range.fromPoints(delta.range.start, delta.range.end);
                            if (delta.action == "insertLines") this.insertLines(range.start.row, delta.lines);else if (delta.action == "insertText") this.insert(range.start, delta.text);else if (delta.action == "removeLines") this._removeLines(range.start.row, range.end.row - 1);else if (delta.action == "removeText") this.remove(range);
                        }
                    }
                }, {
                    key: 'revertDeltas',
                    value: function revertDeltas(deltas) {
                        for (var i = deltas.length - 1; i >= 0; i--) {
                            var delta = deltas[i];
                            var range = Range.fromPoints(delta.range.start, delta.range.end);
                            if (delta.action == "insertLines") this._removeLines(range.start.row, range.end.row - 1);else if (delta.action == "insertText") this.remove(range);else if (delta.action == "removeLines") this._insertLines(range.start.row, delta.lines);else if (delta.action == "removeText") this.insert(range.start, delta.text);
                        }
                    }
                }, {
                    key: 'indexToPosition',
                    value: function indexToPosition(index, startRow) {
                        var lines = this.$lines || this.getAllLines();
                        var newlineLength = this.getNewLineCharacter().length;
                        for (var i = startRow || 0, l = lines.length; i < l; i++) {
                            index -= lines[i].length + newlineLength;
                            if (index < 0) return { row: i, column: index + lines[i].length + newlineLength };
                        }
                        return { row: l - 1, column: lines[l - 1].length };
                    }
                }, {
                    key: 'positionToIndex',
                    value: function positionToIndex(pos, startRow) {
                        var lines = this.$lines || this.getAllLines();
                        var newlineLength = this.getNewLineCharacter().length;
                        var index = 0;
                        var row = Math.min(pos.row, lines.length);
                        for (var i = startRow || 0; i < row; ++i) index += lines[i].length + newlineLength;
                        return index + pos.column;
                    }
                }]);

                return Document;
            })();

            _export('default', Document);
        }
    };
});
System.register("src/BackgroundTokenizer.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, EventEmitterClass, BackgroundTokenizer;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";

            BackgroundTokenizer = (function () {
                function BackgroundTokenizer(tokenizer, session) {
                    _classCallCheck(this, BackgroundTokenizer);

                    this.running = 0;
                    this.lines = [];
                    this.states = [];
                    this.currentLine = 0;
                    this.eventBus = new EventEmitterClass(this);
                    this.tokenizer = tokenizer;
                    var self = this;
                    this.$worker = function () {
                        if (!self.running) {
                            return;
                        }
                        var workerStart = new Date();
                        var currentLine = self.currentLine;
                        var endLine = -1;
                        var doc = self.doc;
                        while (self.lines[currentLine]) currentLine++;
                        var startLine = currentLine;
                        var len = doc.getLength();
                        var processedLines = 0;
                        self.running = 0;
                        while (currentLine < len) {
                            self.tokenizeRow(currentLine);
                            endLine = currentLine;
                            do {
                                currentLine++;
                            } while (self.lines[currentLine]);
                            processedLines++;
                            if (processedLines % 5 === 0 && new Date().getTime() - workerStart.getTime() > 20) {
                                self.running = setTimeout(self.$worker, 20);
                                break;
                            }
                        }
                        self.currentLine = currentLine;
                        if (startLine <= endLine) self.fireUpdateEvent(startLine, endLine);
                    };
                }

                _createClass(BackgroundTokenizer, [{
                    key: "fireUpdateEvent",
                    value: function fireUpdateEvent(firstRow, lastRow) {
                        var data = { first: firstRow, last: lastRow };
                        this.eventBus._signal("update", { data: data });
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "getState",
                    value: function getState(row) {
                        if (this.currentLine == row) {
                            this.tokenizeRow(row);
                        }
                        return this.states[row] || "start";
                    }
                }, {
                    key: "getTokens",
                    value: function getTokens(row) {
                        return this.lines[row] || this.tokenizeRow(row);
                    }
                }, {
                    key: "setDocument",
                    value: function setDocument(doc) {
                        this.doc = doc;
                        this.lines = [];
                        this.states = [];
                        this.stop();
                    }
                }, {
                    key: "setTokenizer",
                    value: function setTokenizer(tokenizer) {
                        this.tokenizer = tokenizer;
                        this.lines = [];
                        this.states = [];
                        this.start(0);
                    }
                }, {
                    key: "start",
                    value: function start(startRow) {
                        this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
                        this.lines.splice(this.currentLine, this.lines.length);
                        this.states.splice(this.currentLine, this.states.length);
                        this.stop();
                        this.running = setTimeout(this.$worker, 700);
                    }
                }, {
                    key: "stop",
                    value: function stop() {
                        if (this.running) {
                            clearTimeout(this.running);
                        }
                        this.running = 0;
                    }
                }, {
                    key: "scheduleStart",
                    value: function scheduleStart() {
                        if (!this.running) {
                            this.running = setTimeout(this.$worker, 700);
                        }
                    }
                }, {
                    key: "updateOnChange",
                    value: function updateOnChange(delta) {
                        var range = delta.range;
                        var startRow = range.start.row;
                        var len = range.end.row - startRow;
                        if (len === 0) {
                            this.lines[startRow] = null;
                        } else if (delta.action === "removeText" || delta.action === "removeLines") {
                            this.lines.splice(startRow, len + 1, null);
                            this.states.splice(startRow, len + 1, null);
                        } else {
                            var args = Array(len + 1);
                            args.unshift(startRow, 1);
                            this.lines.splice.apply(this.lines, args);
                            this.states.splice.apply(this.states, args);
                        }
                        this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
                        this.stop();
                    }
                }, {
                    key: "tokenizeRow",
                    value: function tokenizeRow(row) {
                        var line = this.doc.getLine(row);
                        var state = this.states[row - 1];
                        var data = this.tokenizer.getLineTokens(line, state);
                        if (this.states[row] + "" !== data.state + "") {
                            this.states[row] = data.state;
                            this.lines[row + 1] = null;
                            if (this.currentLine > row + 1) this.currentLine = row + 1;
                        } else if (this.currentLine == row) {
                            this.currentLine = row + 1;
                        }
                        return this.lines[row] = data.tokens;
                    }
                }]);

                return BackgroundTokenizer;
            })();

            _export("default", BackgroundTokenizer);
        }
    };
});
System.register("src/SearchHighlight.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/lang.js", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, getMatchOffsets, Range, MAX_RANGES, SearchHighlight;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibLangJs) {
            getMatchOffsets = _srcLibLangJs.getMatchOffsets;
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";
            MAX_RANGES = 500;

            SearchHighlight = (function () {
                function SearchHighlight(regExp, clazz, type) {
                    _classCallCheck(this, SearchHighlight);

                    this.setRegexp(regExp);
                    this.clazz = clazz;
                    this.type = type || "text";
                }

                _createClass(SearchHighlight, [{
                    key: "setRegexp",
                    value: function setRegexp(regExp) {
                        if (this.regExp + "" == regExp + "") {
                            return;
                        }
                        this.regExp = regExp;
                        this.cache = [];
                    }
                }, {
                    key: "update",
                    value: function update(html, markerLayer, session, config) {
                        if (!this.regExp) return;
                        var start = config.firstRow,
                            end = config.lastRow;
                        for (var i = start; i <= end; i++) {
                            var ranges = this.cache[i];
                            if (ranges == null) {
                                var matches = getMatchOffsets(session.getLine(i), this.regExp);
                                if (matches.length > MAX_RANGES) {
                                    matches = matches.slice(0, MAX_RANGES);
                                }
                                ranges = matches.map(function (match) {
                                    return new Range(i, match.offset, i, match.offset + match.length);
                                });
                                this.cache[i] = ranges.length ? ranges : [];
                            }
                            for (var j = ranges.length; j--;) {
                                markerLayer.drawSingleLineMarker(html, session.documentToScreenRange(ranges[j]), this.clazz, config);
                            }
                        }
                    }
                }]);

                return SearchHighlight;
            })();

            _export("default", SearchHighlight);
        }
    };
});
System.register('src/lib/asserts.js', ['npm:babel-runtime@5.8.34/helpers/class-call-check'], function (_export) {
    var _classCallCheck, ENABLE_ASSERTS, AssertionError;

    function doAssertFailure(defaultMessage, defaultArgs, givenMessage, givenArgs) {
        var message = 'Assertion failed';
        if (givenMessage) {
            message += ': ' + givenMessage;
            var args = givenArgs;
        } else if (defaultMessage) {
            message += ': ' + defaultMessage;
            args = defaultArgs;
        }
        throw new AssertionError('' + message, args || []);
    }

    function assert(condition, message, args) {
        if (ENABLE_ASSERTS && !condition) {
            doAssertFailure('', null, message, Array.prototype.slice.call(arguments, 2));
        }
        return condition;
    }

    return {
        setters: [function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }],
        execute: function () {
            "use strict";

            _export('assert', assert);

            ENABLE_ASSERTS = true;

            _export('ENABLE_ASSERTS', ENABLE_ASSERTS);

            AssertionError = function AssertionError(message, args) {
                _classCallCheck(this, AssertionError);

                this.name = 'AssertionError';
                this.message = message;
            };

            _export('AssertionError', AssertionError);

            ;
        }
    };
});
System.register("src/BracketMatch.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/TokenIterator.js", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, TokenIterator, Range, $brackets, BracketMatch;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";
            $brackets = {
                ")": "(",
                "(": ")",
                "]": "[",
                "[": "]",
                "{": "}",
                "}": "{"
            };

            BracketMatch = (function () {
                function BracketMatch(editSession) {
                    _classCallCheck(this, BracketMatch);

                    this.editSession = editSession;
                }

                _createClass(BracketMatch, [{
                    key: "findMatchingBracket",
                    value: function findMatchingBracket(position, chr) {
                        if (position.column === 0) return null;
                        var charBeforeCursor = chr || this.editSession.getLine(position.row).charAt(position.column - 1);
                        if (charBeforeCursor === "") return null;
                        var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
                        if (!match) return null;
                        if (match[1]) return this.findClosingBracket(match[1], position);else return this.findOpeningBracket(match[2], position);
                    }
                }, {
                    key: "getBracketRange",
                    value: function getBracketRange(pos) {
                        var line = this.editSession.getLine(pos.row);
                        var before = true;
                        var range;
                        var chr = line.charAt(pos.column - 1);
                        var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                        if (!match) {
                            chr = line.charAt(pos.column);
                            pos = { row: pos.row, column: pos.column + 1 };
                            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                            before = false;
                        }
                        if (!match) return null;
                        if (match[1]) {
                            var closingPos = this.findClosingBracket(match[1], pos);
                            if (!closingPos) return null;
                            range = Range.fromPoints(pos, closingPos);
                            if (!before) {
                                range.end.column++;
                                range.start.column--;
                            }
                            range['cursor'] = range.end;
                        } else {
                            var openingPos = this.findOpeningBracket(match[2], pos);
                            if (!openingPos) return null;
                            range = Range.fromPoints(openingPos, pos);
                            if (!before) {
                                range.start.column++;
                                range.end.column--;
                            }
                            range['cursor'] = range.start;
                        }
                        return range;
                    }
                }, {
                    key: "findOpeningBracket",
                    value: function findOpeningBracket(bracket, position, typeRe) {
                        var openBracket = $brackets[bracket];
                        var depth = 1;
                        var iterator = new TokenIterator(this.editSession, position.row, position.column);
                        var token = iterator.getCurrentToken();
                        if (!token) token = iterator.stepForward();
                        if (!token) return;
                        if (!typeRe) {
                            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
                        }
                        var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
                        var value = token.value;
                        while (true) {
                            while (valueIndex >= 0) {
                                var chr = value.charAt(valueIndex);
                                if (chr == openBracket) {
                                    depth -= 1;
                                    if (depth === 0) {
                                        return {
                                            row: iterator.getCurrentTokenRow(),
                                            column: valueIndex + iterator.getCurrentTokenColumn()
                                        };
                                    }
                                } else if (chr === bracket) {
                                    depth += 1;
                                }
                                valueIndex -= 1;
                            }
                            do {
                                token = iterator.stepBackward();
                            } while (token && !typeRe.test(token.type));
                            if (token === null) break;
                            value = token.value;
                            valueIndex = value.length - 1;
                        }
                        return null;
                    }
                }, {
                    key: "findClosingBracket",
                    value: function findClosingBracket(bracket, position, typeRe) {
                        var closingBracket = $brackets[bracket];
                        var depth = 1;
                        var iterator = new TokenIterator(this.editSession, position.row, position.column);
                        var token = iterator.getCurrentToken();
                        if (!token) token = iterator.stepForward();
                        if (!token) return;
                        if (!typeRe) {
                            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:end|start|begin)\b/, "") + ")+");
                        }
                        var valueIndex = position.column - iterator.getCurrentTokenColumn();
                        while (true) {
                            var value = token.value;
                            var valueLength = value.length;
                            while (valueIndex < valueLength) {
                                var chr = value.charAt(valueIndex);
                                if (chr == closingBracket) {
                                    depth -= 1;
                                    if (depth === 0) {
                                        return {
                                            row: iterator.getCurrentTokenRow(),
                                            column: valueIndex + iterator.getCurrentTokenColumn()
                                        };
                                    }
                                } else if (chr === bracket) {
                                    depth += 1;
                                }
                                valueIndex += 1;
                            }
                            do {
                                token = iterator.stepForward();
                            } while (token && !typeRe.test(token.type));
                            if (token === null) break;
                            valueIndex = 0;
                        }
                        return null;
                    }
                }]);

                return BracketMatch;
            })();

            _export("default", BracketMatch);
        }
    };
});
System.register("src/EditSession.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "npm:babel-runtime@5.8.34/core-js/object/keys", "src/lib/lang.js", "src/config.js", "src/lib/EventEmitterClass.js", "src/FoldLine.js", "src/Fold.js", "src/Selection.js", "src/Range.js", "src/Document.js", "src/BackgroundTokenizer.js", "src/SearchHighlight.js", "src/lib/asserts.js", "src/BracketMatch.js", "src/TokenIterator.js", "src/mode/TextMode.js"], function (_export) {
    var _createClass, _classCallCheck, _Promise, _Object$keys, delayedCall, stringRepeat, defineOptions, resetOptions, EventEmitterClass, FoldLine, Fold, Selection, Range, Document, BackgroundTokenizer, SearchHighlight, assert, BracketMatch, TokenIterator, TextMode, CHAR, CHAR_EXT, PLACEHOLDER_START, PLACEHOLDER_BODY, PUNCTUATION, SPACE, TAB, TAB_SPACE, EditSession;

    function isFullWidth(c) {
        if (c < 0x1100) return false;
        return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys["default"];
        }, function (_srcLibLangJs) {
            delayedCall = _srcLibLangJs.delayedCall;
            stringRepeat = _srcLibLangJs.stringRepeat;
        }, function (_srcConfigJs) {
            defineOptions = _srcConfigJs.defineOptions;
            resetOptions = _srcConfigJs.resetOptions;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }, function (_srcFoldLineJs) {
            FoldLine = _srcFoldLineJs["default"];
        }, function (_srcFoldJs) {
            Fold = _srcFoldJs["default"];
        }, function (_srcSelectionJs) {
            Selection = _srcSelectionJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcDocumentJs) {
            Document = _srcDocumentJs["default"];
        }, function (_srcBackgroundTokenizerJs) {
            BackgroundTokenizer = _srcBackgroundTokenizerJs["default"];
        }, function (_srcSearchHighlightJs) {
            SearchHighlight = _srcSearchHighlightJs["default"];
        }, function (_srcLibAssertsJs) {
            assert = _srcLibAssertsJs.assert;
        }, function (_srcBracketMatchJs) {
            BracketMatch = _srcBracketMatchJs["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }, function (_srcModeTextModeJs) {
            TextMode = _srcModeTextModeJs["default"];
        }],
        execute: function () {
            "use strict";

            CHAR = 1;
            CHAR_EXT = 2;
            PLACEHOLDER_START = 3;
            PLACEHOLDER_BODY = 4;
            PUNCTUATION = 9;
            SPACE = 10;
            TAB = 11;
            TAB_SPACE = 12;

            EditSession = (function () {
                function EditSession(doc) {
                    _classCallCheck(this, EditSession);

                    this.$breakpoints = [];
                    this.$decorations = [];
                    this.$frontMarkers = {};
                    this.$backMarkers = {};
                    this.$markerId = 1;
                    this.$undoSelect = true;
                    this.$defaultUndoManager = { undo: function undo() {}, redo: function redo() {}, reset: function reset() {} };
                    this.$overwrite = false;
                    this.$modes = {};
                    this.$mode = null;
                    this.$modeId = null;
                    this.$scrollTop = 0;
                    this.$scrollLeft = 0;
                    this.$wrapLimit = 80;
                    this.$useWrapMode = false;
                    this.$wrapLimitRange = {
                        min: null,
                        max: null
                    };
                    this.$onChange = this.onChange.bind(this);
                    this.lineWidgets = null;
                    this.$selectionMarker = null;
                    this.$bracketMatcher = new BracketMatch(this);
                    this.$foldStyles = {
                        "manual": 1,
                        "markbegin": 1,
                        "markbeginend": 1
                    };
                    this.$foldStyle = "markbegin";
                    if (!(doc instanceof Document)) {
                        throw new TypeError('doc must be an Document');
                    }
                    this.eventBus = new EventEmitterClass(this);
                    this.$foldData = [];
                    this.$foldData.toString = function () {
                        return this.join("\n");
                    };
                    this.eventBus.on("changeFold", this.onChangeFold.bind(this));
                    this.setDocument(doc);
                    this.selection = new Selection(this);
                    resetOptions(this);
                    this.setLanguageMode(new TextMode('', []));
                }

                _createClass(EditSession, [{
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "_emit",
                    value: function _emit(eventName, event) {
                        this.eventBus._emit(eventName, event);
                    }
                }, {
                    key: "_signal",
                    value: function _signal(eventName, event) {
                        this.eventBus._signal(eventName, event);
                    }
                }, {
                    key: "setDocument",
                    value: function setDocument(doc) {
                        if (!(doc instanceof Document)) {
                            throw new Error("doc must be a Document");
                        }
                        if (this.doc) {
                            this.doc.off("change", this.$onChange);
                        }
                        this.doc = doc;
                        doc.on("change", this.$onChange);
                        if (this.bgTokenizer) {
                            this.bgTokenizer.setDocument(this.getDocument());
                        }
                        this.resetCaches();
                    }
                }, {
                    key: "getDocument",
                    value: function getDocument() {
                        return this.doc;
                    }
                }, {
                    key: "$resetRowCache",
                    value: function $resetRowCache(docRow) {
                        if (!docRow) {
                            this.$docRowCache = [];
                            this.$screenRowCache = [];
                            return;
                        }
                        var l = this.$docRowCache.length;
                        var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
                        if (l > i) {
                            this.$docRowCache.splice(i, l);
                            this.$screenRowCache.splice(i, l);
                        }
                    }
                }, {
                    key: "$getRowCacheIndex",
                    value: function $getRowCacheIndex(cacheArray, val) {
                        var low = 0;
                        var hi = cacheArray.length - 1;
                        while (low <= hi) {
                            var mid = low + hi >> 1;
                            var c = cacheArray[mid];
                            if (val > c) {
                                low = mid + 1;
                            } else if (val < c) {
                                hi = mid - 1;
                            } else {
                                return mid;
                            }
                        }
                        return low - 1;
                    }
                }, {
                    key: "resetCaches",
                    value: function resetCaches() {
                        this.$modified = true;
                        this.$wrapData = [];
                        this.$rowLengthCache = [];
                        this.$resetRowCache(0);
                        if (this.bgTokenizer) {
                            this.bgTokenizer.start(0);
                        }
                    }
                }, {
                    key: "onChangeFold",
                    value: function onChangeFold(event) {
                        var fold = event.data;
                        this.$resetRowCache(fold.start.row);
                    }
                }, {
                    key: "onChange",
                    value: function onChange(event, doc) {
                        var delta = event.data;
                        this.$modified = true;
                        this.$resetRowCache(delta.range.start.row);
                        var removedFolds = this.$updateInternalDataOnChange(event);
                        if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
                            this.$deltasDoc.push(delta);
                            if (removedFolds && removedFolds.length != 0) {
                                this.$deltasFold.push({
                                    action: "removeFolds",
                                    folds: removedFolds
                                });
                            }
                            this.$informUndoManager.schedule();
                        }
                        if (this.bgTokenizer) {
                            this.bgTokenizer.updateOnChange(delta);
                        }
                        this.eventBus._signal("change", event);
                    }
                }, {
                    key: "setValue",
                    value: function setValue(text) {
                        this.doc.setValue(text);
                        this.selection.moveTo(0, 0);
                        this.$resetRowCache(0);
                        this.$deltas = [];
                        this.$deltasDoc = [];
                        this.$deltasFold = [];
                        this.setUndoManager(this.$undoManager);
                        this.getUndoManager().reset();
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.getValue();
                    }
                }, {
                    key: "getValue",
                    value: function getValue() {
                        return this.doc.getValue();
                    }
                }, {
                    key: "getSelection",
                    value: function getSelection() {
                        return this.selection;
                    }
                }, {
                    key: "setSelection",
                    value: function setSelection(selection) {
                        this.selection = selection;
                    }
                }, {
                    key: "getState",
                    value: function getState(row) {
                        if (this.bgTokenizer) {
                            return this.bgTokenizer.getState(row);
                        } else {
                            return void 0;
                        }
                    }
                }, {
                    key: "getTokens",
                    value: function getTokens(row) {
                        if (this.bgTokenizer) {
                            return this.bgTokenizer.getTokens(row);
                        } else {
                            return void 0;
                        }
                    }
                }, {
                    key: "getTokenAt",
                    value: function getTokenAt(row, column) {
                        if (this.bgTokenizer) {
                            var tokens = this.bgTokenizer.getTokens(row);
                            var token;
                            var c = 0;
                            if (column == null) {
                                i = tokens.length - 1;
                                c = this.getLine(row).length;
                            } else {
                                for (var i = 0; i < tokens.length; i++) {
                                    c += tokens[i].value.length;
                                    if (c >= column) break;
                                }
                            }
                            token = tokens[i];
                            if (!token) return null;
                            token.index = i;
                            token.start = c - token.value.length;
                            return token;
                        } else {
                            return void 0;
                        }
                    }
                }, {
                    key: "setUndoManager",
                    value: function setUndoManager(undoManager) {
                        this.$undoManager = undoManager;
                        this.$deltas = [];
                        this.$deltasDoc = [];
                        this.$deltasFold = [];
                        if (this.$informUndoManager) this.$informUndoManager.cancel();
                        if (undoManager) {
                            var self = this;
                            this.$syncInformUndoManager = function () {
                                self.$informUndoManager.cancel();
                                if (self.$deltasFold.length) {
                                    self.$deltas.push({
                                        group: "fold",
                                        deltas: self.$deltasFold
                                    });
                                    self.$deltasFold = [];
                                }
                                if (self.$deltasDoc.length) {
                                    self.$deltas.push({
                                        group: "doc",
                                        deltas: self.$deltasDoc
                                    });
                                    self.$deltasDoc = [];
                                }
                                if (self.$deltas.length > 0) {
                                    undoManager.execute({
                                        action: "aceupdate",
                                        args: [self.$deltas, self],
                                        merge: self.mergeUndoDeltas
                                    });
                                }
                                self.mergeUndoDeltas = false;
                                self.$deltas = [];
                            };
                            this.$informUndoManager = delayedCall(this.$syncInformUndoManager);
                        }
                    }
                }, {
                    key: "markUndoGroup",
                    value: function markUndoGroup() {
                        if (this.$syncInformUndoManager) {
                            this.$syncInformUndoManager();
                        }
                    }
                }, {
                    key: "getUndoManager",
                    value: function getUndoManager() {
                        return this.$undoManager || this.$defaultUndoManager;
                    }
                }, {
                    key: "getTabString",
                    value: function getTabString() {
                        if (this.getUseSoftTabs()) {
                            return stringRepeat(" ", this.getTabSize());
                        } else {
                            return "\t";
                        }
                    }
                }, {
                    key: "setUseSoftTabs",
                    value: function setUseSoftTabs(useSoftTabs) {
                        this.setOption("useSoftTabs", useSoftTabs);
                        return this;
                    }
                }, {
                    key: "getUseSoftTabs",
                    value: function getUseSoftTabs() {
                        return this.$useSoftTabs && !this.$mode.$indentWithTabs;
                    }
                }, {
                    key: "setTabSize",
                    value: function setTabSize(tabSize) {
                        this.setOption("tabSize", tabSize);
                    }
                }, {
                    key: "getTabSize",
                    value: function getTabSize() {
                        return this.$tabSize;
                    }
                }, {
                    key: "isTabStop",
                    value: function isTabStop(position) {
                        return this.$useSoftTabs && position.column % this.$tabSize === 0;
                    }
                }, {
                    key: "setOverwrite",
                    value: function setOverwrite(overwrite) {
                        this.setOption("overwrite", overwrite);
                    }
                }, {
                    key: "getOverwrite",
                    value: function getOverwrite() {
                        return this.$overwrite;
                    }
                }, {
                    key: "toggleOverwrite",
                    value: function toggleOverwrite() {
                        this.setOverwrite(!this.$overwrite);
                    }
                }, {
                    key: "addGutterDecoration",
                    value: function addGutterDecoration(row, className) {
                        if (!this.$decorations[row]) {
                            this.$decorations[row] = "";
                        }
                        this.$decorations[row] += " " + className;
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "removeGutterDecoration",
                    value: function removeGutterDecoration(row, className) {
                        this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "getBreakpoints",
                    value: function getBreakpoints() {
                        return this.$breakpoints;
                    }
                }, {
                    key: "setBreakpoints",
                    value: function setBreakpoints(rows) {
                        this.$breakpoints = [];
                        for (var i = 0; i < rows.length; i++) {
                            this.$breakpoints[rows[i]] = "ace_breakpoint";
                        }
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "clearBreakpoints",
                    value: function clearBreakpoints() {
                        this.$breakpoints = [];
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "setBreakpoint",
                    value: function setBreakpoint(row, className) {
                        if (className === undefined) className = "ace_breakpoint";
                        if (className) this.$breakpoints[row] = className;else delete this.$breakpoints[row];
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "clearBreakpoint",
                    value: function clearBreakpoint(row) {
                        delete this.$breakpoints[row];
                        this.eventBus._signal("changeBreakpoint", {});
                    }
                }, {
                    key: "addMarker",
                    value: function addMarker(range, clazz, type, inFront) {
                        var id = this.$markerId++;
                        var marker = {
                            range: range,
                            type: type || "line",
                            renderer: typeof type === "function" ? type : null,
                            clazz: clazz,
                            inFront: !!inFront,
                            id: id
                        };
                        if (inFront) {
                            this.$frontMarkers[id] = marker;
                            this.eventBus._signal("changeFrontMarker");
                        } else {
                            this.$backMarkers[id] = marker;
                            this.eventBus._signal("changeBackMarker");
                        }
                        return id;
                    }
                }, {
                    key: "addDynamicMarker",
                    value: function addDynamicMarker(marker, inFront) {
                        if (!marker.update) {
                            return;
                        }
                        var id = this.$markerId++;
                        marker.id = id;
                        marker.inFront = !!inFront;
                        if (inFront) {
                            this.$frontMarkers[id] = marker;
                            this.eventBus._signal("changeFrontMarker");
                        } else {
                            this.$backMarkers[id] = marker;
                            this.eventBus._signal("changeBackMarker");
                        }
                        return marker;
                    }
                }, {
                    key: "removeMarker",
                    value: function removeMarker(markerId) {
                        var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
                        if (!marker) return;
                        var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
                        if (marker) {
                            delete markers[markerId];
                            this.eventBus._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
                        }
                    }
                }, {
                    key: "getMarkers",
                    value: function getMarkers(inFront) {
                        return inFront ? this.$frontMarkers : this.$backMarkers;
                    }
                }, {
                    key: "highlight",
                    value: function highlight(re) {
                        if (!this.$searchHighlight) {
                            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                            this.addDynamicMarker(highlight);
                            this.$searchHighlight = highlight;
                        }
                        this.$searchHighlight.setRegexp(re);
                    }
                }, {
                    key: "highlightLines",
                    value: function highlightLines(startRow, endRow, clazz, inFront) {
                        if (clazz === undefined) clazz = "ace_step";

                        var range = new Range(startRow, 0, endRow, Infinity);
                        range.markerId = this.addMarker(range, clazz, "fullLine", inFront);
                        return range;
                    }
                }, {
                    key: "setAnnotations",
                    value: function setAnnotations(annotations) {
                        this.$annotations = annotations;
                        this.eventBus._signal("changeAnnotation", {});
                    }
                }, {
                    key: "getAnnotations",
                    value: function getAnnotations() {
                        return this.$annotations || [];
                    }
                }, {
                    key: "clearAnnotations",
                    value: function clearAnnotations() {
                        this.setAnnotations([]);
                    }
                }, {
                    key: "$detectNewLine",
                    value: function $detectNewLine(text) {
                        var match = text.match(/^.*?(\r?\n)/m);
                        if (match) {
                            this.$autoNewLine = match[1];
                        } else {
                            this.$autoNewLine = "\n";
                        }
                    }
                }, {
                    key: "getWordRange",
                    value: function getWordRange(row, column) {
                        var line = this.getLine(row);
                        var inToken = false;
                        if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);
                        if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);
                        if (inToken) var re = this.tokenRe;else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;else var re = this.nonTokenRe;
                        var start = column;
                        if (start > 0) {
                            do {
                                start--;
                            } while (start >= 0 && line.charAt(start).match(re));
                            start++;
                        }
                        var end = column;
                        while (end < line.length && line.charAt(end).match(re)) {
                            end++;
                        }
                        return new Range(row, start, row, end);
                    }
                }, {
                    key: "getAWordRange",
                    value: function getAWordRange(row, column) {
                        var wordRange = this.getWordRange(row, column);
                        var line = this.getLine(wordRange.end.row);
                        while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
                            wordRange.end.column += 1;
                        }
                        return wordRange;
                    }
                }, {
                    key: "setNewLineMode",
                    value: function setNewLineMode(newLineMode) {
                        this.doc.setNewLineMode(newLineMode);
                    }
                }, {
                    key: "getNewLineMode",
                    value: function getNewLineMode() {
                        return this.doc.getNewLineMode();
                    }
                }, {
                    key: "setUseWorker",
                    value: function setUseWorker(useWorker) {
                        this.setOption("useWorker", useWorker);
                    }
                }, {
                    key: "getUseWorker",
                    value: function getUseWorker() {
                        return this.$useWorker;
                    }
                }, {
                    key: "onReloadTokenizer",
                    value: function onReloadTokenizer(e) {
                        var rows = e.data;
                        this.bgTokenizer.start(rows.first);
                        this.eventBus._signal("tokenizerUpdate", e);
                    }
                }, {
                    key: "setLanguageMode",
                    value: function setLanguageMode(mode) {
                        return this.$onChangeMode(mode, false);
                    }
                }, {
                    key: "setMode",
                    value: function setMode(modeName) {
                        var _this = this;

                        this.importMode(modeName).then(function (mode) {
                            return _this.setLanguageMode(mode);
                        })["catch"](function (reason) {
                            throw new Error("setMode failed. Reason: " + reason);
                        });
                    }
                }, {
                    key: "importMode",
                    value: function importMode(modeName, options) {
                        if (typeof modeName !== 'string') {
                            throw new TypeError("modeName must be a string");
                        }
                        if (!this.$mode) {
                            this.$onChangeMode(new TextMode('', []), true);
                        }
                        var self = this;
                        return new _Promise(function (success, fail) {
                            if (self.$modes[modeName] && !options) {
                                success(self.$modes[modeName]);
                            } else {
                                if (self.$modes[modeName] && !options) {
                                    success(self.$modes[modeName]);
                                }
                                System["import"](modeName).then(function (m) {
                                    if (m && m["default"]) {
                                        var newMode = new m["default"](options);
                                        success(newMode);
                                    } else {
                                        fail(new Error(modeName + " does not define a default export (a LanguageMode class)."));
                                    }
                                })["catch"](function (reason) {
                                    fail(reason);
                                });
                            }
                        });
                    }
                }, {
                    key: "$onChangeMode",
                    value: function $onChangeMode(mode, isPlaceholder) {
                        var _this2 = this;

                        if (!isPlaceholder) {
                            this.$modeId = mode.$id;
                        }
                        if (this.$mode === mode) {
                            return;
                        }
                        this.$mode = mode;
                        this.$stopWorker();
                        if (this.$useWorker) {
                            this.$startWorker();
                        }
                        var tokenizer = mode.getTokenizer();
                        if (tokenizer['addEventListener'] !== undefined) {
                            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                            tokenizer['addEventListener']("update", onReloadTokenizer);
                        }
                        if (!this.bgTokenizer) {
                            this.bgTokenizer = new BackgroundTokenizer(tokenizer, this);
                            this.bgTokenizer.on("update", function (event, bg) {
                                _this2.eventBus._signal("tokenizerUpdate", event);
                            });
                        } else {
                            this.bgTokenizer.setTokenizer(tokenizer);
                        }
                        this.bgTokenizer.setDocument(this.getDocument());
                        this.tokenRe = mode.tokenRe;
                        this.nonTokenRe = mode.nonTokenRe;
                        if (!isPlaceholder) {
                            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                            this.$setFolding(mode.foldingRules);
                            this.bgTokenizer.start(0);
                            this.eventBus._emit("changeMode");
                        }
                    }
                }, {
                    key: "$stopWorker",
                    value: function $stopWorker() {
                        if (this.$worker) {
                            this.$worker.terminate();
                        }
                        this.$worker = null;
                    }
                }, {
                    key: "$startWorker",
                    value: function $startWorker() {
                        var _this3 = this;

                        try {
                            this.$mode.createWorker(this).then(function (worker) {
                                _this3.$worker = worker;
                            })["catch"](function (e) {
                                console.warn("" + e);
                            });
                        } catch (e) {
                            this.$worker = null;
                        }
                    }
                }, {
                    key: "getMode",
                    value: function getMode() {
                        return this.$mode;
                    }
                }, {
                    key: "setScrollTop",
                    value: function setScrollTop(scrollTop) {
                        if (this.$scrollTop === scrollTop || isNaN(scrollTop)) {
                            return;
                        }
                        this.$scrollTop = scrollTop;
                        this.eventBus._signal("changeScrollTop", scrollTop);
                    }
                }, {
                    key: "getScrollTop",
                    value: function getScrollTop() {
                        return this.$scrollTop;
                    }
                }, {
                    key: "setScrollLeft",
                    value: function setScrollLeft(scrollLeft) {
                        if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;
                        this.$scrollLeft = scrollLeft;
                        this.eventBus._signal("changeScrollLeft", scrollLeft);
                    }
                }, {
                    key: "getScrollLeft",
                    value: function getScrollLeft() {
                        return this.$scrollLeft;
                    }
                }, {
                    key: "getScreenWidth",
                    value: function getScreenWidth() {
                        this.$computeWidth();
                        if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
                        return this.screenWidth;
                    }
                }, {
                    key: "getLineWidgetMaxWidth",
                    value: function getLineWidgetMaxWidth() {
                        if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
                        var width = 0;
                        this.lineWidgets.forEach(function (w) {
                            if (w && w.screenWidth > width) width = w.screenWidth;
                        });
                        return this.lineWidgetWidth = width;
                    }
                }, {
                    key: "$computeWidth",
                    value: function $computeWidth(force) {
                        if (this.$modified || force) {
                            this.$modified = false;
                            if (this.$useWrapMode) {
                                return this.screenWidth = this.$wrapLimit;
                            }
                            var lines = this.doc.getAllLines();
                            var cache = this.$rowLengthCache;
                            var longestScreenLine = 0;
                            var foldIndex = 0;
                            var foldLine = this.$foldData[foldIndex];
                            var foldStart = foldLine ? foldLine.start.row : Infinity;
                            var len = lines.length;
                            for (var i = 0; i < len; i++) {
                                if (i > foldStart) {
                                    i = foldLine.end.row + 1;
                                    if (i >= len) break;
                                    foldLine = this.$foldData[foldIndex++];
                                    foldStart = foldLine ? foldLine.start.row : Infinity;
                                }
                                if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];
                                if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                            }
                            this.screenWidth = longestScreenLine;
                        }
                    }
                }, {
                    key: "getLine",
                    value: function getLine(row) {
                        return this.doc.getLine(row);
                    }
                }, {
                    key: "getLines",
                    value: function getLines(firstRow, lastRow) {
                        return this.doc.getLines(firstRow, lastRow);
                    }
                }, {
                    key: "getLength",
                    value: function getLength() {
                        return this.doc.getLength();
                    }
                }, {
                    key: "getTextRange",
                    value: function getTextRange(range) {
                        return this.doc.getTextRange(range || this.selection.getRange());
                    }
                }, {
                    key: "insert",
                    value: function insert(position, text) {
                        return this.doc.insert(position, text);
                    }
                }, {
                    key: "remove",
                    value: function remove(range) {
                        return this.doc.remove(range);
                    }
                }, {
                    key: "undoChanges",
                    value: function undoChanges(deltas, dontSelect) {
                        var _this4 = this;

                        if (!deltas.length) return;
                        this.$fromUndo = true;
                        var lastUndoRange = null;
                        for (var i = deltas.length - 1; i != -1; i--) {
                            var delta = deltas[i];
                            if (delta.group === "doc") {
                                this.doc.revertDeltas(delta.deltas);
                                lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
                            } else {
                                delta.deltas.forEach(function (foldDelta) {
                                    _this4.addFolds(foldDelta.folds);
                                }, this);
                            }
                        }
                        this.$fromUndo = false;
                        lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                        return lastUndoRange;
                    }
                }, {
                    key: "redoChanges",
                    value: function redoChanges(deltas, dontSelect) {
                        if (!deltas.length) return;
                        this.$fromUndo = true;
                        var lastUndoRange = null;
                        for (var i = 0; i < deltas.length; i++) {
                            var delta = deltas[i];
                            if (delta.group == "doc") {
                                this.doc.applyDeltas(delta.deltas);
                                lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
                            }
                        }
                        this.$fromUndo = false;
                        lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
                        return lastUndoRange;
                    }
                }, {
                    key: "setUndoSelect",
                    value: function setUndoSelect(enable) {
                        this.$undoSelect = enable;
                    }
                }, {
                    key: "$getUndoSelection",
                    value: function $getUndoSelection(deltas, isUndo, lastUndoRange) {
                        function isInsert(delta) {
                            var insert = delta.action === "insertText" || delta.action === "insertLines";
                            return isUndo ? !insert : insert;
                        }
                        var delta = deltas[0];
                        var range;
                        var point;
                        var lastDeltaIsInsert = false;
                        if (isInsert(delta)) {
                            range = Range.fromPoints(delta.range.start, delta.range.end);
                            lastDeltaIsInsert = true;
                        } else {
                            range = Range.fromPoints(delta.range.start, delta.range.start);
                            lastDeltaIsInsert = false;
                        }
                        for (var i = 1; i < deltas.length; i++) {
                            delta = deltas[i];
                            if (isInsert(delta)) {
                                point = delta.range.start;
                                if (range.compare(point.row, point.column) === -1) {
                                    range.setStart(delta.range.start.row, delta.range.start.column);
                                }
                                point = delta.range.end;
                                if (range.compare(point.row, point.column) === 1) {
                                    range.setEnd(delta.range.end.row, delta.range.end.column);
                                }
                                lastDeltaIsInsert = true;
                            } else {
                                point = delta.range.start;
                                if (range.compare(point.row, point.column) === -1) {
                                    range = Range.fromPoints(delta.range.start, delta.range.start);
                                }
                                lastDeltaIsInsert = false;
                            }
                        }
                        if (lastUndoRange != null) {
                            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
                                lastUndoRange.start.column += range.end.column - range.start.column;
                                lastUndoRange.end.column += range.end.column - range.start.column;
                            }
                            var cmp = lastUndoRange.compareRange(range);
                            if (cmp === 1) {
                                range.setStart(lastUndoRange.start.row, lastUndoRange.start.column);
                            } else if (cmp === -1) {
                                range.setEnd(lastUndoRange.end.row, lastUndoRange.start.column);
                            }
                        }
                        return range;
                    }
                }, {
                    key: "replace",
                    value: function replace(range, text) {
                        return this.doc.replace(range, text);
                    }
                }, {
                    key: "moveText",
                    value: function moveText(fromRange, toPosition, copy) {
                        var text = this.getTextRange(fromRange);
                        var folds = this.getFoldsInRange(fromRange);
                        var rowDiff;
                        var colDiff;
                        var toRange = Range.fromPoints(toPosition, toPosition);
                        if (!copy) {
                            this.remove(fromRange);
                            rowDiff = fromRange.start.row - fromRange.end.row;
                            colDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                            if (colDiff) {
                                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) {
                                    toRange.start.column += colDiff;
                                }
                                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) {
                                    toRange.end.column += colDiff;
                                }
                            }
                            if (rowDiff && toRange.start.row >= fromRange.end.row) {
                                toRange.start.row += rowDiff;
                                toRange.end.row += rowDiff;
                            }
                        }
                        toRange.end = this.insert(toRange.start, text);
                        if (folds.length) {
                            var oldStart = fromRange.start;
                            var newStart = toRange.start;
                            rowDiff = newStart.row - oldStart.row;
                            colDiff = newStart.column - oldStart.column;
                            this.addFolds(folds.map(function (x) {
                                x = x.clone();
                                if (x.start.row == oldStart.row) {
                                    x.start.column += colDiff;
                                }
                                if (x.end.row == oldStart.row) {
                                    x.end.column += colDiff;
                                }
                                x.start.row += rowDiff;
                                x.end.row += rowDiff;
                                return x;
                            }));
                        }
                        return toRange;
                    }
                }, {
                    key: "indentRows",
                    value: function indentRows(startRow, endRow, indentString) {
                        indentString = indentString.replace(/\t/g, this.getTabString());
                        for (var row = startRow; row <= endRow; row++) this.insert({ row: row, column: 0 }, indentString);
                    }
                }, {
                    key: "outdentRows",
                    value: function outdentRows(range) {
                        var rowRange = range.collapseRows();
                        var deleteRange = new Range(0, 0, 0, 0);
                        var size = this.getTabSize();
                        for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
                            var line = this.getLine(i);
                            deleteRange.start.row = i;
                            deleteRange.end.row = i;
                            for (var j = 0; j < size; ++j) if (line.charAt(j) != ' ') break;
                            if (j < size && line.charAt(j) == '\t') {
                                deleteRange.start.column = j;
                                deleteRange.end.column = j + 1;
                            } else {
                                deleteRange.start.column = 0;
                                deleteRange.end.column = j;
                            }
                            this.remove(deleteRange);
                        }
                    }
                }, {
                    key: "$moveLines",
                    value: function $moveLines(firstRow, lastRow, dir) {
                        firstRow = this.getRowFoldStart(firstRow);
                        lastRow = this.getRowFoldEnd(lastRow);
                        if (dir < 0) {
                            var row = this.getRowFoldStart(firstRow + dir);
                            if (row < 0) return 0;
                            var diff = row - firstRow;
                        } else if (dir > 0) {
                            var row = this.getRowFoldEnd(lastRow + dir);
                            if (row > this.doc.getLength() - 1) return 0;
                            var diff = row - lastRow;
                        } else {
                            firstRow = this.$clipRowToDocument(firstRow);
                            lastRow = this.$clipRowToDocument(lastRow);
                            var diff = lastRow - firstRow + 1;
                        }
                        var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
                        var folds = this.getFoldsInRange(range).map(function (x) {
                            x = x.clone();
                            x.start.row += diff;
                            x.end.row += diff;
                            return x;
                        });
                        var lines = dir === 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeLines(firstRow, lastRow);
                        this.doc.insertLines(firstRow + diff, lines);
                        folds.length && this.addFolds(folds);
                        return diff;
                    }
                }, {
                    key: "moveLinesUp",
                    value: function moveLinesUp(firstRow, lastRow) {
                        return this.$moveLines(firstRow, lastRow, -1);
                    }
                }, {
                    key: "moveLinesDown",
                    value: function moveLinesDown(firstRow, lastRow) {
                        return this.$moveLines(firstRow, lastRow, 1);
                    }
                }, {
                    key: "duplicateLines",
                    value: function duplicateLines(firstRow, lastRow) {
                        return this.$moveLines(firstRow, lastRow, 0);
                    }
                }, {
                    key: "$clipRowToDocument",
                    value: function $clipRowToDocument(row) {
                        return Math.max(0, Math.min(row, this.doc.getLength() - 1));
                    }
                }, {
                    key: "$clipColumnToRow",
                    value: function $clipColumnToRow(row, column) {
                        if (column < 0) return 0;
                        return Math.min(this.doc.getLine(row).length, column);
                    }
                }, {
                    key: "$clipPositionToDocument",
                    value: function $clipPositionToDocument(row, column) {
                        column = Math.max(0, column);
                        if (row < 0) {
                            row = 0;
                            column = 0;
                        } else {
                            var len = this.doc.getLength();
                            if (row >= len) {
                                row = len - 1;
                                column = this.doc.getLine(len - 1).length;
                            } else {
                                column = Math.min(this.doc.getLine(row).length, column);
                            }
                        }
                        return {
                            row: row,
                            column: column
                        };
                    }
                }, {
                    key: "$clipRangeToDocument",
                    value: function $clipRangeToDocument(range) {
                        if (range.start.row < 0) {
                            range.start.row = 0;
                            range.start.column = 0;
                        } else {
                            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
                        }
                        var len = this.doc.getLength() - 1;
                        if (range.end.row > len) {
                            range.end.row = len;
                            range.end.column = this.doc.getLine(len).length;
                        } else {
                            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
                        }
                        return range;
                    }
                }, {
                    key: "setUseWrapMode",
                    value: function setUseWrapMode(useWrapMode) {
                        if (useWrapMode != this.$useWrapMode) {
                            this.$useWrapMode = useWrapMode;
                            this.$modified = true;
                            this.$resetRowCache(0);
                            if (useWrapMode) {
                                var len = this.getLength();
                                this.$wrapData = Array(len);
                                this.$updateWrapData(0, len - 1);
                            }
                            this.eventBus._signal("changeWrapMode");
                        }
                    }
                }, {
                    key: "getUseWrapMode",
                    value: function getUseWrapMode() {
                        return this.$useWrapMode;
                    }
                }, {
                    key: "setWrapLimitRange",
                    value: function setWrapLimitRange(min, max) {
                        if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                            this.$wrapLimitRange = {
                                min: min,
                                max: max
                            };
                            this.$modified = true;
                            this.eventBus._signal("changeWrapMode");
                        }
                    }
                }, {
                    key: "adjustWrapLimit",
                    value: function adjustWrapLimit(desiredLimit, $printMargin) {
                        var limits = this.$wrapLimitRange;
                        if (limits.max < 0) limits = { min: $printMargin, max: $printMargin };
                        var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
                        if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                            this.$wrapLimit = wrapLimit;
                            this.$modified = true;
                            if (this.$useWrapMode) {
                                this.$updateWrapData(0, this.getLength() - 1);
                                this.$resetRowCache(0);
                                this.eventBus._signal("changeWrapLimit");
                            }
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "$constrainWrapLimit",
                    value: function $constrainWrapLimit(wrapLimit, min, max) {
                        if (min) wrapLimit = Math.max(min, wrapLimit);
                        if (max) wrapLimit = Math.min(max, wrapLimit);
                        return wrapLimit;
                    }
                }, {
                    key: "getWrapLimit",
                    value: function getWrapLimit() {
                        return this.$wrapLimit;
                    }
                }, {
                    key: "setWrapLimit",
                    value: function setWrapLimit(limit) {
                        this.setWrapLimitRange(limit, limit);
                    }
                }, {
                    key: "getWrapLimitRange",
                    value: function getWrapLimitRange() {
                        return {
                            min: this.$wrapLimitRange.min,
                            max: this.$wrapLimitRange.max
                        };
                    }
                }, {
                    key: "$updateInternalDataOnChange",
                    value: function $updateInternalDataOnChange(e) {
                        var useWrapMode = this.$useWrapMode;
                        var len;
                        var action = e.data.action;
                        var firstRow = e.data.range.start.row;
                        var lastRow = e.data.range.end.row;
                        var start = e.data.range.start;
                        var end = e.data.range.end;
                        var removedFolds = null;
                        if (action.indexOf("Lines") != -1) {
                            if (action == "insertLines") {
                                lastRow = firstRow + e.data.lines.length;
                            } else {
                                lastRow = firstRow;
                            }
                            len = e.data.lines ? e.data.lines.length : lastRow - firstRow;
                        } else {
                            len = lastRow - firstRow;
                        }
                        this.$updating = true;
                        if (len != 0) {
                            if (action.indexOf("remove") != -1) {
                                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                                var foldLines = this.$foldData;
                                removedFolds = this.getFoldsInRange(e.data.range);
                                this.removeFolds(removedFolds);
                                var foldLine = this.getFoldLine(end.row);
                                var idx = 0;
                                if (foldLine) {
                                    foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                                    foldLine.shiftRow(-len);
                                    var foldLineBefore = this.getFoldLine(firstRow);
                                    if (foldLineBefore && foldLineBefore !== foldLine) {
                                        foldLineBefore.merge(foldLine);
                                        foldLine = foldLineBefore;
                                    }
                                    idx = foldLines.indexOf(foldLine) + 1;
                                }
                                for (idx; idx < foldLines.length; idx++) {
                                    var foldLine = foldLines[idx];
                                    if (foldLine.start.row >= end.row) {
                                        foldLine.shiftRow(-len);
                                    }
                                }
                                lastRow = firstRow;
                            } else {
                                var args = Array(len);
                                args.unshift(firstRow, 0);
                                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                                arr.splice.apply(arr, args);
                                var foldLines = this.$foldData;
                                var foldLine = this.getFoldLine(firstRow);
                                var idx = 0;
                                if (foldLine) {
                                    var cmp = foldLine.range.compareInside(start.row, start.column);
                                    if (cmp == 0) {
                                        foldLine = foldLine.split(start.row, start.column);
                                        foldLine.shiftRow(len);
                                        foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                                    } else if (cmp == -1) {
                                        foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                                        foldLine.shiftRow(len);
                                    }
                                    idx = foldLines.indexOf(foldLine) + 1;
                                }
                                for (idx; idx < foldLines.length; idx++) {
                                    var foldLine = foldLines[idx];
                                    if (foldLine.start.row >= firstRow) {
                                        foldLine.shiftRow(len);
                                    }
                                }
                            }
                        } else {
                            len = Math.abs(e.data.range.start.column - e.data.range.end.column);
                            if (action.indexOf("remove") != -1) {
                                removedFolds = this.getFoldsInRange(e.data.range);
                                this.removeFolds(removedFolds);
                                len = -len;
                            }
                            var foldLine = this.getFoldLine(firstRow);
                            if (foldLine) {
                                foldLine.addRemoveChars(firstRow, start.column, len);
                            }
                        }
                        if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
                            console.error("doc.getLength() and $wrapData.length have to be the same!");
                        }
                        this.$updating = false;
                        if (useWrapMode) this.$updateWrapData(firstRow, lastRow);else this.$updateRowLengthCache(firstRow, lastRow);
                        return removedFolds;
                    }
                }, {
                    key: "$updateRowLengthCache",
                    value: function $updateRowLengthCache(firstRow, lastRow, b) {
                        this.$rowLengthCache[firstRow] = null;
                        this.$rowLengthCache[lastRow] = null;
                    }
                }, {
                    key: "$updateWrapData",
                    value: function $updateWrapData(firstRow, lastRow) {
                        var lines = this.doc.getAllLines();
                        var tabSize = this.getTabSize();
                        var wrapData = this.$wrapData;
                        var wrapLimit = this.$wrapLimit;
                        var tokens;
                        var foldLine;
                        var row = firstRow;
                        lastRow = Math.min(lastRow, lines.length - 1);
                        while (row <= lastRow) {
                            foldLine = this.getFoldLine(row, foldLine);
                            if (!foldLine) {
                                tokens = this.$getDisplayTokens(lines[row]);
                                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                row++;
                            } else {
                                tokens = [];
                                foldLine.walk((function (placeholder, row, column, lastColumn) {
                                    var walkTokens;
                                    if (placeholder != null) {
                                        walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                                        walkTokens[0] = PLACEHOLDER_START;
                                        for (var i = 1; i < walkTokens.length; i++) {
                                            walkTokens[i] = PLACEHOLDER_BODY;
                                        }
                                    } else {
                                        walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                                    }
                                    tokens = tokens.concat(walkTokens);
                                }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                                row = foldLine.end.row + 1;
                            }
                        }
                    }
                }, {
                    key: "$computeWrapSplits",
                    value: function $computeWrapSplits(tokens, wrapLimit, tabSize) {
                        if (tokens.length == 0) {
                            return [];
                        }
                        var splits = [];
                        var displayLength = tokens.length;
                        var lastSplit = 0,
                            lastDocSplit = 0;
                        var isCode = this.$wrapAsCode;
                        function addSplit(screenPos) {
                            var displayed = tokens.slice(lastSplit, screenPos);
                            var len = displayed.length;
                            displayed.join("").replace(/12/g, function () {
                                len -= 1;
                                return void 0;
                            }).replace(/2/g, function () {
                                len -= 1;
                                return void 0;
                            });
                            lastDocSplit += len;
                            splits.push(lastDocSplit);
                            lastSplit = screenPos;
                        }
                        while (displayLength - lastSplit > wrapLimit) {
                            var split = lastSplit + wrapLimit;
                            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                                addSplit(split);
                                continue;
                            }
                            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                                for (split; split != lastSplit - 1; split--) {
                                    if (tokens[split] == PLACEHOLDER_START) {
                                        break;
                                    }
                                }
                                if (split > lastSplit) {
                                    addSplit(split);
                                    continue;
                                }
                                split = lastSplit + wrapLimit;
                                for (split; split < tokens.length; split++) {
                                    if (tokens[split] != PLACEHOLDER_BODY) {
                                        break;
                                    }
                                }
                                if (split == tokens.length) {
                                    break;
                                }
                                addSplit(split);
                                continue;
                            }
                            var minSplit = Math.max(split - (isCode ? 10 : wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                                split--;
                            }
                            if (isCode) {
                                while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                                    split--;
                                }
                                while (split > minSplit && tokens[split] == PUNCTUATION) {
                                    split--;
                                }
                            } else {
                                while (split > minSplit && tokens[split] < SPACE) {
                                    split--;
                                }
                            }
                            if (split > minSplit) {
                                addSplit(++split);
                                continue;
                            }
                            split = lastSplit + wrapLimit;
                            addSplit(split);
                        }
                        return splits;
                    }
                }, {
                    key: "$getDisplayTokens",
                    value: function $getDisplayTokens(str, offset) {
                        var arr = [];
                        var tabSize;
                        offset = offset || 0;
                        for (var i = 0; i < str.length; i++) {
                            var c = str.charCodeAt(i);
                            if (c == 9) {
                                tabSize = this.getScreenTabSize(arr.length + offset);
                                arr.push(TAB);
                                for (var n = 1; n < tabSize; n++) {
                                    arr.push(TAB_SPACE);
                                }
                            } else if (c == 32) {
                                arr.push(SPACE);
                            } else if (c > 39 && c < 48 || c > 57 && c < 64) {
                                arr.push(PUNCTUATION);
                            } else if (c >= 0x1100 && isFullWidth(c)) {
                                arr.push(CHAR, CHAR_EXT);
                            } else {
                                arr.push(CHAR);
                            }
                        }
                        return arr;
                    }
                }, {
                    key: "$getStringScreenWidth",
                    value: function $getStringScreenWidth(str, maxScreenColumn, screenColumn) {
                        if (maxScreenColumn == 0) return [0, 0];
                        if (maxScreenColumn == null) maxScreenColumn = Infinity;
                        screenColumn = screenColumn || 0;
                        var c;
                        var column;
                        for (column = 0; column < str.length; column++) {
                            c = str.charCodeAt(column);
                            if (c == 9) {
                                screenColumn += this.getScreenTabSize(screenColumn);
                            } else if (c >= 0x1100 && isFullWidth(c)) {
                                screenColumn += 2;
                            } else {
                                screenColumn += 1;
                            }
                            if (screenColumn > maxScreenColumn) {
                                break;
                            }
                        }
                        return [screenColumn, column];
                    }
                }, {
                    key: "getRowLength",
                    value: function getRowLength(row) {
                        if (this.lineWidgets) var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;else h = 0;
                        if (!this.$useWrapMode || !this.$wrapData[row]) {
                            return 1 + h;
                        } else {
                            return this.$wrapData[row].length + 1 + h;
                        }
                    }
                }, {
                    key: "getRowLineCount",
                    value: function getRowLineCount(row) {
                        if (!this.$useWrapMode || !this.$wrapData[row]) {
                            return 1;
                        } else {
                            return this.$wrapData[row].length + 1;
                        }
                    }
                }, {
                    key: "getRowWrapIndent",
                    value: function getRowWrapIndent(screenRow) {
                        if (this.$useWrapMode) {
                            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                            var splits = this.$wrapData[pos.row];
                            return splits.length && splits[0] < pos.column ? splits['indent'] : 0;
                        } else {
                            return 0;
                        }
                    }
                }, {
                    key: "getScreenLastRowColumn",
                    value: function getScreenLastRowColumn(screenRow) {
                        var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                        return this.documentToScreenColumn(pos.row, pos.column);
                    }
                }, {
                    key: "getDocumentLastRowColumn",
                    value: function getDocumentLastRowColumn(docRow, docColumn) {
                        var screenRow = this.documentToScreenRow(docRow, docColumn);
                        return this.getScreenLastRowColumn(screenRow);
                    }
                }, {
                    key: "getDocumentLastRowColumnPosition",
                    value: function getDocumentLastRowColumnPosition(docRow, docColumn) {
                        var screenRow = this.documentToScreenRow(docRow, docColumn);
                        return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
                    }
                }, {
                    key: "getRowSplitData",
                    value: function getRowSplitData(row) {
                        if (!this.$useWrapMode) {
                            return undefined;
                        } else {
                            return this.$wrapData[row];
                        }
                    }
                }, {
                    key: "getScreenTabSize",
                    value: function getScreenTabSize(screenColumn) {
                        return this.$tabSize - screenColumn % this.$tabSize;
                    }
                }, {
                    key: "screenToDocumentRow",
                    value: function screenToDocumentRow(screenRow, screenColumn) {
                        return this.screenToDocumentPosition(screenRow, screenColumn).row;
                    }
                }, {
                    key: "screenToDocumentColumn",
                    value: function screenToDocumentColumn(screenRow, screenColumn) {
                        return this.screenToDocumentPosition(screenRow, screenColumn).column;
                    }
                }, {
                    key: "screenToDocumentPosition",
                    value: function screenToDocumentPosition(screenRow, screenColumn) {
                        if (screenRow < 0) {
                            return { row: 0, column: 0 };
                        }
                        var line;
                        var docRow = 0;
                        var docColumn = 0;
                        var column;
                        var row = 0;
                        var rowLength = 0;
                        var rowCache = this.$screenRowCache;
                        var i = this.$getRowCacheIndex(rowCache, screenRow);
                        var l = rowCache.length;
                        if (l && i >= 0) {
                            var row = rowCache[i];
                            var docRow = this.$docRowCache[i];
                            var doCache = screenRow > rowCache[l - 1];
                        } else {
                            var doCache = !l;
                        }
                        var maxRow = this.getLength() - 1;
                        var foldLine = this.getNextFoldLine(docRow);
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        while (row <= screenRow) {
                            rowLength = this.getRowLength(docRow);
                            if (row + rowLength > screenRow || docRow >= maxRow) {
                                break;
                            } else {
                                row += rowLength;
                                docRow++;
                                if (docRow > foldStart) {
                                    docRow = foldLine.end.row + 1;
                                    foldLine = this.getNextFoldLine(docRow, foldLine);
                                    foldStart = foldLine ? foldLine.start.row : Infinity;
                                }
                            }
                            if (doCache) {
                                this.$docRowCache.push(docRow);
                                this.$screenRowCache.push(row);
                            }
                        }
                        if (foldLine && foldLine.start.row <= docRow) {
                            line = this.getFoldDisplayLine(foldLine);
                            docRow = foldLine.start.row;
                        } else if (row + rowLength <= screenRow || docRow > maxRow) {
                            return {
                                row: maxRow,
                                column: this.getLine(maxRow).length
                            };
                        } else {
                            line = this.getLine(docRow);
                            foldLine = null;
                        }
                        if (this.$useWrapMode) {
                            var splits = this.$wrapData[docRow];
                            if (splits) {
                                var splitIndex = Math.floor(screenRow - row);
                                column = splits[splitIndex];
                                if (splitIndex > 0 && splits.length) {
                                    docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                                    line = line.substring(docColumn);
                                }
                            }
                        }
                        docColumn += this.$getStringScreenWidth(line, screenColumn)[1];
                        if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;
                        if (foldLine) return foldLine.idxToPosition(docColumn);
                        return { row: docRow, column: docColumn };
                    }
                }, {
                    key: "documentToScreenPosition",
                    value: function documentToScreenPosition(docRow, docColumn) {
                        var pos;
                        if (typeof docColumn === "undefined") {
                            pos = this.$clipPositionToDocument(docRow['row'], docRow['column']);
                        } else {
                            assert(typeof docRow === 'number', "docRow must be a number");
                            assert(typeof docColumn === 'number', "docColumn must be a number");
                            pos = this.$clipPositionToDocument(docRow, docColumn);
                        }
                        docRow = pos.row;
                        docColumn = pos.column;
                        assert(typeof docRow === 'number', "docRow must be a number");
                        assert(typeof docColumn === 'number', "docColumn must be a number");
                        var screenRow = 0;
                        var foldStartRow = null;
                        var fold = null;
                        fold = this.getFoldAt(docRow, docColumn, 1);
                        if (fold) {
                            docRow = fold.start.row;
                            docColumn = fold.start.column;
                        }
                        var rowEnd,
                            row = 0;
                        var rowCache = this.$docRowCache;
                        var i = this.$getRowCacheIndex(rowCache, docRow);
                        var l = rowCache.length;
                        if (l && i >= 0) {
                            var row = rowCache[i];
                            var screenRow = this.$screenRowCache[i];
                            var doCache = docRow > rowCache[l - 1];
                        } else {
                            var doCache = !l;
                        }
                        var foldLine = this.getNextFoldLine(row);
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        while (row < docRow) {
                            if (row >= foldStart) {
                                rowEnd = foldLine.end.row + 1;
                                if (rowEnd > docRow) break;
                                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            } else {
                                rowEnd = row + 1;
                            }
                            screenRow += this.getRowLength(row);
                            row = rowEnd;
                            if (doCache) {
                                this.$docRowCache.push(row);
                                this.$screenRowCache.push(screenRow);
                            }
                        }
                        var textLine = "";
                        if (foldLine && row >= foldStart) {
                            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                            foldStartRow = foldLine.start.row;
                        } else {
                            textLine = this.getLine(docRow).substring(0, docColumn);
                            foldStartRow = docRow;
                        }
                        if (this.$useWrapMode) {
                            var wrapRow = this.$wrapData[foldStartRow];
                            if (wrapRow) {
                                var screenRowOffset = 0;
                                while (textLine.length >= wrapRow[screenRowOffset]) {
                                    screenRow++;
                                    screenRowOffset++;
                                }
                                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                            }
                        }
                        return {
                            row: screenRow,
                            column: this.$getStringScreenWidth(textLine)[0]
                        };
                    }
                }, {
                    key: "documentToScreenColumn",
                    value: function documentToScreenColumn(docRow, docColumn) {
                        return this.documentToScreenPosition(docRow, docColumn).column;
                    }
                }, {
                    key: "documentToScreenRow",
                    value: function documentToScreenRow(docRow, docColumn) {
                        return this.documentToScreenPosition(docRow, docColumn).row;
                    }
                }, {
                    key: "documentToScreenRange",
                    value: function documentToScreenRange(range) {
                        var screenPosStart = this.documentToScreenPosition(range.start.row, range.start.column);
                        var screenPosEnd = this.documentToScreenPosition(range.end.row, range.end.column);
                        return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
                    }
                }, {
                    key: "getScreenLength",
                    value: function getScreenLength() {
                        var screenRows = 0;
                        var fold = null;
                        if (!this.$useWrapMode) {
                            screenRows = this.getLength();
                            var foldData = this.$foldData;
                            for (var i = 0; i < foldData.length; i++) {
                                fold = foldData[i];
                                screenRows -= fold.end.row - fold.start.row;
                            }
                        } else {
                            var lastRow = this.$wrapData.length;
                            var row = 0,
                                i = 0;
                            var fold = this.$foldData[i++];
                            var foldStart = fold ? fold.start.row : Infinity;
                            while (row < lastRow) {
                                var splits = this.$wrapData[row];
                                screenRows += splits ? splits.length + 1 : 1;
                                row++;
                                if (row > foldStart) {
                                    row = fold.end.row + 1;
                                    fold = this.$foldData[i++];
                                    foldStart = fold ? fold.start.row : Infinity;
                                }
                            }
                        }
                        if (this.lineWidgets) {
                            screenRows += this.$getWidgetScreenLength();
                        }
                        return screenRows;
                    }
                }, {
                    key: "$setFontMetrics",
                    value: function $setFontMetrics(fm) {}
                }, {
                    key: "findMatchingBracket",
                    value: function findMatchingBracket(position, chr) {
                        return this.$bracketMatcher.findMatchingBracket(position, chr);
                    }
                }, {
                    key: "getBracketRange",
                    value: function getBracketRange(position) {
                        return this.$bracketMatcher.getBracketRange(position);
                    }
                }, {
                    key: "findOpeningBracket",
                    value: function findOpeningBracket(bracket, position, typeRe) {
                        return this.$bracketMatcher.findOpeningBracket(bracket, position, typeRe);
                    }
                }, {
                    key: "findClosingBracket",
                    value: function findClosingBracket(bracket, position, typeRe) {
                        return this.$bracketMatcher.findClosingBracket(bracket, position, typeRe);
                    }
                }, {
                    key: "getFoldAt",
                    value: function getFoldAt(row, column, side) {
                        var foldLine = this.getFoldLine(row);
                        if (!foldLine) return null;
                        var folds = foldLine.folds;
                        for (var i = 0; i < folds.length; i++) {
                            var fold = folds[i];
                            if (fold.range.contains(row, column)) {
                                if (side === 1 && fold.range.isEnd(row, column)) {
                                    continue;
                                } else if (side === -1 && fold.range.isStart(row, column)) {
                                    continue;
                                }
                                return fold;
                            }
                        }
                    }
                }, {
                    key: "getFoldsInRange",
                    value: function getFoldsInRange(range) {
                        var start = range.start;
                        var end = range.end;
                        var foldLines = this.$foldData;
                        var foundFolds = [];
                        start.column += 1;
                        end.column -= 1;
                        for (var i = 0; i < foldLines.length; i++) {
                            var cmp = foldLines[i].range.compareRange(range);
                            if (cmp == 2) {
                                continue;
                            } else if (cmp == -2) {
                                break;
                            }
                            var folds = foldLines[i].folds;
                            for (var j = 0; j < folds.length; j++) {
                                var fold = folds[j];
                                cmp = fold.range.compareRange(range);
                                if (cmp == -2) {
                                    break;
                                } else if (cmp == 2) {
                                    continue;
                                } else if (cmp == 42) {
                                    break;
                                }
                                foundFolds.push(fold);
                            }
                        }
                        start.column -= 1;
                        end.column += 1;
                        return foundFolds;
                    }
                }, {
                    key: "getFoldsInRangeList",
                    value: function getFoldsInRangeList(ranges) {
                        if (Array.isArray(ranges)) {
                            var folds = [];
                            ranges.forEach(function (range) {
                                folds = folds.concat(this.getFoldsInRange(range));
                            }, this);
                        } else {
                            var folds = this.getFoldsInRange(ranges);
                        }
                        return folds;
                    }
                }, {
                    key: "getAllFolds",
                    value: function getAllFolds() {
                        var folds = [];
                        var foldLines = this.$foldData;
                        for (var i = 0; i < foldLines.length; i++) for (var j = 0; j < foldLines[i].folds.length; j++) folds.push(foldLines[i].folds[j]);
                        return folds;
                    }
                }, {
                    key: "getFoldStringAt",
                    value: function getFoldStringAt(row, column, trim, foldLine) {
                        foldLine = foldLine || this.getFoldLine(row);
                        if (!foldLine) return null;
                        var lastFold = {
                            end: { column: 0 }
                        };
                        var str;
                        var fold;
                        for (var i = 0; i < foldLine.folds.length; i++) {
                            fold = foldLine.folds[i];
                            var cmp = fold.range.compareEnd(row, column);
                            if (cmp == -1) {
                                str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                                break;
                            } else if (cmp === 0) {
                                return null;
                            }
                            lastFold = fold;
                        }
                        if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);
                        if (trim == -1) return str.substring(0, column - lastFold.end.column);else if (trim == 1) return str.substring(column - lastFold.end.column);else return str;
                    }
                }, {
                    key: "getFoldLine",
                    value: function getFoldLine(docRow, startFoldLine) {
                        var foldData = this.$foldData;
                        var i = 0;
                        if (startFoldLine) i = foldData.indexOf(startFoldLine);
                        if (i == -1) i = 0;
                        for (i; i < foldData.length; i++) {
                            var foldLine = foldData[i];
                            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
                                return foldLine;
                            } else if (foldLine.end.row > docRow) {
                                return null;
                            }
                        }
                        return null;
                    }
                }, {
                    key: "getNextFoldLine",
                    value: function getNextFoldLine(docRow, startFoldLine) {
                        var foldData = this.$foldData;
                        var i = 0;
                        if (startFoldLine) i = foldData.indexOf(startFoldLine);
                        if (i == -1) i = 0;
                        for (i; i < foldData.length; i++) {
                            var foldLine = foldData[i];
                            if (foldLine.end.row >= docRow) {
                                return foldLine;
                            }
                        }
                        return null;
                    }
                }, {
                    key: "getFoldedRowCount",
                    value: function getFoldedRowCount(first, last) {
                        var foldData = this.$foldData;
                        var rowCount = last - first + 1;
                        for (var i = 0; i < foldData.length; i++) {
                            var foldLine = foldData[i],
                                end = foldLine.end.row,
                                start = foldLine.start.row;
                            if (end >= last) {
                                if (start < last) {
                                    if (start >= first) rowCount -= last - start;else rowCount = 0;
                                }
                                break;
                            } else if (end >= first) {
                                if (start >= first) rowCount -= end - start;else rowCount -= end - first + 1;
                            }
                        }
                        return rowCount;
                    }
                }, {
                    key: "$addFoldLine",
                    value: function $addFoldLine(foldLine) {
                        this.$foldData.push(foldLine);
                        this.$foldData.sort(function (a, b) {
                            return a.start.row - b.start.row;
                        });
                        return foldLine;
                    }
                }, {
                    key: "addFold",
                    value: function addFold(placeholder, range) {
                        var foldData = this.$foldData;
                        var added = false;
                        var fold;
                        if (placeholder instanceof Fold) fold = placeholder;else if (typeof placeholder === 'string') {
                            fold = new Fold(range, placeholder);
                            fold.collapseChildren = range.collapseChildren;
                        } else {
                            throw new Error("placeholder must be a string or a Fold.");
                        }
                        fold.range = this.$clipRangeToDocument(fold.range);
                        var startRow = fold.start.row;
                        var startColumn = fold.start.column;
                        var endRow = fold.end.row;
                        var endColumn = fold.end.column;
                        if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2)) throw new Error("The range has to be at least 2 characters width");
                        var startFold = this.getFoldAt(startRow, startColumn, 1);
                        var endFold = this.getFoldAt(endRow, endColumn, -1);
                        if (startFold && endFold == startFold) return startFold.addSubFold(fold);
                        if (startFold && !startFold.range.isStart(startRow, startColumn) || endFold && !endFold.range.isEnd(endRow, endColumn)) {
                            throw new Error("A fold can't intersect already existing fold" + fold.range + startFold.range);
                        }
                        var folds = this.getFoldsInRange(fold.range);
                        if (folds.length > 0) {
                            this.removeFolds(folds);
                            folds.forEach(function (subFold) {
                                fold.addSubFold(subFold);
                            });
                        }
                        for (var i = 0; i < foldData.length; i++) {
                            var foldLine = foldData[i];
                            if (endRow == foldLine.start.row) {
                                foldLine.addFold(fold);
                                added = true;
                                break;
                            } else if (startRow == foldLine.end.row) {
                                foldLine.addFold(fold);
                                added = true;
                                if (!fold.sameRow) {
                                    var foldLineNext = foldData[i + 1];
                                    if (foldLineNext && foldLineNext.start.row == endRow) {
                                        foldLine.merge(foldLineNext);
                                        break;
                                    }
                                }
                                break;
                            } else if (endRow <= foldLine.start.row) {
                                break;
                            }
                        }
                        if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, [fold]));
                        if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
                        this.setModified(true);
                        var foldEvent = { data: fold, action: "add" };
                        this.eventBus._emit("changeFold", foldEvent);
                        return fold;
                    }
                }, {
                    key: "setModified",
                    value: function setModified(modified) {}
                }, {
                    key: "addFolds",
                    value: function addFolds(folds) {
                        folds.forEach(function (fold) {
                            this.addFold(fold);
                        }, this);
                    }
                }, {
                    key: "removeFold",
                    value: function removeFold(fold) {
                        var foldLine = fold.foldLine;
                        var startRow = foldLine.start.row;
                        var endRow = foldLine.end.row;
                        var foldLines = this.$foldData;
                        var folds = foldLine.folds;
                        if (folds.length == 1) {
                            foldLines.splice(foldLines.indexOf(foldLine), 1);
                        } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                            folds.pop();
                            foldLine.end.row = folds[folds.length - 1].end.row;
                            foldLine.end.column = folds[folds.length - 1].end.column;
                        } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                            folds.shift();
                            foldLine.start.row = folds[0].start.row;
                            foldLine.start.column = folds[0].start.column;
                        } else if (fold.sameRow) {
                            folds.splice(folds.indexOf(fold), 1);
                        } else {
                            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                            folds = newFoldLine.folds;
                            folds.shift();
                            newFoldLine.start.row = folds[0].start.row;
                            newFoldLine.start.column = folds[0].start.column;
                        }
                        if (!this.$updating) {
                            if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);else this.$updateRowLengthCache(startRow, endRow);
                        }
                        this.setModified(true);
                        var foldEvent = { data: fold, action: "remove" };
                        this.eventBus._emit("changeFold", foldEvent);
                    }
                }, {
                    key: "removeFolds",
                    value: function removeFolds(folds) {
                        var cloneFolds = [];
                        for (var i = 0; i < folds.length; i++) {
                            cloneFolds.push(folds[i]);
                        }
                        cloneFolds.forEach(function (fold) {
                            this.removeFold(fold);
                        }, this);
                        this.setModified(true);
                    }
                }, {
                    key: "expandFold",
                    value: function expandFold(fold) {
                        this.removeFold(fold);
                        fold.subFolds.forEach(function (subFold) {
                            fold.restoreRange(subFold);
                            this.addFold(subFold);
                        }, this);
                        if (fold.collapseChildren > 0) {
                            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
                        }
                        fold.subFolds = [];
                    }
                }, {
                    key: "expandFolds",
                    value: function expandFolds(folds) {
                        folds.forEach(function (fold) {
                            this.expandFold(fold);
                        }, this);
                    }
                }, {
                    key: "unfold",
                    value: function unfold(location, expandInner) {
                        var range;
                        var folds;
                        if (location == null) {
                            range = new Range(0, 0, this.getLength(), 0);
                            expandInner = true;
                        } else if (typeof location === "number") range = new Range(location, 0, location, this.getLine(location).length);else if ("row" in location) range = Range.fromPoints(location, location);else if (location instanceof Range) {
                            range = location;
                        } else {
                            throw new TypeError("location must be one of number | Position | Range");
                        }
                        folds = this.getFoldsInRangeList(range);
                        if (expandInner) {
                            this.removeFolds(folds);
                        } else {
                            var subFolds = folds;
                            while (subFolds.length) {
                                this.expandFolds(subFolds);
                                subFolds = this.getFoldsInRangeList(range);
                            }
                        }
                        if (folds.length) return folds;
                    }
                }, {
                    key: "isRowFolded",
                    value: function isRowFolded(docRow, startFoldRow) {
                        return !!this.getFoldLine(docRow, startFoldRow);
                    }
                }, {
                    key: "getRowFoldEnd",
                    value: function getRowFoldEnd(docRow, startFoldRow) {
                        var foldLine = this.getFoldLine(docRow, startFoldRow);
                        return foldLine ? foldLine.end.row : docRow;
                    }
                }, {
                    key: "getRowFoldStart",
                    value: function getRowFoldStart(docRow, startFoldRow) {
                        var foldLine = this.getFoldLine(docRow, startFoldRow);
                        return foldLine ? foldLine.start.row : docRow;
                    }
                }, {
                    key: "getFoldDisplayLine",
                    value: function getFoldDisplayLine(foldLine, endRow, endColumn, startRow, startColumn) {
                        if (startRow == null) startRow = foldLine.start.row;
                        if (startColumn == null) startColumn = 0;
                        if (endRow == null) endRow = foldLine.end.row;
                        if (endColumn == null) endColumn = this.getLine(endRow).length;
                        var self = this;
                        var textLine = "";
                        foldLine.walk(function (placeholder, row, column, lastColumn) {
                            if (row < startRow) return;
                            if (row == startRow) {
                                if (column < startColumn) return;
                                lastColumn = Math.max(startColumn, lastColumn);
                            }
                            if (placeholder != null) {
                                textLine += placeholder;
                            } else {
                                textLine += self.getLine(row).substring(lastColumn, column);
                            }
                        }, endRow, endColumn);
                        return textLine;
                    }
                }, {
                    key: "getDisplayLine",
                    value: function getDisplayLine(row, endColumn, startRow, startColumn) {
                        var foldLine = this.getFoldLine(row);
                        if (!foldLine) {
                            var line;
                            line = this.getLine(row);
                            return line.substring(startColumn || 0, endColumn || line.length);
                        } else {
                            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
                        }
                    }
                }, {
                    key: "$cloneFoldData",
                    value: function $cloneFoldData() {
                        var fd = [];
                        fd = this.$foldData.map(function (foldLine) {
                            var folds = foldLine.folds.map(function (fold) {
                                return fold.clone();
                            });
                            return new FoldLine(fd, folds);
                        });
                        return fd;
                    }
                }, {
                    key: "toggleFold",
                    value: function toggleFold(tryToUnfold) {
                        var selection = this.selection;
                        var range = selection.getRange();
                        var fold;
                        var bracketPos;
                        if (range.isEmpty()) {
                            var cursor = range.start;
                            fold = this.getFoldAt(cursor.row, cursor.column);
                            if (fold) {
                                this.expandFold(fold);
                                return;
                            } else if (bracketPos = this.findMatchingBracket(cursor)) {
                                if (range.comparePoint(bracketPos) == 1) {
                                    range.end = bracketPos;
                                } else {
                                    range.start = bracketPos;
                                    range.start.column++;
                                    range.end.column--;
                                }
                            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
                                if (range.comparePoint(bracketPos) === 1) range.end = bracketPos;else range.start = bracketPos;
                                range.start.column++;
                            } else {
                                range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
                            }
                        } else {
                            var folds = this.getFoldsInRange(range);
                            if (tryToUnfold && folds.length) {
                                this.expandFolds(folds);
                                return;
                            } else if (folds.length == 1) {
                                fold = folds[0];
                            }
                        }
                        if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);
                        if (fold && fold.range.toString() == range.toString()) {
                            this.expandFold(fold);
                            return;
                        }
                        var placeholder = "...";
                        if (!range.isMultiLine()) {
                            placeholder = this.getTextRange(range);
                            if (placeholder.length < 4) return;
                            placeholder = placeholder.trim().substring(0, 2) + "..";
                        }
                        this.addFold(placeholder, range);
                    }
                }, {
                    key: "getCommentFoldRange",
                    value: function getCommentFoldRange(row, column, dir) {
                        var iterator = new TokenIterator(this, row, column);
                        var token = iterator.getCurrentToken();
                        if (token && /^comment|string/.test(token.type)) {
                            var range = new Range(0, 0, 0, 0);
                            var re = new RegExp(token.type.replace(/\..*/, "\\."));
                            if (dir != 1) {
                                do {
                                    token = iterator.stepBackward();
                                } while (token && re.test(token.type));
                                iterator.stepForward();
                            }
                            range.start.row = iterator.getCurrentTokenRow();
                            range.start.column = iterator.getCurrentTokenColumn() + 2;
                            iterator = new TokenIterator(this, row, column);
                            if (dir != -1) {
                                do {
                                    token = iterator.stepForward();
                                } while (token && re.test(token.type));
                                token = iterator.stepBackward();
                            } else token = iterator.getCurrentToken();
                            range.end.row = iterator.getCurrentTokenRow();
                            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
                            return range;
                        }
                    }
                }, {
                    key: "foldAll",
                    value: function foldAll(startRow, endRow, depth) {
                        if (depth === void 0) {
                            depth = 100000;
                        }
                        var foldWidgets = this.foldWidgets;
                        if (!foldWidgets) {
                            return;
                        }
                        endRow = endRow || this.getLength();
                        startRow = startRow || 0;
                        for (var row = startRow; row < endRow; row++) {
                            if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                            if (foldWidgets[row] != "start") continue;
                            var range = this.getFoldWidgetRange(row);
                            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                                row = range.end.row;
                                try {
                                    var fold = this.addFold("...", range);
                                    if (fold) fold.collapseChildren = depth;
                                } catch (e) {}
                            }
                        }
                    }
                }, {
                    key: "setFoldStyle",
                    value: function setFoldStyle(style) {
                        if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + _Object$keys(this.$foldStyles).join(", ") + "]");
                        if (this.$foldStyle === style) return;
                        this.$foldStyle = style;
                        if (style === "manual") this.unfold();
                        var mode = this.$foldMode;
                        this.$setFolding(null);
                        this.$setFolding(mode);
                    }
                }, {
                    key: "$setFolding",
                    value: function $setFolding(foldMode) {
                        if (this.$foldMode == foldMode) return;
                        this.$foldMode = foldMode;
                        this.eventBus.off('change', this.$updateFoldWidgets);
                        this.eventBus._emit("changeAnnotation");
                        if (!foldMode || this.$foldStyle === "manual") {
                            this.foldWidgets = null;
                            return;
                        }
                        this.foldWidgets = [];
                        this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
                        this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
                        this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
                        this.eventBus.on('change', this.$updateFoldWidgets);
                    }
                }, {
                    key: "getParentFoldRangeData",
                    value: function getParentFoldRangeData(row, ignoreCurrent) {
                        var fw = this.foldWidgets;
                        if (!fw || ignoreCurrent && fw[row]) {
                            return {};
                        }
                        var i = row - 1;
                        var firstRange;
                        while (i >= 0) {
                            var c = fw[i];
                            if (c == null) c = fw[i] = this.getFoldWidget(i);
                            if (c == "start") {
                                var range = this.getFoldWidgetRange(i);
                                if (!firstRange) firstRange = range;
                                if (range && range.end.row >= row) break;
                            }
                            i--;
                        }
                        return {
                            range: i !== -1 && range,
                            firstRange: firstRange
                        };
                    }
                }, {
                    key: "onFoldWidgetClick",
                    value: function onFoldWidgetClick(row, e) {
                        e = e.domEvent;
                        var options = {
                            children: e.shiftKey,
                            all: e.ctrlKey || e.metaKey,
                            siblings: e.altKey
                        };
                        var range = this.$toggleFoldWidget(row, options);
                        if (!range) {
                            var el = e.target || e.srcElement;
                            if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
                        }
                    }
                }, {
                    key: "$toggleFoldWidget",
                    value: function $toggleFoldWidget(row, options) {
                        if (!this.getFoldWidget) return;
                        var type = this.getFoldWidget(row);
                        var line = this.getLine(row);
                        var dir = type === "end" ? -1 : 1;
                        var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
                        if (fold) {
                            if (options.children || options.all) this.removeFold(fold);else this.expandFold(fold);
                            return;
                        }
                        var range = this.getFoldWidgetRange(row, true);
                        if (range && !range.isMultiLine()) {
                            fold = this.getFoldAt(range.start.row, range.start.column, 1);
                            if (fold && range.isEqual(fold.range)) {
                                this.removeFold(fold);
                                return;
                            }
                        }
                        if (options.siblings) {
                            var data = this.getParentFoldRangeData(row);
                            if (data.range) {
                                var startRow = data.range.start.row + 1;
                                var endRow = data.range.end.row;
                            }
                            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
                        } else if (options.children) {
                            endRow = range ? range.end.row : this.getLength();
                            this.foldAll(row + 1, range.end.row, options.all ? 10000 : 0);
                        } else if (range) {
                            if (options.all) {
                                range.collapseChildren = 10000;
                            }
                            this.addFold("...", range);
                        }
                        return range;
                    }
                }, {
                    key: "toggleFoldWidget",
                    value: function toggleFoldWidget(toggleParent) {
                        var row = this.selection.getCursor().row;
                        row = this.getRowFoldStart(row);
                        var range = this.$toggleFoldWidget(row, {});
                        if (range) {
                            return;
                        }
                        var data = this.getParentFoldRangeData(row, true);
                        range = data.range || data.firstRange;
                        if (range) {
                            row = range.start.row;
                            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
                            if (fold) {
                                this.removeFold(fold);
                            } else {
                                this.addFold("...", range);
                            }
                        }
                    }
                }, {
                    key: "updateFoldWidgets",
                    value: function updateFoldWidgets(e, editSession) {
                        var delta = e.data;
                        var range = delta.range;
                        var firstRow = range.start.row;
                        var len = range.end.row - firstRow;
                        if (len === 0) {
                            this.foldWidgets[firstRow] = null;
                        } else if (delta.action == "removeText" || delta.action == "removeLines") {
                            this.foldWidgets.splice(firstRow, len + 1, null);
                        } else {
                            var args = Array(len + 1);
                            args.unshift(firstRow, 1);
                            this.foldWidgets.splice.apply(this.foldWidgets, args);
                        }
                    }
                }]);

                return EditSession;
            })();

            _export("default", EditSession);

            defineOptions(EditSession.prototype, "session", {
                wrap: {
                    set: function set(value) {
                        if (!value || value == "off") value = false;else if (value == "free") value = true;else if (value == "printMargin") value = -1;else if (typeof value == "string") value = parseInt(value, 10) || false;
                        if (this.$wrap == value) return;
                        if (!value) {
                            this.setUseWrapMode(false);
                        } else {
                            var col = typeof value == "number" ? value : null;
                            this.setWrapLimitRange(col, col);
                            this.setUseWrapMode(true);
                        }
                        this.$wrap = value;
                    },
                    get: function get() {
                        if (this.getUseWrapMode()) {
                            if (this.$wrap == -1) return "printMargin";
                            if (!this.getWrapLimitRange().min) return "free";
                            return this.$wrap;
                        }
                        return "off";
                    },
                    handlesSet: true
                },
                wrapMethod: {
                    set: function set(val) {
                        val = val == "auto" ? this.$mode.type != "text" : val != "text";
                        if (val != this.$wrapAsCode) {
                            this.$wrapAsCode = val;
                            if (this.$useWrapMode) {
                                this.$modified = true;
                                this.$resetRowCache(0);
                                this.$updateWrapData(0, this.getLength() - 1);
                            }
                        }
                    },
                    initialValue: "auto"
                },
                firstLineNumber: {
                    set: function set() {
                        this._signal("changeBreakpoint");
                    },
                    initialValue: 1
                },
                useWorker: {
                    set: function set(useWorker) {
                        this.$useWorker = useWorker;
                        this.$stopWorker();
                        if (useWorker) {
                            this.$startWorker();
                        }
                    },
                    initialValue: true
                },
                useSoftTabs: { initialValue: true },
                tabSize: {
                    set: function set(tabSize) {
                        if (isNaN(tabSize) || this.$tabSize === tabSize) return;
                        this.$modified = true;
                        this.$rowLengthCache = [];
                        this.$tabSize = tabSize;
                        this._signal("changeTabSize");
                    },
                    initialValue: 4,
                    handlesSet: true
                },
                overwrite: {
                    set: function set(val) {
                        this._signal("changeOverwrite");
                    },
                    initialValue: false
                },
                newLineMode: {
                    set: function set(val) {
                        this.doc.setNewLineMode(val);
                    },
                    get: function get() {
                        return this.doc.getNewLineMode();
                    },
                    handlesSet: true
                },
                mode: {
                    set: function set(val) {
                        this.setMode(val);
                    },
                    get: function get() {
                        return this.$modeId;
                    }
                }
            });
        }
    };
});
System.register("src/UndoManager.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, UndoManager;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            UndoManager = (function () {
                function UndoManager() {
                    _classCallCheck(this, UndoManager);

                    this.reset();
                }

                _createClass(UndoManager, [{
                    key: "execute",
                    value: function execute(options) {
                        var deltas = options.args[0];
                        this._editSession = options.args[1];
                        if (options.merge && this.hasUndo()) {
                            this._dirtyCounter--;
                            deltas = this.$undoStack.pop().concat(deltas);
                        }
                        this.$undoStack.push(deltas);
                        this.$redoStack = [];
                        if (this._dirtyCounter < 0) {
                            this._dirtyCounter = NaN;
                        }
                        this._dirtyCounter++;
                    }
                }, {
                    key: "undo",
                    value: function undo(dontSelect) {
                        var deltas = this.$undoStack.pop();
                        var undoSelectionRange = null;
                        if (deltas) {
                            undoSelectionRange = this._editSession.undoChanges(deltas, dontSelect);
                            this.$redoStack.push(deltas);
                            this._dirtyCounter--;
                        }
                        return undoSelectionRange;
                    }
                }, {
                    key: "redo",
                    value: function redo(dontSelect) {
                        var deltas = this.$redoStack.pop();
                        var redoSelectionRange = null;
                        if (deltas) {
                            redoSelectionRange = this._editSession.redoChanges(deltas, dontSelect);
                            this.$undoStack.push(deltas);
                            this._dirtyCounter++;
                        }
                        return redoSelectionRange;
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this.$undoStack = [];
                        this.$redoStack = [];
                        this.markClean();
                    }
                }, {
                    key: "hasUndo",
                    value: function hasUndo() {
                        return this.$undoStack.length > 0;
                    }
                }, {
                    key: "hasRedo",
                    value: function hasRedo() {
                        return this.$redoStack.length > 0;
                    }
                }, {
                    key: "markClean",
                    value: function markClean() {
                        this._dirtyCounter = 0;
                    }
                }, {
                    key: "isClean",
                    value: function isClean() {
                        return this._dirtyCounter === 0;
                    }
                }]);

                return UndoManager;
            })();

            _export("default", UndoManager);
        }
    };
});
System.register("src/config.js", ["npm:babel-runtime@5.8.34/core-js/object/keys", "src/lib/lang.js", "src/lib/oop.js", "src/lib/net.js"], function (_export) {
    var _Object$keys, copyObject, implement, loadScript, global, options, $loading, optionsProvider, defaultOptions;

    function get(key) {
        if (!options.hasOwnProperty(key)) {
            throw new Error("Unknown config key: " + key);
        }
        return options[key];
    }

    function set(key, value) {
        if (!options.hasOwnProperty(key)) {
            throw new Error("Unknown config key: " + key);
        }
        options[key] = value;
    }

    function all() {
        return copyObject(options);
    }

    function moduleUrl(moduleName, component) {
        if (options.$moduleUrls[moduleName]) {
            return options.$moduleUrls[moduleName];
        }
        var parts = moduleName.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component === "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component === 'worker' && sep === '-') {
            var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
            base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1) {
            base = parts[parts.length - 2];
        }
        var path = options[component + "Path"];
        if (path == null) {
            path = options.basePath;
        } else if (sep == "/") {
            component = sep = "";
        }
        if (path && path.slice(-1) != "/") {
            path += "/";
        }
        return path + component + sep + base + get("suffix");
    }

    function setModuleUrl(name, subst) {
        return options.$moduleUrls[name] = subst;
    }

    function loadModule(what, onLoad) {
        var doc = arguments.length <= 2 || arguments[2] === undefined ? document : arguments[2];

        var module;
        var moduleName;
        var moduleType;
        if (Array.isArray(what)) {
            moduleType = what[0];
            moduleName = what[1];
        } else {
            moduleName = what;
        }
        try {} catch (e) {}
        if (module && !$loading[moduleName]) return onLoad && onLoad(module);
        if (!$loading[moduleName]) {
            $loading[moduleName] = [];
        }
        $loading[moduleName].push(onLoad);
        if ($loading[moduleName].length > 1) return;
        var afterLoad = function afterLoad() {};
        if (!get("packaged")) {
            return afterLoad();
        }
        loadScript(moduleUrl(moduleName, moduleType), afterLoad, doc);
    }

    function init(packaged) {
        options.packaged = packaged || module.packaged;
        if (!global.document) return "";
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document['currentScript'] || document['_currentScript'];
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
            var script = scripts[i];
            var src = script.src || script.getAttribute("src");
            if (!src) continue;
            var attributes = script.attributes;
            for (var j = 0, l = attributes.length; j < l; j++) {
                var attr = attributes[j];
                if (attr.name.indexOf("data-ace-") === 0) {
                    scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
                }
            }
            var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
            if (m) {
                scriptUrl = m[1];
            }
        }
        if (scriptUrl) {
            scriptOptions['base'] = scriptOptions['base'] || scriptUrl;
            scriptOptions['packaged'] = true;
        }
        scriptOptions['basePath'] = scriptOptions['base'];
        scriptOptions['workerPath'] = scriptOptions['workerPath'] || scriptOptions['base'];
        scriptOptions['modePath'] = scriptOptions['modePath'] || scriptOptions['base'];
        scriptOptions['themePath'] = scriptOptions['themePath'] || scriptOptions['base'];
        delete scriptOptions['base'];
        for (var key in scriptOptions) if (typeof scriptOptions[key] !== "undefined") set(key, scriptOptions[key]);
    }

    function deHyphenate(str) {
        return str.replace(/-(.)/g, function (m, m1) {
            return m1.toUpperCase();
        });
    }

    function defineOptions(obj, path, options) {
        if (!obj.$options) {
            defaultOptions[path] = obj.$options = {};
        }
        _Object$keys(options).forEach(function (key) {
            var opt = options[key];
            if (typeof opt === "string") {
                opt = { forwardTo: opt };
            }
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt) {
                obj["$" + opt.name] = opt.initialValue;
            }
        });
        implement(obj, optionsProvider);
        return this;
    }

    function resetOptions(obj) {
        _Object$keys(obj.$options).forEach(function (key) {
            var opt = obj.$options[key];
            if ("value" in opt) {
                obj.setOption(key, opt.value);
            }
        });
    }

    function setDefaultValue(path, name, value) {
        var opts = defaultOptions[path] || (defaultOptions[path] = {});
        if (opts[name]) {
            if (opts.forwardTo) setDefaultValue(opts.forwardTo, name, value);else opts[name].value = value;
        }
    }

    function setDefaultValues(path, optionHash) {
        _Object$keys(optionHash).forEach(function (key) {
            setDefaultValue(path, key, optionHash[key]);
        });
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys["default"];
        }, function (_srcLibLangJs) {
            copyObject = _srcLibLangJs.copyObject;
        }, function (_srcLibOopJs) {
            implement = _srcLibOopJs.implement;
        }, function (_srcLibNetJs) {
            loadScript = _srcLibNetJs.loadScript;
        }],
        execute: function () {
            "use strict";

            _export("get", get);

            _export("set", set);

            _export("all", all);

            _export("moduleUrl", moduleUrl);

            _export("setModuleUrl", setModuleUrl);

            _export("loadModule", loadModule);

            _export("init", init);

            _export("defineOptions", defineOptions);

            _export("resetOptions", resetOptions);

            _export("setDefaultValue", setDefaultValue);

            _export("setDefaultValues", setDefaultValues);

            global = (function () {
                return this || typeof window !== 'undefined' && window;
            })();

            options = {
                packaged: false,
                workerPath: null,
                modePath: null,
                themePath: null,
                basePath: "",
                suffix: ".js",
                $moduleUrls: {}
            };
            $loading = {};

            _export("$loading", $loading);

            ;optionsProvider = {
                setOptions: function setOptions(optList) {
                    _Object$keys(optList).forEach(function (key) {
                        this.setOption(key, optList[key]);
                    }, this);
                },
                getOptions: function getOptions(optionNames) {
                    var result = {};
                    if (!optionNames) {
                        optionNames = _Object$keys(this.$options);
                    } else if (!Array.isArray(optionNames)) {
                        result = optionNames;
                        optionNames = _Object$keys(result);
                    }
                    optionNames.forEach(function (key) {
                        result[key] = this.getOption(key);
                    }, this);
                    return result;
                },
                setOption: function setOption(name, value) {
                    if (this["$" + name] === value) return;
                    var opt = this.$options[name];
                    if (!opt) {
                        if (typeof console != "undefined" && console.warn) console.warn('misspelled option "' + name + '"');
                        return undefined;
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
                    if (!opt.handlesSet) this["$" + name] = value;
                    if (opt && opt.set) opt.set.call(this, value);
                },
                getOption: function getOption(name) {
                    var opt = this.$options[name];
                    if (!opt) {
                        if (typeof console != "undefined" && console.warn) console.warn('misspelled option "' + name + '"');
                        return undefined;
                    }
                    if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
                    return opt && opt.get ? opt.get.call(this) : this["$" + name];
                }
            };
            defaultOptions = {};
        }
    };
});
System.register("src/layer/Cursor.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js"], function (_export) {
    var _createClass, _classCallCheck, addCssClass, createElement, removeCssClass, setCssClass, IE8, Cursor;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            addCssClass = _srcLibDomJs.addCssClass;
            createElement = _srcLibDomJs.createElement;
            removeCssClass = _srcLibDomJs.removeCssClass;
            setCssClass = _srcLibDomJs.setCssClass;
        }],
        execute: function () {
            "use strict";

            Cursor = (function () {
                function Cursor(container) {
                    _classCallCheck(this, Cursor);

                    this.isVisible = false;
                    this.isBlinking = true;
                    this.blinkInterval = 1000;
                    this.smoothBlinking = false;
                    this.cursors = [];
                    this.$padding = 0;
                    this.element = createElement("div");
                    this.element.className = "ace_layer ace_cursor-layer";
                    container.appendChild(this.element);
                    if (IE8 === void 0) {
                        IE8 = "opacity" in this.element;
                    }
                    this.cursor = this.addCursor();
                    addCssClass(this.element, "ace_hidden-cursors");
                    this.$updateCursors = this.$updateVisibility.bind(this);
                }

                _createClass(Cursor, [{
                    key: "$updateVisibility",
                    value: function $updateVisibility(visible) {
                        var cursors = this.cursors;
                        for (var i = cursors.length; i--;) {
                            cursors[i].style.visibility = visible ? "" : "hidden";
                        }
                    }
                }, {
                    key: "$updateOpacity",
                    value: function $updateOpacity(opaque) {
                        var cursors = this.cursors;
                        for (var i = cursors.length; i--;) {
                            cursors[i].style.opacity = opaque ? "" : "0";
                        }
                    }
                }, {
                    key: "setPadding",
                    value: function setPadding(padding) {
                        if (typeof padding === 'number') {
                            this.$padding = padding;
                        } else {
                            throw new TypeError("padding must be a number");
                        }
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        this.session = session;
                    }
                }, {
                    key: "setBlinking",
                    value: function setBlinking(blinking) {
                        if (blinking !== this.isBlinking) {
                            this.isBlinking = blinking;
                            this.restartTimer();
                        }
                    }
                }, {
                    key: "setBlinkInterval",
                    value: function setBlinkInterval(blinkInterval) {
                        if (blinkInterval !== this.blinkInterval) {
                            this.blinkInterval = blinkInterval;
                            this.restartTimer();
                        }
                    }
                }, {
                    key: "setSmoothBlinking",
                    value: function setSmoothBlinking(smoothBlinking) {
                        if (smoothBlinking != this.smoothBlinking && !IE8) {
                            this.smoothBlinking = smoothBlinking;
                            setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                            this.$updateCursors(true);
                            this.$updateCursors = (smoothBlinking ? this.$updateOpacity : this.$updateVisibility).bind(this);
                            this.restartTimer();
                        }
                    }
                }, {
                    key: "addCursor",
                    value: function addCursor() {
                        var cursor = createElement("div");
                        cursor.className = "ace_cursor";
                        this.element.appendChild(cursor);
                        this.cursors.push(cursor);
                        return cursor;
                    }
                }, {
                    key: "removeCursor",
                    value: function removeCursor() {
                        if (this.cursors.length > 1) {
                            var cursor = this.cursors.pop();
                            cursor.parentNode.removeChild(cursor);
                            return cursor;
                        }
                    }
                }, {
                    key: "hideCursor",
                    value: function hideCursor() {
                        this.isVisible = false;
                        addCssClass(this.element, "ace_hidden-cursors");
                        this.restartTimer();
                    }
                }, {
                    key: "showCursor",
                    value: function showCursor() {
                        this.isVisible = true;
                        removeCssClass(this.element, "ace_hidden-cursors");
                        this.restartTimer();
                    }
                }, {
                    key: "restartTimer",
                    value: function restartTimer() {
                        var update = this.$updateCursors;
                        clearInterval(this.intervalId);
                        clearTimeout(this.timeoutId);
                        if (this.smoothBlinking) {
                            removeCssClass(this.element, "ace_smooth-blinking");
                        }
                        update(true);
                        if (!this.isBlinking || !this.blinkInterval || !this.isVisible) return;
                        if (this.smoothBlinking) {
                            setTimeout((function () {
                                addCssClass(this.element, "ace_smooth-blinking");
                            }).bind(this));
                        }
                        var blink = (function () {
                            this.timeoutId = setTimeout(function () {
                                update(false);
                            }, 0.6 * this.blinkInterval);
                        }).bind(this);
                        this.intervalId = setInterval(function () {
                            update(true);
                            blink();
                        }, this.blinkInterval);
                        blink();
                    }
                }, {
                    key: "getPixelPosition",
                    value: function getPixelPosition(position, onScreen) {
                        if (!this.config || !this.session) {
                            return { left: 0, top: 0 };
                        }
                        if (!position) {
                            position = this.session.getSelection().getCursor();
                        }
                        var pos = this.session.documentToScreenPosition(position.row, position.column);
                        var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
                        var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
                        return { left: cursorLeft, top: cursorTop };
                    }
                }, {
                    key: "update",
                    value: function update(config) {
                        this.config = config;
                        var selections = this.session['$selectionMarkers'];
                        var i = 0,
                            cursorIndex = 0;
                        if (selections === undefined || selections.length === 0) {
                            selections = [{ cursor: null }];
                        }
                        for (var i = 0, n = selections.length; i < n; i++) {
                            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                            if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
                                continue;
                            }
                            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
                            style.left = pixelPos.left + "px";
                            style.top = pixelPos.top + "px";
                            style.width = config.characterWidth + "px";
                            style.height = config.lineHeight + "px";
                        }
                        while (this.cursors.length > cursorIndex) {
                            this.removeCursor();
                        }
                        var overwrite = this.session.getOverwrite();
                        this.$setOverwrite(overwrite);
                        this.$pixelPos = pixelPos;
                        this.restartTimer();
                    }
                }, {
                    key: "$setOverwrite",
                    value: function $setOverwrite(overwrite) {
                        if (overwrite !== this.overwrite) {
                            this.overwrite = overwrite;
                            if (overwrite) addCssClass(this.element, "ace_overwrite-cursors");else removeCssClass(this.element, "ace_overwrite-cursors");
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        clearInterval(this.intervalId);
                        clearTimeout(this.timeoutId);
                    }
                }]);

                return Cursor;
            })();

            _export("default", Cursor);
        }
    };
});
System.register("src/layer/FontMetrics.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/object/create", "src/lib/dom.js", "src/lib/lang.js", "src/lib/useragent.js", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, _Object$create, createElement, stringRepeat, isIE, EventEmitterClass, CHAR_COUNT, FontMetrics;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate["default"];
        }, function (_srcLibDomJs) {
            createElement = _srcLibDomJs.createElement;
        }, function (_srcLibLangJs) {
            stringRepeat = _srcLibLangJs.stringRepeat;
        }, function (_srcLibUseragentJs) {
            isIE = _srcLibUseragentJs.isIE;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";
            CHAR_COUNT = 0;

            FontMetrics = (function () {
                function FontMetrics(container, pollingInterval) {
                    _classCallCheck(this, FontMetrics);

                    this.$characterSize = { width: 0, height: 0 };
                    this.eventBus = new EventEmitterClass(this);
                    this.el = createElement("div");
                    this.$setMeasureNodeStyles(this.el.style, true);
                    this.$main = createElement("div");
                    this.$setMeasureNodeStyles(this.$main.style);
                    this.$measureNode = createElement("div");
                    this.$setMeasureNodeStyles(this.$measureNode.style);
                    this.el.appendChild(this.$main);
                    this.el.appendChild(this.$measureNode);
                    container.appendChild(this.el);
                    if (!CHAR_COUNT) {
                        this.$testFractionalRect();
                    }
                    this.$measureNode.innerHTML = stringRepeat("X", CHAR_COUNT);
                    this.$characterSize = { width: 0, height: 0 };
                    this.checkForSizeChanges();
                }

                _createClass(FontMetrics, [{
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "$testFractionalRect",
                    value: function $testFractionalRect() {
                        var el = createElement("div");
                        this.$setMeasureNodeStyles(el.style);
                        el.style.width = "0.2px";
                        document.documentElement.appendChild(el);
                        var w = el.getBoundingClientRect().width;
                        if (w > 0 && w < 1) {
                            CHAR_COUNT = 1;
                        } else {
                            CHAR_COUNT = 100;
                        }
                        el.parentNode.removeChild(el);
                    }
                }, {
                    key: "$setMeasureNodeStyles",
                    value: function $setMeasureNodeStyles(style, isRoot) {
                        style.width = style.height = "auto";
                        style.left = style.top = "-100px";
                        style.visibility = "hidden";
                        style.position = "fixed";
                        style.whiteSpace = "pre";
                        if (isIE < 8) {
                            style["font-family"] = "inherit";
                        } else {
                            style.font = "inherit";
                        }
                        style.overflow = isRoot ? "hidden" : "visible";
                    }
                }, {
                    key: "checkForSizeChanges",
                    value: function checkForSizeChanges() {
                        var size = this.$measureSizes();
                        if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                            this.$measureNode.style.fontWeight = "bold";
                            var boldSize = this.$measureSizes();
                            this.$measureNode.style.fontWeight = "";
                            this.$characterSize = size;
                            this.charSizes = _Object$create(null);
                            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                            this.eventBus._emit("changeCharacterSize", { data: size });
                        }
                    }
                }, {
                    key: "$pollSizeChanges",
                    value: function $pollSizeChanges() {
                        if (this.$pollSizeChangesTimer) {
                            return this.$pollSizeChangesTimer;
                        }
                        var self = this;
                        return this.$pollSizeChangesTimer = setInterval(function () {
                            self.checkForSizeChanges();
                        }, 500);
                    }
                }, {
                    key: "setPolling",
                    value: function setPolling(val) {
                        if (val) {
                            this.$pollSizeChanges();
                        } else {
                            if (this.$pollSizeChangesTimer) {
                                this.$pollSizeChangesTimer;
                            }
                        }
                    }
                }, {
                    key: "$measureSizes",
                    value: function $measureSizes() {
                        if (CHAR_COUNT === 1) {
                            var rect = null;
                            try {
                                rect = this.$measureNode.getBoundingClientRect();
                            } catch (e) {
                                rect = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 };
                            }
                            var size = { height: rect.height, width: rect.width };
                        } else {
                            var size = { height: this.$measureNode.clientHeight, width: this.$measureNode.clientWidth / CHAR_COUNT };
                        }
                        if (size.width === 0 || size.height === 0) {
                            return null;
                        }
                        return size;
                    }
                }, {
                    key: "$measureCharWidth",
                    value: function $measureCharWidth(ch) {
                        this.$main.innerHTML = stringRepeat(ch, CHAR_COUNT);
                        var rect = this.$main.getBoundingClientRect();
                        return rect.width / CHAR_COUNT;
                    }
                }, {
                    key: "getCharacterWidth",
                    value: function getCharacterWidth(ch) {
                        var w = this.charSizes[ch];
                        if (w === undefined) {
                            this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
                        }
                        return w;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        clearInterval(this.$pollSizeChangesTimer);
                        if (this.el && this.el.parentNode) {
                            this.el.parentNode.removeChild(this.el);
                        }
                    }
                }]);

                return FontMetrics;
            })();

            _export("default", FontMetrics);
        }
    };
});
System.register("src/layer/Gutter.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js", "src/lib/lang.js", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, addCssClass, createElement, removeCssClass, escapeHTML, EventEmitterClass, Gutter;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            addCssClass = _srcLibDomJs.addCssClass;
            createElement = _srcLibDomJs.createElement;
            removeCssClass = _srcLibDomJs.removeCssClass;
        }, function (_srcLibLangJs) {
            escapeHTML = _srcLibLangJs.escapeHTML;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";

            Gutter = (function () {
                function Gutter(container) {
                    _classCallCheck(this, Gutter);

                    this.gutterWidth = 0;
                    this.$annotations = [];
                    this.$cells = [];
                    this.$fixedWidth = false;
                    this.$showLineNumbers = true;
                    this.$renderer = "";
                    this.$showFoldWidgets = true;
                    this.eventBus = new EventEmitterClass(this);
                    this.element = createElement("div");
                    this.element.className = "ace_layer ace_gutter-layer";
                    container.appendChild(this.element);
                    this.setShowFoldWidgets(this.$showFoldWidgets);
                    this.$updateAnnotations = this.$updateAnnotations.bind(this);
                }

                _createClass(Gutter, [{
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        if (this.session) {
                            this.session.off("change", this.$updateAnnotations);
                        }
                        this.session = session;
                        session.on("change", this.$updateAnnotations);
                    }
                }, {
                    key: "setAnnotations",
                    value: function setAnnotations(annotations) {
                        this.$annotations = [];
                        for (var i = 0; i < annotations.length; i++) {
                            var annotation = annotations[i];
                            var row = annotation.row;
                            var rowInfo = this.$annotations[row];
                            if (!rowInfo) {
                                rowInfo = this.$annotations[row] = { text: [] };
                            }
                            var annoText = annotation.text;
                            annoText = annoText ? escapeHTML(annoText) : annotation.html || "";
                            if (rowInfo.text.indexOf(annoText) === -1) rowInfo.text.push(annoText);
                            var type = annotation.type;
                            if (type === "error") rowInfo.className = " ace_error";else if (type === "warning" && rowInfo.className != " ace_error") rowInfo.className = " ace_warning";else if (type === "info" && !rowInfo.className) rowInfo.className = " ace_info";
                        }
                    }
                }, {
                    key: "$updateAnnotations",
                    value: function $updateAnnotations(e, session) {
                        if (!this.$annotations.length) return;
                        var delta = e.data;
                        var range = delta.range;
                        var firstRow = range.start.row;
                        var len = range.end.row - firstRow;
                        if (len === 0) {} else if (delta.action === "removeText" || delta.action === "removeLines") {
                            this.$annotations.splice(firstRow, len + 1, null);
                        } else {
                            var args = new Array(len + 1);
                            args.unshift(firstRow, 1);
                            this.$annotations.splice.apply(this.$annotations, args);
                        }
                    }
                }, {
                    key: "update",
                    value: function update(config) {
                        var session = this.session;
                        var firstRow = config.firstRow;
                        var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
                        var fold = session.getNextFoldLine(firstRow);
                        var foldStart = fold ? fold.start.row : Infinity;
                        var foldWidgets = this.$showFoldWidgets && session['foldWidgets'];
                        var breakpoints = session.$breakpoints;
                        var decorations = session.$decorations;
                        var firstLineNumber = session['$firstLineNumber'];
                        var lastLineNumber = 0;
                        var gutterRenderer = session['gutterRenderer'] || this.$renderer;
                        var cell = null;
                        var index = -1;
                        var row = firstRow;
                        while (true) {
                            if (row > foldStart) {
                                row = fold.end.row + 1;
                                fold = session.getNextFoldLine(row, fold);
                                foldStart = fold ? fold.start.row : Infinity;
                            }
                            if (row > lastRow) {
                                while (this.$cells.length > index + 1) {
                                    cell = this.$cells.pop();
                                    this.element.removeChild(cell.element);
                                }
                                break;
                            }
                            cell = this.$cells[++index];
                            if (!cell) {
                                cell = { element: null, textNode: null, foldWidget: null };
                                cell.element = createElement("div");
                                cell.textNode = document.createTextNode('');
                                cell.element.appendChild(cell.textNode);
                                this.element.appendChild(cell.element);
                                this.$cells[index] = cell;
                            }
                            var className = "ace_gutter-cell ";
                            if (breakpoints[row]) className += breakpoints[row];
                            if (decorations[row]) className += decorations[row];
                            if (this.$annotations[row]) className += this.$annotations[row].className;
                            if (cell.element.className != className) cell.element.className = className;
                            var height = session.getRowLength(row) * config.lineHeight + "px";
                            if (height != cell.element.style.height) cell.element.style.height = height;
                            if (foldWidgets) {
                                var c = foldWidgets[row];
                                if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
                            }
                            if (c) {
                                if (!cell.foldWidget) {
                                    cell.foldWidget = createElement("span");
                                    cell.element.appendChild(cell.foldWidget);
                                }
                                var className = "ace_fold-widget ace_" + c;
                                if (c == "start" && row == foldStart && row < fold.end.row) className += " ace_closed";else className += " ace_open";
                                if (cell.foldWidget.className != className) cell.foldWidget.className = className;
                                var height = config.lineHeight + "px";
                                if (cell.foldWidget.style.height != height) cell.foldWidget.style.height = height;
                            } else {
                                if (cell.foldWidget) {
                                    cell.element.removeChild(cell.foldWidget);
                                    cell.foldWidget = null;
                                }
                            }
                            var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
                            if (text != cell.textNode.data) cell.textNode.data = text;
                            row++;
                        }
                        this.element.style.height = config.minHeight + "px";
                        if (this.$fixedWidth || session.$useWrapMode) lastLineNumber = session.getLength() + firstLineNumber;
                        var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
                        var padding = this.$padding || this.$computePadding();
                        gutterWidth += padding.left + padding.right;
                        if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                            this.gutterWidth = gutterWidth;
                            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                            this.eventBus._emit("changeGutterWidth", gutterWidth);
                        }
                    }
                }, {
                    key: "setShowLineNumbers",
                    value: function setShowLineNumbers(show) {
                        this.$renderer = !show && {
                            getWidth: function getWidth() {
                                return "";
                            },
                            getText: function getText() {
                                return "";
                            }
                        };
                    }
                }, {
                    key: "getShowLineNumbers",
                    value: function getShowLineNumbers() {
                        return this.$showLineNumbers;
                    }
                }, {
                    key: "setShowFoldWidgets",
                    value: function setShowFoldWidgets(show) {
                        if (show) addCssClass(this.element, "ace_folding-enabled");else removeCssClass(this.element, "ace_folding-enabled");
                        this.$showFoldWidgets = show;
                        this.$padding = null;
                    }
                }, {
                    key: "getShowFoldWidgets",
                    value: function getShowFoldWidgets() {
                        return this.$showFoldWidgets;
                    }
                }, {
                    key: "$computePadding",
                    value: function $computePadding() {
                        if (!this.element.firstChild) {
                            return { left: 0, right: 0 };
                        }
                        var style = window.getComputedStyle(this.element.firstChild);
                        this.$padding = {};
                        this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
                        this.$padding.right = parseInt(style.paddingRight) || 0;
                        return this.$padding;
                    }
                }, {
                    key: "getRegion",
                    value: function getRegion(point) {
                        var padding = this.$padding || this.$computePadding();
                        var rect = this.element.getBoundingClientRect();
                        if (point.clientX < padding.left + rect.left) {
                            return "markers";
                        }
                        if (this.$showFoldWidgets && point.clientX > rect.right - padding.right) {
                            return "foldWidgets";
                        }
                    }
                }]);

                return Gutter;
            })();

            _export("default", Gutter);
        }
    };
});
System.register("src/layer/Marker.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, createElement, Range, Marker;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            createElement = _srcLibDomJs.createElement;
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            Marker = (function () {
                function Marker(container) {
                    _classCallCheck(this, Marker);

                    this.$padding = 0;
                    this.element = createElement("div");
                    this.element.className = "ace_layer ace_marker-layer";
                    container.appendChild(this.element);
                }

                _createClass(Marker, [{
                    key: "setPadding",
                    value: function setPadding(padding) {
                        this.$padding = padding;
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        this.session = session;
                    }
                }, {
                    key: "setMarkers",
                    value: function setMarkers(markers) {
                        this.markers = markers;
                    }
                }, {
                    key: "update",
                    value: function update(config) {
                        var config = config || this.config;
                        if (!config) {
                            return;
                        }
                        this.config = config;
                        var html = [];
                        for (var id in this.markers) {
                            var marker = this.markers[id];
                            if (!marker.range) {
                                marker.update(html, this, this.session, config);
                                continue;
                            }
                            var range = marker.range.clipRows(config.firstRow, config.lastRow);
                            if (range.isEmpty()) continue;
                            range = this.session.documentToScreenRange(range);
                            if (marker.renderer) {
                                var top = this.$getTop(range.start.row, config);
                                var left = this.$padding + range.start.column * config.characterWidth;
                                marker.renderer(html, range, left, top, config);
                            } else if (marker.type === "fullLine") {
                                this.drawFullLineMarker(html, range, marker.clazz, config);
                            } else if (marker.type === "screenLine") {
                                this.drawScreenLineMarker(html, range, marker.clazz, config);
                            } else if (range.isMultiLine()) {
                                if (marker.type === "text") this.drawTextMarker(html, range, marker.clazz, config);else this.drawMultiLineMarker(html, range, marker.clazz, config);
                            } else {
                                this.drawSingleLineMarker(html, range, marker.clazz + " ace_start ace_br15", config);
                            }
                        }
                        this.element.innerHTML = html.join("");
                    }
                }, {
                    key: "$getTop",
                    value: function $getTop(row, layerConfig) {
                        return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
                    }
                }, {
                    key: "drawTextMarker",
                    value: function drawTextMarker(stringBuilder, range, clazz, layerConfig, extraStyle) {
                        function getBorderClass(tl, tr, br, bl) {
                            return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
                        }
                        var session = this.session;
                        var start = range.start.row;
                        var end = range.end.row;
                        var row = start;
                        var prev = 0;
                        var curr = 0;
                        var next = session.getScreenLastRowColumn(row);
                        var lineRange = new Range(row, range.start.column, row, curr);
                        for (; row <= end; row++) {
                            lineRange.start.row = lineRange.end.row = row;
                            lineRange.start.column = row === start ? range.start.column : session.getRowWrapIndent(row);
                            lineRange.end.column = next;
                            prev = curr;
                            curr = next;
                            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row === end ? 0 : range.end.column;
                            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row === start ? " ace_start" : "") + " ace_br" + getBorderClass(row === start || row === start + 1 && range.start.column !== 0, prev < curr, curr > next, row === end), layerConfig, row == end ? 0 : 1, extraStyle);
                        }
                    }
                }, {
                    key: "drawMultiLineMarker",
                    value: function drawMultiLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                        var padding = this.$padding;
                        var height = config.lineHeight;
                        var top = this.$getTop(range.start.row, config);
                        var left = padding + range.start.column * config.characterWidth;
                        extraStyle = extraStyle || "";
                        stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
                        top = this.$getTop(range.end.row, config);
                        var width = range.end.column * config.characterWidth;
                        stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                        height = (range.end.row - range.start.row - 1) * config.lineHeight;
                        if (height < 0) {
                            return;
                        }
                        top = this.$getTop(range.start.row + 1, config);
                        var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
                        stringBuilder.push("<div class='", clazz, radiusClass ? " ace_br" + radiusClass : "", "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
                    }
                }, {
                    key: "drawSingleLineMarker",
                    value: function drawSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle) {
                        var height = config.lineHeight;
                        var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
                        var top = this.$getTop(range.start.row, config);
                        var left = this.$padding + range.start.column * config.characterWidth;
                        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
                    }
                }, {
                    key: "drawFullLineMarker",
                    value: function drawFullLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                        var top = this.$getTop(range.start.row, config);
                        var height = config.lineHeight;
                        if (range.start.row !== range.end.row) {
                            height += this.$getTop(range.end.row, config) - top;
                        }
                        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                    }
                }, {
                    key: "drawScreenLineMarker",
                    value: function drawScreenLineMarker(stringBuilder, range, clazz, config, extraStyle) {
                        var top = this.$getTop(range.start.row, config);
                        var height = config.lineHeight;
                        stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
                    }
                }]);

                return Marker;
            })();

            _export("default", Marker);
        }
    };
});
System.register("src/layer/Text.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js", "src/lib/lang.js", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, createElement, stringRepeat, EventEmitterClass, Text;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            createElement = _srcLibDomJs.createElement;
        }, function (_srcLibLangJs) {
            stringRepeat = _srcLibLangJs.stringRepeat;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";

            Text = (function () {
                function Text(container) {
                    _classCallCheck(this, Text);

                    this.element = createElement("div");
                    this.$padding = 0;
                    this.EOF_CHAR = "\xB6";
                    this.EOL_CHAR_LF = "\xAC";
                    this.EOL_CHAR_CRLF = "\xa4";
                    this.TAB_CHAR = "→";
                    this.SPACE_CHAR = "\xB7";
                    this.showInvisibles = false;
                    this.displayIndentGuides = true;
                    this.$tabStrings = [];
                    this.$textToken = { "text": true, "rparen": true, "lparen": true };
                    this.eventBus = new EventEmitterClass(this);
                    this.element.className = "ace_layer ace_text-layer";
                    container.appendChild(this.element);
                    this.EOL_CHAR = this.EOL_CHAR_LF;
                }

                _createClass(Text, [{
                    key: "updateEolChar",
                    value: function updateEolChar() {
                        var EOL_CHAR = this.session.doc.getNewLineCharacter() === "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
                        if (this.EOL_CHAR != EOL_CHAR) {
                            this.EOL_CHAR = EOL_CHAR;
                            return true;
                        } else {
                            return false;
                        }
                    }
                }, {
                    key: "setPadding",
                    value: function setPadding(padding) {
                        this.$padding = padding;
                        this.element.style.padding = "0 " + padding + "px";
                    }
                }, {
                    key: "getLineHeight",
                    value: function getLineHeight() {
                        return this.$fontMetrics.$characterSize.height || 0;
                    }
                }, {
                    key: "getCharacterWidth",
                    value: function getCharacterWidth() {
                        return this.$fontMetrics.$characterSize.width || 0;
                    }
                }, {
                    key: "$setFontMetrics",
                    value: function $setFontMetrics(measure) {
                        var _this = this;

                        this.$fontMetrics = measure;
                        this.$fontMetrics.on("changeCharacterSize", function (e) {
                            _this.eventBus._signal("changeCharacterSize", e);
                        });
                        this.$pollSizeChanges();
                    }
                }, {
                    key: "checkForSizeChanges",
                    value: function checkForSizeChanges() {
                        this.$fontMetrics.checkForSizeChanges();
                    }
                }, {
                    key: "$pollSizeChanges",
                    value: function $pollSizeChanges() {
                        return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        this.session = session;
                        this.$computeTabString();
                    }
                }, {
                    key: "setShowInvisibles",
                    value: function setShowInvisibles(showInvisibles) {
                        if (this.showInvisibles === showInvisibles) {
                            return false;
                        } else {
                            this.showInvisibles = showInvisibles;
                            this.$computeTabString();
                            return true;
                        }
                    }
                }, {
                    key: "setDisplayIndentGuides",
                    value: function setDisplayIndentGuides(displayIndentGuides) {
                        if (this.displayIndentGuides === displayIndentGuides) {
                            return false;
                        } else {
                            this.displayIndentGuides = displayIndentGuides;
                            this.$computeTabString();
                            return true;
                        }
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "onChangeTabSize",
                    value: function onChangeTabSize() {
                        this.$computeTabString();
                    }
                }, {
                    key: "$computeTabString",
                    value: function $computeTabString() {
                        var tabSize = this.session.getTabSize();
                        this.tabSize = tabSize;
                        var tabStr = this.$tabStrings = ["0"];
                        for (var i = 1; i < tabSize + 1; i++) {
                            if (this.showInvisibles) {
                                tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + this.TAB_CHAR + stringRepeat("\xa0", i - 1) + "</span>");
                            } else {
                                tabStr.push(stringRepeat("\xa0", i));
                            }
                        }
                        if (this.displayIndentGuides) {
                            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                            var className = "ace_indent-guide";
                            var spaceClass = "";
                            var tabClass = "";
                            if (this.showInvisibles) {
                                className += " ace_invisible";
                                spaceClass = " ace_invisible_space";
                                tabClass = " ace_invisible_tab";
                                var spaceContent = stringRepeat(this.SPACE_CHAR, this.tabSize);
                                var tabContent = this.TAB_CHAR + stringRepeat("\xa0", this.tabSize - 1);
                            } else {
                                var spaceContent = stringRepeat("\xa0", this.tabSize);
                                var tabContent = spaceContent;
                            }
                            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
                            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
                        }
                    }
                }, {
                    key: "updateLines",
                    value: function updateLines(config, firstRow, lastRow) {
                        if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
                            this.scrollLines(config);
                        }
                        this.config = config;
                        var first = Math.max(firstRow, config.firstRow);
                        var last = Math.min(lastRow, config.lastRow);
                        var lineElements = this.element.childNodes;
                        var lineElementsIdx = 0;
                        for (var row = config.firstRow; row < first; row++) {
                            var foldLine = this.session.getFoldLine(row);
                            if (foldLine) {
                                if (foldLine.containsRow(first)) {
                                    first = foldLine.start.row;
                                    break;
                                } else {
                                    row = foldLine.end.row;
                                }
                            }
                            lineElementsIdx++;
                        }
                        var row = first;
                        var foldLine = this.session.getNextFoldLine(row);
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        while (true) {
                            if (row > foldStart) {
                                row = foldLine.end.row + 1;
                                foldLine = this.session.getNextFoldLine(row, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                            if (row > last) break;
                            var lineElement = lineElements[lineElementsIdx++];
                            if (lineElement) {
                                var html = [];
                                this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
                                lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                                lineElement.innerHTML = html.join("");
                            }
                            row++;
                        }
                    }
                }, {
                    key: "scrollLines",
                    value: function scrollLines(config) {
                        var oldConfig = this.config;
                        this.config = config;
                        if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);
                        if (config.lastRow < oldConfig.firstRow) return this.update(config);
                        var el = this.element;
                        if (oldConfig.firstRow < config.firstRow) {
                            for (var row = this.session['getFoldedRowCount'](oldConfig.firstRow, config.firstRow - 1); row > 0; row--) {
                                el.removeChild(el.firstChild);
                            }
                        }
                        if (oldConfig.lastRow > config.lastRow) {
                            for (var row = this.session['getFoldedRowCount'](config.lastRow + 1, oldConfig.lastRow); row > 0; row--) {
                                el.removeChild(el.lastChild);
                            }
                        }
                        if (config.firstRow < oldConfig.firstRow) {
                            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
                            if (el.firstChild) el.insertBefore(fragment, el.firstChild);else el.appendChild(fragment);
                        }
                        if (config.lastRow > oldConfig.lastRow) {
                            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
                            el.appendChild(fragment);
                        }
                    }
                }, {
                    key: "$renderLinesFragment",
                    value: function $renderLinesFragment(config, firstRow, lastRow) {
                        var fragment = this.element.ownerDocument.createDocumentFragment();
                        var row = firstRow;
                        var foldLine = this.session.getNextFoldLine(row);
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        while (true) {
                            if (row > foldStart) {
                                row = foldLine.end.row + 1;
                                foldLine = this.session.getNextFoldLine(row, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                            if (row > lastRow) break;
                            var container = createElement("div");
                            var html = [];
                            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                            container.innerHTML = html.join("");
                            if (this.$useLineGroups()) {
                                container.className = 'ace_line_group';
                                fragment.appendChild(container);
                                container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
                            } else {
                                while (container.firstChild) fragment.appendChild(container.firstChild);
                            }
                            row++;
                        }
                        return fragment;
                    }
                }, {
                    key: "update",
                    value: function update(config) {
                        this.config = config;
                        var html = [];
                        var firstRow = config.firstRow,
                            lastRow = config.lastRow;
                        var row = firstRow;
                        var foldLine = this.session.getNextFoldLine(row);
                        var foldStart = foldLine ? foldLine.start.row : Infinity;
                        while (true) {
                            if (row > foldStart) {
                                row = foldLine.end.row + 1;
                                foldLine = this.session.getNextFoldLine(row, foldLine);
                                foldStart = foldLine ? foldLine.start.row : Infinity;
                            }
                            if (row > lastRow) break;
                            if (this.$useLineGroups()) html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
                            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
                            if (this.$useLineGroups()) html.push("</div>");
                            row++;
                        }
                        this.element.innerHTML = html.join("");
                    }
                }, {
                    key: "$renderToken",
                    value: function $renderToken(stringBuilder, screenColumn, token, value) {
                        var self = this;
                        var replaceReg = /\t|&|<|( +)|([\x00-\x1f\x80-\xa0\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
                        var replaceFunc = function replaceFunc(c, a, b, tabIdx, idx4) {
                            if (a) {
                                return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : stringRepeat("\xa0", c.length);
                            } else if (c == "&") {
                                return "&#38;";
                            } else if (c == "<") {
                                return "&#60;";
                            } else if (c == "\t") {
                                var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
                                screenColumn += tabSize - 1;
                                return self.$tabStrings[tabSize];
                            } else if (c == "　") {
                                var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                                var space = self.showInvisibles ? self.SPACE_CHAR : "";
                                screenColumn += 1;
                                return "<span class='" + classToUse + "' style='width:" + self.config.characterWidth * 2 + "px'>" + space + "</span>";
                            } else if (b) {
                                return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
                            } else {
                                screenColumn += 1;
                                return "<span class='ace_cjk' style='width:" + self.config.characterWidth * 2 + "px'>" + c + "</span>";
                            }
                        };
                        var output = value.replace(replaceReg, replaceFunc);
                        if (!this.$textToken[token.type]) {
                            var classes = "ace_" + token.type.replace(/\./g, " ace_");
                            var style = "";
                            if (token.type == "fold") style = " style='width:" + token.value.length * this.config.characterWidth + "px;' ";
                            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
                        } else {
                            stringBuilder.push(output);
                        }
                        return screenColumn + value.length;
                    }
                }, {
                    key: "renderIndentGuide",
                    value: function renderIndentGuide(stringBuilder, value, max) {
                        var cols = value.search(this.$indentGuideRe);
                        if (cols <= 0 || cols >= max) return value;
                        if (value[0] === " ") {
                            cols -= cols % this.tabSize;
                            stringBuilder.push(stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
                            return value.substr(cols);
                        } else if (value[0] == "\t") {
                            stringBuilder.push(stringRepeat(this.$tabStrings["\t"], cols));
                            return value.substr(cols);
                        }
                        return value;
                    }
                }, {
                    key: "$renderWrappedLine",
                    value: function $renderWrappedLine(stringBuilder, tokens, splits, onlyContents) {
                        var chars = 0;
                        var split = 0;
                        var splitChars = splits[0];
                        var screenColumn = 0;
                        for (var i = 0; i < tokens.length; i++) {
                            var token = tokens[i];
                            var value = token.value;
                            if (i == 0 && this.displayIndentGuides) {
                                chars = value.length;
                                value = this.renderIndentGuide(stringBuilder, value, splitChars);
                                if (!value) continue;
                                chars -= value.length;
                            }
                            if (chars + value.length < splitChars) {
                                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                                chars += value.length;
                            } else {
                                while (chars + value.length >= splitChars) {
                                    screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                                    value = value.substring(splitChars - chars);
                                    chars = splitChars;
                                    if (!onlyContents) {
                                        stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                                    }
                                    split++;
                                    screenColumn = 0;
                                    splitChars = splits[split] || Number.MAX_VALUE;
                                }
                                if (value.length != 0) {
                                    chars += value.length;
                                    screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                                }
                            }
                        }
                    }
                }, {
                    key: "$renderSimpleLine",
                    value: function $renderSimpleLine(stringBuilder, tokens) {
                        var screenColumn = 0;
                        var token = tokens[0];
                        var value = token.value;
                        if (this.displayIndentGuides) value = this.renderIndentGuide(stringBuilder, value);
                        if (value) screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                        for (var i = 1; i < tokens.length; i++) {
                            token = tokens[i];
                            value = token.value;
                            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
                        }
                    }
                }, {
                    key: "$renderLine",
                    value: function $renderLine(stringBuilder, row, onlyContents, foldLine) {
                        if (!foldLine && foldLine != false) {
                            foldLine = this.session.getFoldLine(row);
                        }
                        if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);else var tokens = this.session.getTokens(row);
                        if (!onlyContents) {
                            stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
                        }
                        if (tokens && tokens.length) {
                            var splits = this.session.getRowSplitData(row);
                            if (splits && splits.length) this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);else this.$renderSimpleLine(stringBuilder, tokens);
                        }
                        if (this.showInvisibles) {
                            if (foldLine) row = foldLine.end.row;
                            stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
                        }
                        if (!onlyContents) stringBuilder.push("</div>");
                    }
                }, {
                    key: "$getFoldLineTokens",
                    value: function $getFoldLineTokens(row, foldLine) {
                        var session = this.session;
                        var renderTokens = [];
                        function addTokens(tokens, from, to) {
                            var idx = 0,
                                col = 0;
                            while (col + tokens[idx].value.length < from) {
                                col += tokens[idx].value.length;
                                idx++;
                                if (idx == tokens.length) return;
                            }
                            if (col != from) {
                                var value = tokens[idx].value.substring(from - col);
                                if (value.length > to - from) value = value.substring(0, to - from);
                                renderTokens.push({
                                    type: tokens[idx].type,
                                    value: value
                                });
                                col = from + value.length;
                                idx += 1;
                            }
                            while (col < to && idx < tokens.length) {
                                var value = tokens[idx].value;
                                if (value.length + col > to) {
                                    renderTokens.push({
                                        type: tokens[idx].type,
                                        value: value.substring(0, to - col)
                                    });
                                } else renderTokens.push(tokens[idx]);
                                col += value.length;
                                idx += 1;
                            }
                        }
                        var tokens = session.getTokens(row);
                        foldLine.walk(function (placeholder, row, column, lastColumn, isNewRow) {
                            if (placeholder != null) {
                                renderTokens.push({
                                    type: "fold",
                                    value: placeholder
                                });
                            } else {
                                if (isNewRow) tokens = session.getTokens(row);
                                if (tokens.length) addTokens(tokens, lastColumn, column);
                            }
                        }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
                        return renderTokens;
                    }
                }, {
                    key: "$useLineGroups",
                    value: function $useLineGroups() {
                        return this.session.getUseWrapMode();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        clearInterval(this.$pollSizeChangesTimer);
                        if (this.$measureNode) {
                            this.$measureNode.parentNode.removeChild(this.$measureNode);
                        }
                        delete this.$measureNode;
                    }
                }]);

                return Text;
            })();

            _export("default", Text);
        }
    };
});
System.register("src/VScrollBar.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/event.js", "src/ScrollBar.js", "src/lib/dom.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, addListener, ScrollBar, scrollbarWidth, VScrollBar;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibEventJs) {
            addListener = _srcLibEventJs.addListener;
        }, function (_srcScrollBarJs) {
            ScrollBar = _srcScrollBarJs["default"];
        }, function (_srcLibDomJs) {
            scrollbarWidth = _srcLibDomJs.scrollbarWidth;
        }],
        execute: function () {
            "use strict";

            VScrollBar = (function (_ScrollBar) {
                _inherits(VScrollBar, _ScrollBar);

                function VScrollBar(parent, renderer) {
                    _classCallCheck(this, VScrollBar);

                    _get(Object.getPrototypeOf(VScrollBar.prototype), "constructor", this).call(this, parent, '-v');
                    this._scrollTop = 0;
                    renderer.$scrollbarWidth = this._width = scrollbarWidth(parent.ownerDocument);
                    this.inner.style.width = this.element.style.width = (this._width || 15) + 5 + "px";
                    addListener(this.element, "scroll", this.onScroll.bind(this));
                }

                _createClass(VScrollBar, [{
                    key: "onScroll",
                    value: function onScroll() {
                        if (!this.skipEvent) {
                            this._scrollTop = this.element.scrollTop;
                            this.eventBus._emit("scroll", { data: this._scrollTop });
                        }
                        this.skipEvent = false;
                    }
                }, {
                    key: "setHeight",
                    value: function setHeight(height) {
                        this.element.style.height = height + "px";
                    }
                }, {
                    key: "setInnerHeight",
                    value: function setInnerHeight(height) {
                        this.inner.style.height = height + "px";
                    }
                }, {
                    key: "setScrollHeight",
                    value: function setScrollHeight(height) {
                        this.inner.style.height = height + "px";
                    }
                }, {
                    key: "setScrollTop",
                    value: function setScrollTop(scrollTop) {
                        if (this._scrollTop != scrollTop) {
                            this.skipEvent = true;
                            this._scrollTop = this.element.scrollTop = scrollTop;
                        }
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this.isVisible ? this._width : 0;
                    }
                }, {
                    key: "scrollTop",
                    get: function get() {
                        return this._scrollTop;
                    }
                }]);

                return VScrollBar;
            })(ScrollBar);

            _export("default", VScrollBar);
        }
    };
});
System.register("src/ScrollBar.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/dom.js", "src/lib/event.js", "src/lib/EventEmitterClass.js"], function (_export) {
    var _createClass, _classCallCheck, createElement, addListener, preventDefault, EventEmitterClass, ScrollBar;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibDomJs) {
            createElement = _srcLibDomJs.createElement;
        }, function (_srcLibEventJs) {
            addListener = _srcLibEventJs.addListener;
            preventDefault = _srcLibEventJs.preventDefault;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }],
        execute: function () {
            "use strict";

            ScrollBar = (function () {
                function ScrollBar(parent, classSuffix) {
                    _classCallCheck(this, ScrollBar);

                    this.eventBus = new EventEmitterClass(this);
                    this.element = createElement("div");
                    this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
                    this.inner = createElement("div");
                    this.inner.className = "ace_scrollbar-inner";
                    this.element.appendChild(this.inner);
                    parent.appendChild(this.element);
                    this.setVisible(false);
                    this.skipEvent = false;
                    addListener(this.element, "mousedown", preventDefault);
                }

                _createClass(ScrollBar, [{
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "setVisible",
                    value: function setVisible(isVisible) {
                        this.element.style.display = isVisible ? "" : "none";
                        this.isVisible = isVisible;
                        return this;
                    }
                }]);

                return ScrollBar;
            })();

            _export("default", ScrollBar);
        }
    };
});
System.register("src/HScrollBar.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/event.js", "src/ScrollBar.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, addListener, ScrollBar, HScrollBar;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibEventJs) {
            addListener = _srcLibEventJs.addListener;
        }, function (_srcScrollBarJs) {
            ScrollBar = _srcScrollBarJs["default"];
        }],
        execute: function () {
            "use strict";

            HScrollBar = (function (_ScrollBar) {
                _inherits(HScrollBar, _ScrollBar);

                function HScrollBar(parent, renderer) {
                    _classCallCheck(this, HScrollBar);

                    _get(Object.getPrototypeOf(HScrollBar.prototype), "constructor", this).call(this, parent, '-h');
                    this._scrollLeft = 0;
                    this._height = renderer.$scrollbarWidth;
                    this.inner.style.height = this.element.style.height = (this._height || 15) + 5 + "px";
                    addListener(this.element, "scroll", this.onScroll.bind(this));
                }

                _createClass(HScrollBar, [{
                    key: "onScroll",
                    value: function onScroll() {
                        if (!this.skipEvent) {
                            this._scrollLeft = this.element.scrollLeft;
                            this.eventBus._emit("scroll", { data: this._scrollLeft });
                        }
                        this.skipEvent = false;
                    }
                }, {
                    key: "setWidth",
                    value: function setWidth(width) {
                        this.element.style.width = width + "px";
                    }
                }, {
                    key: "setInnerWidth",
                    value: function setInnerWidth(width) {
                        this.inner.style.width = width + "px";
                    }
                }, {
                    key: "setScrollWidth",
                    value: function setScrollWidth(width) {
                        this.inner.style.width = width + "px";
                    }
                }, {
                    key: "setScrollLeft",
                    value: function setScrollLeft(scrollLeft) {
                        if (this._scrollLeft != scrollLeft) {
                            this.skipEvent = true;
                            this._scrollLeft = this.element.scrollLeft = scrollLeft;
                        }
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this.isVisible ? this._height : 0;
                    }
                }]);

                return HScrollBar;
            })(ScrollBar);

            _export("default", HScrollBar);
        }
    };
});
System.register('src/lib/keys.js', ['src/lib/oop.js'], function (_export) {
    "use strict";
    var mixin, Keys, name, i, FUNCTION_KEYS, PRINTABLE_KEYS, MODIFIER_KEYS, KEY_MODS, enter, escape, del;

    _export('keyCodeToString', keyCodeToString);

    function keyCodeToString(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString !== "string") {
            keyString = String.fromCharCode(keyCode);
        }
        return keyString.toLowerCase();
    }

    return {
        setters: [function (_srcLibOopJs) {
            mixin = _srcLibOopJs.mixin;
        }],
        execute: function () {
            Keys = {
                MODIFIER_KEYS: {
                    16: 'Shift', 17: 'Ctrl', 18: 'Alt', 224: 'Meta'
                },
                KEY_MODS: {
                    "ctrl": 1, "alt": 2, "option": 2, "shift": 4,
                    "super": 8, "meta": 8, "command": 8, "cmd": 8
                },
                FUNCTION_KEYS: {
                    8: "Backspace",
                    9: "Tab",
                    13: "Return",
                    19: "Pause",
                    27: "Esc",
                    32: "Space",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "Left",
                    38: "Up",
                    39: "Right",
                    40: "Down",
                    44: "Print",
                    45: "Insert",
                    46: "Delete",
                    96: "Numpad0",
                    97: "Numpad1",
                    98: "Numpad2",
                    99: "Numpad3",
                    100: "Numpad4",
                    101: "Numpad5",
                    102: "Numpad6",
                    103: "Numpad7",
                    104: "Numpad8",
                    105: "Numpad9",
                    '-13': "NumpadEnter",
                    112: "F1",
                    113: "F2",
                    114: "F3",
                    115: "F4",
                    116: "F5",
                    117: "F6",
                    118: "F7",
                    119: "F8",
                    120: "F9",
                    121: "F10",
                    122: "F11",
                    123: "F12",
                    144: "Numlock",
                    145: "Scrolllock"
                },
                PRINTABLE_KEYS: {
                    32: ' ', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5',
                    54: '6', 55: '7', 56: '8', 57: '9', 59: ';', 61: '=', 65: 'a',
                    66: 'b', 67: 'c', 68: 'd', 69: 'e', 70: 'f', 71: 'g', 72: 'h',
                    73: 'i', 74: 'j', 75: 'k', 76: 'l', 77: 'm', 78: 'n', 79: 'o',
                    80: 'p', 81: 'q', 82: 'r', 83: 's', 84: 't', 85: 'u', 86: 'v',
                    87: 'w', 88: 'x', 89: 'y', 90: 'z', 107: '+', 109: '-', 110: '.',
                    187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[',
                    220: '\\', 221: ']', 222: '\''
                },
                enter: 13,
                esc: 27,
                escape: 27,
                del: 46
            };

            for (i in Keys.FUNCTION_KEYS) {
                name = Keys.FUNCTION_KEYS[i].toLowerCase();
                Keys[name] = parseInt(i, 10);
            }
            for (i in Keys.PRINTABLE_KEYS) {
                name = Keys.PRINTABLE_KEYS[i].toLowerCase();
                Keys[name] = parseInt(i, 10);
            }
            mixin(Keys, Keys.MODIFIER_KEYS);
            mixin(Keys, Keys.PRINTABLE_KEYS);
            mixin(Keys, Keys.FUNCTION_KEYS);
            Keys[173] = '-';
            (function () {
                var mods = ["cmd", "ctrl", "alt", "shift"];
                for (var i = Math.pow(2, mods.length); i--;) {
                    var f = function f(s) {
                        return i & Keys.KEY_MODS[s];
                    };
                    var filtrate = mods.filter(f);
                    Keys.KEY_MODS[i] = mods.filter(f).join("-") + "-";
                }
            })();
            FUNCTION_KEYS = Keys.FUNCTION_KEYS;

            _export('FUNCTION_KEYS', FUNCTION_KEYS);

            PRINTABLE_KEYS = Keys.PRINTABLE_KEYS;

            _export('PRINTABLE_KEYS', PRINTABLE_KEYS);

            MODIFIER_KEYS = Keys.MODIFIER_KEYS;

            _export('MODIFIER_KEYS', MODIFIER_KEYS);

            KEY_MODS = Keys.KEY_MODS;

            _export('KEY_MODS', KEY_MODS);

            enter = Keys["return"];

            _export('enter', enter);

            escape = Keys.esc;

            _export('escape', escape);

            del = Keys["delete"];

            _export('del', del);

            _export('default', Keys);
        }
    };
});
System.register("src/lib/useragent.js", [], function (_export) {
    "use strict";
    var OS, os, ua, isWin, isMac, isLinux, isIE, isOldIE, isGecko, isMozilla, isOldGecko, isOpera, isWebKit, isChrome, isChromeOS, isAIR, isAndroid, isIPad, isTouchPad, isMobile;

    _export("getOS", getOS);

    function getOS() {
        if (isMac) {
            return OS.MAC;
        } else if (isLinux) {
            return OS.LINUX;
        } else {
            return OS.WINDOWS;
        }
    }

    return {
        setters: [],
        execute: function () {
            OS = {
                LINUX: "LINUX",
                MAC: "MAC",
                WINDOWS: "WINDOWS"
            };

            _export("OS", OS);

            os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
            ua = navigator.userAgent;
            isWin = os == "win";

            _export("isWin", isWin);

            isMac = os == "mac";

            _export("isMac", isMac);

            isLinux = os == "linux";

            _export("isLinux", isLinux);

            isIE = navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);

            _export("isIE", isIE);

            isOldIE = isIE && isIE < 9;

            _export("isOldIE", isOldIE);

            isGecko = ('Controllers' in window || 'controllers' in window) && window.navigator.product === "Gecko";

            _export("isGecko", isGecko);

            isMozilla = isGecko;

            _export("isMozilla", isMozilla);

            isOldGecko = isGecko && parseInt((ua.match(/rv\:(\d+)/) || [])[1], 10) < 4;

            _export("isOldGecko", isOldGecko);

            isOpera = 'opera' in window && Object.prototype.toString.call(window['opera']) == "[object Opera]";

            _export("isOpera", isOpera);

            isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;

            _export("isWebKit", isWebKit);

            isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;

            _export("isChrome", isChrome);

            isChromeOS = ua.indexOf(" CrOS ") >= 0;

            _export("isChromeOS", isChromeOS);

            isAIR = ua.indexOf("AdobeAIR") >= 0;

            _export("isAIR", isAIR);

            isAndroid = ua.indexOf("Android") >= 0;

            _export("isAndroid", isAndroid);

            isIPad = ua.indexOf("iPad") >= 0;

            _export("isIPad", isIPad);

            isTouchPad = ua.indexOf("TouchPad") >= 0;

            _export("isTouchPad", isTouchPad);

            isMobile = isAndroid || isIPad || isTouchPad;

            _export("isMobile", isMobile);
        }
    };
});
System.register('src/lib/event.js', ['npm:babel-runtime@5.8.34/core-js/object/create', 'src/lib/keys.js', 'src/lib/useragent.js'], function (_export) {
    var _Object$create, FUNCTION_KEYS, KEY_MODS, MODIFIER_KEYS, PRINTABLE_KEYS, isChromeOS, isIE, isMac, isOldGecko, isOldIE, isOpera, getModifierHash, pressedKeys, ts, nextFrameCandidate, requestAnimationFrame;

    function addListener(target, type, callback, useCapture) {
        if (target.addEventListener) {
            return target.addEventListener(type, callback, false);
        }
    }

    function removeListener(target, type, callback, useCapture) {
        if (target.removeEventListener) {
            return target.removeEventListener(type, callback, false);
        }
    }

    function stopEvent(e) {
        stopPropagation(e);
        preventDefault(e);
        return false;
    }

    function stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        } else {
            e.cancelBubble = true;
        }
    }

    function preventDefault(e) {
        var RETURN_VALUE_DEPRECATED = 'returnValue';
        if (e.preventDefault) {
            e.preventDefault();
        } else if (e[RETURN_VALUE_DEPRECATED]) {
            e[RETURN_VALUE_DEPRECATED] = false;
        }
    }

    function getButton(e) {
        if (e.type == "dblclick") return 0;
        if (e.type == "contextmenu" || isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
        if (e.preventDefault) {
            return e.button;
        } else {
            return ({ 1: 0, 2: 2, 4: 1 })[e.button];
        }
    }

    function capture(unused, acquireCaptureHandler, releaseCaptureHandler) {
        var element = document;
        function releaseMouse(e) {
            acquireCaptureHandler && acquireCaptureHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);
            removeListener(element, "mousemove", acquireCaptureHandler, true);
            removeListener(element, "mouseup", releaseMouse, true);
            removeListener(element, "dragstart", releaseMouse, true);
        }
        addListener(element, "mousemove", acquireCaptureHandler, true);
        addListener(element, "mouseup", releaseMouse, true);
        addListener(element, "dragstart", releaseMouse, true);
        return releaseMouse;
    }

    function addMouseWheelListener(element, callback) {
        if ("onmousewheel" in element) {
            addListener(element, "mousewheel", function (e) {
                var factor = 8;
                if (e['wheelDeltaX'] !== undefined) {
                    e['wheelX'] = -e['wheelDeltaX'] / factor;
                    e['wheelY'] = -e['wheelDeltaY'] / factor;
                } else {
                    e['wheelX'] = 0;
                    e['wheelY'] = -e.wheelDelta / factor;
                }
                callback(e);
            });
        } else if ("onwheel" in element) {
            addListener(element, "wheel", function (e) {
                var factor = 0.35;
                switch (e.deltaMode) {
                    case e.DOM_DELTA_PIXEL:
                        e.wheelX = e.deltaX * factor || 0;
                        e.wheelY = e.deltaY * factor || 0;
                        break;
                    case e.DOM_DELTA_LINE:
                    case e.DOM_DELTA_PAGE:
                        e.wheelX = (e.deltaX || 0) * 5;
                        e.wheelY = (e.deltaY || 0) * 5;
                        break;
                }
                callback(e);
            });
        } else {
            addListener(element, "DOMMouseScroll", function (e) {
                if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
                    e.wheelX = (e.detail || 0) * 5;
                    e.wheelY = 0;
                } else {
                    e.wheelX = 0;
                    e.wheelY = (e.detail || 0) * 5;
                }
                callback(e);
            });
        }
    }

    function addMultiMouseDownListener(el, timeouts, eventHandler, callbackName) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
        };
        addListener(el, "mousedown", function (e) {
            if (getButton(e) !== 0) {
                clicks = 0;
            } else if (e.detail > 1) {
                clicks++;
                if (clicks > 4) clicks = 1;
            } else {
                clicks = 1;
            }
            if (isIE) {
                var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                if (!timer || isNewClick) clicks = 1;
                if (timer) clearTimeout(timer);
                timer = setTimeout(function () {
                    timer = null;
                }, timeouts[clicks - 1] || 600);
                if (clicks == 1) {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }
            e['_clicks'] = clicks;
            eventHandler[callbackName]("mousedown", e);
            if (clicks > 4) clicks = 0;else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
        });
        if (isOldIE) {
            addListener(el, "dblclick", function (e) {
                clicks = 2;
                if (timer) clearTimeout(timer);
                timer = setTimeout(function () {
                    timer = null;
                }, timeouts[clicks - 1] || 600);
                eventHandler[callbackName]("mousedown", e);
                eventHandler[callbackName](eventNames[clicks], e);
            });
        }
    }

    function getModifierString(e) {
        return KEY_MODS[getModifierHash(e)];
    }

    function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!isMac && pressedKeys) {
            if (pressedKeys[91] || pressedKeys[92]) hashId |= 8;
            if (pressedKeys.altGr) {
                if ((3 & hashId) != 3) pressedKeys.altGr = 0;else return;
            }
            if (keyCode === 18 || keyCode === 17) {
                if (keyCode === 17 && e.location === 1) {
                    ts = e.timeStamp;
                } else if (keyCode === 18 && hashId === 3 && e.location === 2) {
                    var dt = -ts;
                    ts = e.timeStamp;
                    dt += ts;
                    if (dt < 3) pressedKeys.altGr = true;
                }
            }
        }
        if (keyCode in MODIFIER_KEYS) {
            switch (MODIFIER_KEYS[keyCode]) {
                case "Alt":
                    hashId = 2;
                    break;
                case "Shift":
                    hashId = 4;
                    break;
                case "Ctrl":
                    hashId = 1;
                    break;
                default:
                    hashId = 8;
                    break;
            }
            keyCode = -1;
        }
        if (hashId & 8 && (keyCode === 91 || keyCode === 93)) {
            keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
            if (e.location === 3) {
                callback(e, hashId, -keyCode);
                if (e.defaultPrevented) return;
            }
        }
        if (isChromeOS && hashId & 8) {
            callback(e, hashId, keyCode);
            if (e.defaultPrevented) return;else hashId &= ~8;
        }
        if (!hashId && !(keyCode in FUNCTION_KEYS) && !(keyCode in PRINTABLE_KEYS)) {
            return false;
        }
        return callback(e, hashId, keyCode);
    }

    function resetPressedKeys(e) {
        pressedKeys = _Object$create(null);
    }

    function addCommandKeyListener(el, callback) {
        if (isOldGecko || isOpera && !("KeyboardEvent" in window)) {
            var lastKeyDownKeyCode = null;
            addListener(el, "keydown", function (e) {
                lastKeyDownKeyCode = e.keyCode;
            });
            addListener(el, "keypress", function (e) {
                return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
            });
        } else {
            var lastDefaultPrevented = null;
            addListener(el, "keydown", function (e) {
                pressedKeys[e.keyCode] = true;
                var result = normalizeCommandKeys(callback, e, e.keyCode);
                lastDefaultPrevented = e.defaultPrevented;
                return result;
            });
            addListener(el, 'keypress', function (e) {
                if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                    stopEvent(e);
                    lastDefaultPrevented = null;
                }
            });
            addListener(el, 'keyup', function (e) {
                pressedKeys[e.keyCode] = null;
            });
            if (!pressedKeys) {
                pressedKeys = _Object$create(null);
                addListener(window, 'focus', resetPressedKeys);
            }
        }
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate['default'];
        }, function (_srcLibKeysJs) {
            FUNCTION_KEYS = _srcLibKeysJs.FUNCTION_KEYS;
            KEY_MODS = _srcLibKeysJs.KEY_MODS;
            MODIFIER_KEYS = _srcLibKeysJs.MODIFIER_KEYS;
            PRINTABLE_KEYS = _srcLibKeysJs.PRINTABLE_KEYS;
        }, function (_srcLibUseragentJs) {
            isChromeOS = _srcLibUseragentJs.isChromeOS;
            isIE = _srcLibUseragentJs.isIE;
            isMac = _srcLibUseragentJs.isMac;
            isOldGecko = _srcLibUseragentJs.isOldGecko;
            isOldIE = _srcLibUseragentJs.isOldIE;
            isOpera = _srcLibUseragentJs.isOpera;
        }],
        execute: function () {
            'use strict';

            _export('addListener', addListener);

            _export('removeListener', removeListener);

            _export('stopEvent', stopEvent);

            _export('stopPropagation', stopPropagation);

            _export('preventDefault', preventDefault);

            _export('getButton', getButton);

            _export('capture', capture);

            _export('addMouseWheelListener', addMouseWheelListener);

            _export('addMultiMouseDownListener', addMultiMouseDownListener);

            _export('getModifierString', getModifierString);

            _export('addCommandKeyListener', addCommandKeyListener);

            getModifierHash = isMac && isOpera && !("KeyboardEvent" in window) ? function (e) {
                return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
            } : function (e) {
                return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
            };
            pressedKeys = null;
            ts = 0;
            nextFrameCandidate = window.requestAnimationFrame || window['mozRequestAnimationFrame'] || window['webkitRequestAnimationFrame'] || window.msRequestAnimationFrame || window['oRequestAnimationFrame'];

            if (nextFrameCandidate) {
                nextFrameCandidate = nextFrameCandidate.bind(window);
            } else {
                nextFrameCandidate = function (callback) {
                    setTimeout(callback, 17);
                };
            }
            requestAnimationFrame = nextFrameCandidate;

            _export('requestAnimationFrame', requestAnimationFrame);
        }
    };
});
System.register("src/RenderLoop.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/event.js"], function (_export) {
    var _createClass, _classCallCheck, requestAnimationFrame, RenderLoop;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibEventJs) {
            requestAnimationFrame = _srcLibEventJs.requestAnimationFrame;
        }],
        execute: function () {
            "use strict";

            RenderLoop = (function () {
                function RenderLoop(onRender) {
                    var $window = arguments.length <= 1 || arguments[1] === undefined ? window : arguments[1];

                    _classCallCheck(this, RenderLoop);

                    this.pending = false;
                    this.changes = 0;
                    this.onRender = onRender;
                    this.$window = $window;
                }

                _createClass(RenderLoop, [{
                    key: "schedule",
                    value: function schedule(change) {
                        this.changes = this.changes | change;
                        if (!this.pending && this.changes) {
                            this.pending = true;
                            var self = this;
                            requestAnimationFrame(function () {
                                self.pending = false;
                                var changes;
                                while (changes = self.changes) {
                                    self.changes = 0;
                                    self.onRender(changes);
                                }
                            }, this.$window);
                        }
                    }
                }]);

                return RenderLoop;
            })();

            _export("default", RenderLoop);
        }
    };
});
System.register("src/ThemeLink.js", ["npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _classCallCheck, ThemeLink;

    return {
        setters: [function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            ThemeLink = function ThemeLink(isDark, id, rel, type, href, padding) {
                _classCallCheck(this, ThemeLink);

                if (typeof padding !== 'number') {
                    throw new TypeError("padding must be a number");
                }
                this.isDark = isDark;
                this.id = id;
                this.rel = rel;
                this.type = type;
                this.href = href;
                this.padding = padding;
            };

            _export("default", ThemeLink);
        }
    };
});
System.register("src/VirtualRenderer.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/lib/dom.js", "src/config.js", "src/lib/useragent.js", "src/layer/Cursor.js", "src/layer/FontMetrics.js", "src/layer/Gutter.js", "src/layer/Marker.js", "src/layer/Text.js", "src/VScrollBar.js", "src/HScrollBar.js", "src/RenderLoop.js", "src/lib/EventEmitterClass.js", "src/ThemeLink.js"], function (_export) {
    var _createClass, _classCallCheck, _Promise, _addCssClass, appendHTMLLinkElement, createElement, ensureHTMLStyleElement, removeCssClass, _setCssClass, defineOptions, resetOptions, isOldIE, Cursor, FontMetrics, Gutter, Marker, Text, VScrollBar, HScrollBar, RenderLoop, EventEmitterClass, ThemeLink, CHANGE_CURSOR, CHANGE_MARKER, CHANGE_GUTTER, CHANGE_SCROLL, CHANGE_LINES, CHANGE_TEXT, CHANGE_SIZE, CHANGE_MARKER_BACK, CHANGE_MARKER_FRONT, CHANGE_FULL, CHANGE_H_SCROLL, VirtualRenderer;

    function changesToString(changes) {
        var a = "";
        if (changes & CHANGE_CURSOR) a += " cursor";
        if (changes & CHANGE_MARKER) a += " marker";
        if (changes & CHANGE_GUTTER) a += " gutter";
        if (changes & CHANGE_SCROLL) a += " scroll";
        if (changes & CHANGE_LINES) a += " lines";
        if (changes & CHANGE_TEXT) a += " text";
        if (changes & CHANGE_SIZE) a += " size";
        if (changes & CHANGE_MARKER_BACK) a += " marker_back";
        if (changes & CHANGE_MARKER_FRONT) a += " marker_front";
        if (changes & CHANGE_FULL) a += " full";
        if (changes & CHANGE_H_SCROLL) a += " h_scroll";
        return a.trim();
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcLibDomJs) {
            _addCssClass = _srcLibDomJs.addCssClass;
            appendHTMLLinkElement = _srcLibDomJs.appendHTMLLinkElement;
            createElement = _srcLibDomJs.createElement;
            ensureHTMLStyleElement = _srcLibDomJs.ensureHTMLStyleElement;
            removeCssClass = _srcLibDomJs.removeCssClass;
            _setCssClass = _srcLibDomJs.setCssClass;
        }, function (_srcConfigJs) {
            defineOptions = _srcConfigJs.defineOptions;
            resetOptions = _srcConfigJs.resetOptions;
        }, function (_srcLibUseragentJs) {
            isOldIE = _srcLibUseragentJs.isOldIE;
        }, function (_srcLayerCursorJs) {
            Cursor = _srcLayerCursorJs["default"];
        }, function (_srcLayerFontMetricsJs) {
            FontMetrics = _srcLayerFontMetricsJs["default"];
        }, function (_srcLayerGutterJs) {
            Gutter = _srcLayerGutterJs["default"];
        }, function (_srcLayerMarkerJs) {
            Marker = _srcLayerMarkerJs["default"];
        }, function (_srcLayerTextJs) {
            Text = _srcLayerTextJs["default"];
        }, function (_srcVScrollBarJs) {
            VScrollBar = _srcVScrollBarJs["default"];
        }, function (_srcHScrollBarJs) {
            HScrollBar = _srcHScrollBarJs["default"];
        }, function (_srcRenderLoopJs) {
            RenderLoop = _srcRenderLoopJs["default"];
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs["default"];
        }, function (_srcThemeLinkJs) {
            ThemeLink = _srcThemeLinkJs["default"];
        }],
        execute: function () {
            "use strict";
            CHANGE_CURSOR = 1;
            CHANGE_MARKER = 2;
            CHANGE_GUTTER = 4;
            CHANGE_SCROLL = 8;
            CHANGE_LINES = 16;
            CHANGE_TEXT = 32;
            CHANGE_SIZE = 64;
            CHANGE_MARKER_BACK = 128;
            CHANGE_MARKER_FRONT = 256;
            CHANGE_FULL = 512;
            CHANGE_H_SCROLL = 1024;

            VirtualRenderer = (function () {
                function VirtualRenderer(container) {
                    var _this = this;

                    _classCallCheck(this, VirtualRenderer);

                    this.scrollLeft = 0;
                    this.scrollTop = 0;
                    this.layerConfig = {
                        width: 1,
                        padding: 0,
                        firstRow: 0,
                        firstRowScreen: 0,
                        lastRow: 0,
                        lineHeight: 0,
                        characterWidth: 0,
                        minHeight: 1,
                        maxHeight: 1,
                        offset: 0,
                        height: 1,
                        gutterOffset: 1
                    };
                    this.$padding = 0;
                    this.$frozen = false;
                    this.STEPS = 8;
                    this.scrollMargin = {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0,
                        v: 0,
                        h: 0
                    };
                    this.$changes = 0;
                    this.eventBus = new EventEmitterClass(this);
                    this.container = container || createElement("div");
                    this.$keepTextAreaAtCursor = !isOldIE;
                    _addCssClass(this.container, "ace_editor");
                    this.$gutter = createElement("div");
                    this.$gutter.className = "ace_gutter";
                    this.container.appendChild(this.$gutter);
                    this.scroller = createElement("div");
                    this.scroller.className = "ace_scroller";
                    this.container.appendChild(this.scroller);
                    this.content = createElement("div");
                    this.content.className = "ace_content";
                    this.scroller.appendChild(this.content);
                    this.$gutterLayer = new Gutter(this.$gutter);
                    this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
                    this.$markerBack = new Marker(this.content);
                    var textLayer = this.$textLayer = new Text(this.content);
                    this.canvas = textLayer.element;
                    this.$markerFront = new Marker(this.content);
                    this.$cursorLayer = new Cursor(this.content);
                    this.$horizScroll = false;
                    this.$vScroll = false;
                    this.scrollBarV = new VScrollBar(this.container, this);
                    this.scrollBarH = new HScrollBar(this.container, this);
                    this.scrollBarV.on("scroll", function (event, scrollBar) {
                        if (!_this.$scrollAnimation) {
                            _this.session.setScrollTop(event.data - _this.scrollMargin.top);
                        }
                    });
                    this.scrollBarH.on("scroll", function (event, scrollBar) {
                        if (!this.$scrollAnimation) {
                            this.session.setScrollLeft(event.data - this.scrollMargin.left);
                        }
                    });
                    this.cursorPos = {
                        row: 0,
                        column: 0
                    };
                    this.$fontMetrics = new FontMetrics(this.container, 500);
                    this.$textLayer.$setFontMetrics(this.$fontMetrics);
                    this.$textLayer.on("changeCharacterSize", function (event, text) {
                        _this.updateCharacterSize();
                        _this.onResize(true, _this.gutterWidth, _this.$size.width, _this.$size.height);
                        _this.eventBus._signal("changeCharacterSize", event);
                    });
                    this.$size = {
                        width: 0,
                        height: 0,
                        scrollerHeight: 0,
                        scrollerWidth: 0,
                        $dirty: true
                    };
                    this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
                    this.$loop.schedule(CHANGE_FULL);
                    this.updateCharacterSize();
                    this.setPadding(4);
                    resetOptions(this);
                }

                _createClass(VirtualRenderer, [{
                    key: "on",
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: "setDefaultCursorStyle",
                    value: function setDefaultCursorStyle() {
                        this.content.style.cursor = "default";
                    }
                }, {
                    key: "setCursorLayerOff",
                    value: function setCursorLayerOff() {
                        var noop = function noop() {};
                        this.$cursorLayer.restartTimer = noop;
                        this.$cursorLayer.element.style.opacity = "0";
                    }
                }, {
                    key: "updateCharacterSize",
                    value: function updateCharacterSize() {
                        if (this.$textLayer['allowBoldFonts'] != this.$allowBoldFonts) {
                            this.$allowBoldFonts = this.$textLayer['allowBoldFonts'];
                            this.setStyle("ace_nobold", !this.$allowBoldFonts);
                        }
                        this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
                        this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
                        this.$updatePrintMargin();
                    }
                }, {
                    key: "setSession",
                    value: function setSession(session) {
                        if (this.session) {
                            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
                        }
                        this.session = session;
                        if (!session) {
                            return;
                        }
                        if (this.scrollMargin.top && session.getScrollTop() <= 0) {
                            session.setScrollTop(-this.scrollMargin.top);
                        }
                        this.$cursorLayer.setSession(session);
                        this.$markerBack.setSession(session);
                        this.$markerFront.setSession(session);
                        this.$gutterLayer.setSession(session);
                        this.$textLayer.setSession(session);
                        this.$loop.schedule(CHANGE_FULL);
                        this.session.$setFontMetrics(this.$fontMetrics);
                        this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
                        this.onChangeNewLineMode();
                        this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
                    }
                }, {
                    key: "updateLines",
                    value: function updateLines(firstRow, lastRow, force) {
                        if (lastRow === undefined) {
                            lastRow = Infinity;
                        }
                        if (!this.$changedLines) {
                            this.$changedLines = { firstRow: firstRow, lastRow: lastRow };
                        } else {
                            if (this.$changedLines.firstRow > firstRow) {
                                this.$changedLines.firstRow = firstRow;
                            }
                            if (this.$changedLines.lastRow < lastRow) {
                                this.$changedLines.lastRow = lastRow;
                            }
                        }
                        if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                            if (force) {
                                this.$changedLines.lastRow = this.layerConfig.lastRow;
                            } else {
                                return;
                            }
                        }
                        if (this.$changedLines.firstRow > this.layerConfig.lastRow) {
                            return;
                        }
                        this.$loop.schedule(CHANGE_LINES);
                    }
                }, {
                    key: "onChangeNewLineMode",
                    value: function onChangeNewLineMode() {
                        this.$loop.schedule(CHANGE_TEXT);
                        this.$textLayer.updateEolChar();
                    }
                }, {
                    key: "onChangeTabSize",
                    value: function onChangeTabSize() {
                        if (this.$loop) {
                            if (this.$loop.schedule) {
                                this.$loop.schedule(CHANGE_TEXT | CHANGE_MARKER);
                            } else {}
                        } else {}
                        if (this.$textLayer) {
                            if (this.$textLayer.onChangeTabSize) {
                                this.$textLayer.onChangeTabSize();
                            } else {}
                        } else {}
                    }
                }, {
                    key: "updateText",
                    value: function updateText() {
                        this.$loop.schedule(CHANGE_TEXT);
                    }
                }, {
                    key: "updateFull",
                    value: function updateFull(force) {
                        if (force) this.$renderChanges(CHANGE_FULL, true);else this.$loop.schedule(CHANGE_FULL);
                    }
                }, {
                    key: "updateFontSize",
                    value: function updateFontSize() {
                        this.$textLayer.checkForSizeChanges();
                    }
                }, {
                    key: "$updateSizeAsync",
                    value: function $updateSizeAsync() {
                        if (this.$loop.pending) {
                            this.$size.$dirty = true;
                        } else {
                            this.onResize();
                        }
                    }
                }, {
                    key: "onResize",
                    value: function onResize(force, gutterWidth, width, height) {
                        if (this.resizing > 2) return;else if (this.resizing > 0) this.resizing++;else this.resizing = force ? 1 : 0;
                        var el = this.container;
                        if (!height) height = el.clientHeight || el.scrollHeight;
                        if (!width) width = el.clientWidth || el.scrollWidth;
                        var changes = this.$updateCachedSize(force, gutterWidth, width, height);
                        if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;
                        if (force) this.$gutterLayer.$padding = null;
                        if (force) this.$renderChanges(changes | this.$changes, true);else this.$loop.schedule(changes | this.$changes);
                        if (this.resizing) this.resizing = 0;
                    }
                }, {
                    key: "$updateCachedSize",
                    value: function $updateCachedSize(force, gutterWidth, width, height) {
                        height -= this.$extraHeight || 0;
                        var changes = 0;
                        var size = this.$size;
                        var oldSize = {
                            width: size.width,
                            height: size.height,
                            scrollerHeight: size.scrollerHeight,
                            scrollerWidth: size.scrollerWidth
                        };
                        if (height && (force || size.height != height)) {
                            size.height = height;
                            changes |= CHANGE_SIZE;
                            size.scrollerHeight = size.height;
                            if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.height;
                            this.scrollBarV.element.style.bottom = this.scrollBarH.height + "px";
                            changes = changes | CHANGE_SCROLL;
                        }
                        if (width && (force || size.width != width)) {
                            changes |= CHANGE_SIZE;
                            size.width = width;
                            if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                            this.gutterWidth = gutterWidth;
                            this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
                            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.width);
                            this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.width + "px";
                            this.scroller.style.bottom = this.scrollBarH.height + "px";
                            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= CHANGE_FULL;
                        }
                        size.$dirty = !width || !height;
                        if (changes) {
                            this.eventBus._signal("resize", oldSize);
                        }
                        return changes;
                    }
                }, {
                    key: "onGutterResize",
                    value: function onGutterResize() {
                        var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                        if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
                        if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
                            this.$loop.schedule(CHANGE_FULL);
                        } else if (this.$size.$dirty) {
                            this.$loop.schedule(CHANGE_FULL);
                        } else {
                            this.$computeLayerConfig();
                            this.$loop.schedule(CHANGE_MARKER);
                        }
                    }
                }, {
                    key: "adjustWrapLimit",
                    value: function adjustWrapLimit() {
                        var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
                        var limit = Math.floor(availableWidth / this.characterWidth);
                        return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
                    }
                }, {
                    key: "setAnimatedScroll",
                    value: function setAnimatedScroll(shouldAnimate) {
                        this.setOption("animatedScroll", shouldAnimate);
                    }
                }, {
                    key: "getAnimatedScroll",
                    value: function getAnimatedScroll() {
                        return this.$animatedScroll;
                    }
                }, {
                    key: "setShowInvisibles",
                    value: function setShowInvisibles(showInvisibles) {
                        this.setOption("showInvisibles", showInvisibles);
                    }
                }, {
                    key: "getShowInvisibles",
                    value: function getShowInvisibles() {
                        return this.getOption("showInvisibles");
                    }
                }, {
                    key: "getDisplayIndentGuides",
                    value: function getDisplayIndentGuides() {
                        return this.getOption("displayIndentGuides");
                    }
                }, {
                    key: "setDisplayIndentGuides",
                    value: function setDisplayIndentGuides(displayIndentGuides) {
                        this.setOption("displayIndentGuides", displayIndentGuides);
                    }
                }, {
                    key: "setShowPrintMargin",
                    value: function setShowPrintMargin(showPrintMargin) {
                        this.setOption("showPrintMargin", showPrintMargin);
                    }
                }, {
                    key: "getShowPrintMargin",
                    value: function getShowPrintMargin() {
                        return this.getOption("showPrintMargin");
                    }
                }, {
                    key: "setPrintMarginColumn",
                    value: function setPrintMarginColumn(printMarginColumn) {
                        this.setOption("printMarginColumn", printMarginColumn);
                    }
                }, {
                    key: "getPrintMarginColumn",
                    value: function getPrintMarginColumn() {
                        return this.getOption("printMarginColumn");
                    }
                }, {
                    key: "getShowGutter",
                    value: function getShowGutter() {
                        return this.getOption("showGutter");
                    }
                }, {
                    key: "setShowGutter",
                    value: function setShowGutter(showGutter) {
                        return this.setOption("showGutter", showGutter);
                    }
                }, {
                    key: "getFadeFoldWidgets",
                    value: function getFadeFoldWidgets() {
                        return this.getOption("fadeFoldWidgets");
                    }
                }, {
                    key: "setFadeFoldWidgets",
                    value: function setFadeFoldWidgets(fadeFoldWidgets) {
                        this.setOption("fadeFoldWidgets", fadeFoldWidgets);
                    }
                }, {
                    key: "setHighlightGutterLine",
                    value: function setHighlightGutterLine(highlightGutterLine) {
                        this.setOption("highlightGutterLine", highlightGutterLine);
                    }
                }, {
                    key: "getHighlightGutterLine",
                    value: function getHighlightGutterLine() {
                        return this.getOption("highlightGutterLine");
                    }
                }, {
                    key: "$updateGutterLineHighlight",
                    value: function $updateGutterLineHighlight() {
                        var pos = this.$cursorLayer.$pixelPos;
                        var height = this.layerConfig.lineHeight;
                        if (this.session.getUseWrapMode()) {
                            var cursor = this.session.getSelection().getCursor();
                            cursor.column = 0;
                            pos = this.$cursorLayer.getPixelPosition(cursor, true);
                            height *= this.session.getRowLength(cursor.row);
                        }
                        this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
                        this.$gutterLineHighlight.style.height = height + "px";
                    }
                }, {
                    key: "$updatePrintMargin",
                    value: function $updatePrintMargin() {
                        if (!this.$showPrintMargin && !this.$printMarginEl) return;
                        if (!this.$printMarginEl) {
                            var containerEl = createElement("div");
                            containerEl.className = "ace_layer ace_print-margin-layer";
                            this.$printMarginEl = createElement("div");
                            this.$printMarginEl.className = "ace_print-margin";
                            containerEl.appendChild(this.$printMarginEl);
                            this.content.insertBefore(containerEl, this.content.firstChild);
                        }
                        var style = this.$printMarginEl.style;
                        style.left = this.characterWidth * this.$printMarginColumn + this.$padding + "px";
                        style.visibility = this.$showPrintMargin ? "visible" : "hidden";
                        if (this.session && this.session['$wrap'] == -1) this.adjustWrapLimit();
                    }
                }, {
                    key: "getContainerElement",
                    value: function getContainerElement() {
                        return this.container;
                    }
                }, {
                    key: "getMouseEventTarget",
                    value: function getMouseEventTarget() {
                        return this.content;
                    }
                }, {
                    key: "getTextAreaContainer",
                    value: function getTextAreaContainer() {
                        return this.container;
                    }
                }, {
                    key: "$moveTextAreaToCursor",
                    value: function $moveTextAreaToCursor() {
                        if (!this.$keepTextAreaAtCursor) {
                            return;
                        }
                        var config = this.layerConfig;
                        var posTop = this.$cursorLayer.$pixelPos.top;
                        var posLeft = this.$cursorLayer.$pixelPos.left;
                        posTop -= config.offset;
                        var h = this.lineHeight;
                        if (posTop < 0 || posTop > config.height - h) return;
                        var w = this.characterWidth;
                        if (this.$composition) {
                            var val = this.textarea.value.replace(/^\x01+/, "");
                            w *= this.session.$getStringScreenWidth(val)[0] + 2;
                            h += 2;
                            posTop -= 1;
                        }
                        posLeft -= this.scrollLeft;
                        if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;
                        posLeft -= this.scrollBarV.width;
                        this.textarea.style.height = h + "px";
                        this.textarea.style.width = w + "px";
                        this.textarea.style.right = Math.max(0, this.$size.scrollerWidth - posLeft - w) + "px";
                        this.textarea.style.bottom = Math.max(0, this.$size.height - posTop - h) + "px";
                    }
                }, {
                    key: "getFirstVisibleRow",
                    value: function getFirstVisibleRow() {
                        return this.layerConfig.firstRow;
                    }
                }, {
                    key: "getFirstFullyVisibleRow",
                    value: function getFirstFullyVisibleRow() {
                        return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
                    }
                }, {
                    key: "getLastFullyVisibleRow",
                    value: function getLastFullyVisibleRow() {
                        var flint = Math.floor((this.layerConfig.height + this.layerConfig.offset) / this.layerConfig.lineHeight);
                        return this.layerConfig.firstRow - 1 + flint;
                    }
                }, {
                    key: "getLastVisibleRow",
                    value: function getLastVisibleRow() {
                        return this.layerConfig.lastRow;
                    }
                }, {
                    key: "getPadding",
                    value: function getPadding() {
                        return this.$padding;
                    }
                }, {
                    key: "setPadding",
                    value: function setPadding(padding) {
                        if (typeof padding !== 'number') {
                            throw new TypeError("padding must be a number");
                        }
                        this.$padding = padding;
                        this.$textLayer.setPadding(padding);
                        this.$cursorLayer.setPadding(padding);
                        this.$markerFront.setPadding(padding);
                        this.$markerBack.setPadding(padding);
                        this.$loop.schedule(CHANGE_FULL);
                        this.$updatePrintMargin();
                    }
                }, {
                    key: "setScrollMargin",
                    value: function setScrollMargin(top, bottom, left, right) {
                        var sm = this.scrollMargin;
                        sm.top = top | 0;
                        sm.bottom = bottom | 0;
                        sm.right = right | 0;
                        sm.left = left | 0;
                        sm.v = sm.top + sm.bottom;
                        sm.h = sm.left + sm.right;
                        if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
                        this.updateFull();
                    }
                }, {
                    key: "getHScrollBarAlwaysVisible",
                    value: function getHScrollBarAlwaysVisible() {
                        return this.$hScrollBarAlwaysVisible;
                    }
                }, {
                    key: "setHScrollBarAlwaysVisible",
                    value: function setHScrollBarAlwaysVisible(hScrollBarAlwaysVisible) {
                        this.setOption("hScrollBarAlwaysVisible", hScrollBarAlwaysVisible);
                    }
                }, {
                    key: "getVScrollBarAlwaysVisible",
                    value: function getVScrollBarAlwaysVisible() {
                        return this.$vScrollBarAlwaysVisible;
                    }
                }, {
                    key: "setVScrollBarAlwaysVisible",
                    value: function setVScrollBarAlwaysVisible(alwaysVisible) {
                        this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
                    }
                }, {
                    key: "$updateScrollBarV",
                    value: function $updateScrollBarV() {
                        var scrollHeight = this.layerConfig.maxHeight;
                        var scrollerHeight = this.$size.scrollerHeight;
                        if (!this.$maxLines && this.$scrollPastEnd) {
                            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                            if (this.scrollTop > scrollHeight - scrollerHeight) {
                                scrollHeight = this.scrollTop + scrollerHeight;
                                this.scrollBarV.scrollTop = null;
                            }
                        }
                        this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
                        this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
                    }
                }, {
                    key: "$updateScrollBarH",
                    value: function $updateScrollBarH() {
                        this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
                        this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
                    }
                }, {
                    key: "freeze",
                    value: function freeze() {
                        this.$frozen = true;
                    }
                }, {
                    key: "unfreeze",
                    value: function unfreeze() {
                        this.$frozen = false;
                    }
                }, {
                    key: "$renderChanges",
                    value: function $renderChanges(changes, force) {
                        if (this.$changes) {
                            changes |= this.$changes;
                            this.$changes = 0;
                        }
                        if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                            this.$changes |= changes;
                            return;
                        }
                        if (this.$size.$dirty) {
                            this.$changes |= changes;
                            return this.onResize(true);
                        }
                        if (!this.lineHeight) {
                            this.$textLayer.checkForSizeChanges();
                        }
                        this.eventBus._signal("beforeRender");
                        var config = this.layerConfig;
                        if (changes & CHANGE_FULL || changes & CHANGE_SIZE || changes & CHANGE_TEXT || changes & CHANGE_LINES || changes & CHANGE_SCROLL || changes & CHANGE_H_SCROLL) {
                            changes |= this.$computeLayerConfig();
                            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                                this.scrollTop = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
                                changes = changes | CHANGE_SCROLL;
                                changes |= this.$computeLayerConfig();
                            }
                            config = this.layerConfig;
                            this.$updateScrollBarV();
                            if (changes & CHANGE_H_SCROLL) this.$updateScrollBarH();
                            this.$gutterLayer.element.style.marginTop = -config.offset + "px";
                            this.content.style.marginTop = -config.offset + "px";
                            this.content.style.width = config.width + 2 * this.$padding + "px";
                            this.content.style.height = config.minHeight + "px";
                        }
                        if (changes & CHANGE_H_SCROLL) {
                            this.content.style.marginLeft = -this.scrollLeft + "px";
                            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
                        }
                        if (changes & CHANGE_FULL) {
                            this.$textLayer.update(config);
                            if (this.$showGutter) {
                                this.$gutterLayer.update(config);
                            }
                            this.$markerBack.update(config);
                            this.$markerFront.update(config);
                            this.$cursorLayer.update(config);
                            this.$moveTextAreaToCursor();
                            this.$highlightGutterLine && this.$updateGutterLineHighlight();
                            this.eventBus._signal("afterRender");
                            return;
                        }
                        if (changes & CHANGE_SCROLL) {
                            if (changes & CHANGE_TEXT || changes & CHANGE_LINES) this.$textLayer.update(config);else this.$textLayer.scrollLines(config);
                            if (this.$showGutter) this.$gutterLayer.update(config);
                            this.$markerBack.update(config);
                            this.$markerFront.update(config);
                            this.$cursorLayer.update(config);
                            this.$highlightGutterLine && this.$updateGutterLineHighlight();
                            this.$moveTextAreaToCursor();
                            this.eventBus._signal("afterRender");
                            return;
                        }
                        if (changes & CHANGE_TEXT) {
                            this.$textLayer.update(config);
                            if (this.$showGutter) this.$gutterLayer.update(config);
                        } else if (changes & CHANGE_LINES) {
                            if (this.$updateLines() || changes & CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                        } else if (changes & CHANGE_TEXT || changes & CHANGE_GUTTER) {
                            if (this.$showGutter) this.$gutterLayer.update(config);
                        }
                        if (changes & CHANGE_CURSOR) {
                            this.$cursorLayer.update(config);
                            this.$moveTextAreaToCursor();
                            this.$highlightGutterLine && this.$updateGutterLineHighlight();
                        }
                        if (changes & (CHANGE_MARKER | CHANGE_MARKER_FRONT)) {
                            this.$markerFront.update(config);
                        }
                        if (changes & (CHANGE_MARKER | CHANGE_MARKER_BACK)) {
                            this.$markerBack.update(config);
                        }
                        this.eventBus._signal("afterRender");
                    }
                }, {
                    key: "$autosize",
                    value: function $autosize() {
                        var height = this.session.getScreenLength() * this.lineHeight;
                        var maxHeight = this.$maxLines * this.lineHeight;
                        var desiredHeight = Math.max((this.$minLines || 1) * this.lineHeight, Math.min(maxHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
                        var vScroll = height > maxHeight;
                        if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                            if (vScroll != this.$vScroll) {
                                this.$vScroll = vScroll;
                                this.scrollBarV.setVisible(vScroll);
                            }
                            var w = this.container.clientWidth;
                            this.container.style.height = desiredHeight + "px";
                            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                            this.desiredHeight = desiredHeight;
                        }
                    }
                }, {
                    key: "$computeLayerConfig",
                    value: function $computeLayerConfig() {
                        if (this.$maxLines && this.lineHeight > 1) {
                            this.$autosize();
                        }
                        var session = this.session;
                        var size = this.$size;
                        var hideScrollbars = size.height <= 2 * this.lineHeight;
                        var screenLines = this.session.getScreenLength();
                        var maxHeight = screenLines * this.lineHeight;
                        var offset = this.scrollTop % this.lineHeight;
                        var minHeight = size.scrollerHeight + this.lineHeight;
                        var longestLine = this.$getLongestLine();
                        var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
                        var hScrollChanged = this.$horizScroll !== horizScroll;
                        if (hScrollChanged) {
                            this.$horizScroll = horizScroll;
                            this.scrollBarH.setVisible(horizScroll);
                        }
                        if (!this.$maxLines && this.$scrollPastEnd) {
                            maxHeight += (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                        }
                        var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight < 0);
                        var vScrollChanged = this.$vScroll !== vScroll;
                        if (vScrollChanged) {
                            this.$vScroll = vScroll;
                            this.scrollBarV.setVisible(vScroll);
                        }
                        this.session.setScrollTop(Math.max(-this.scrollMargin.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + this.scrollMargin.bottom)));
                        this.session.setScrollLeft(Math.max(-this.scrollMargin.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + this.scrollMargin.right)));
                        var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
                        var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
                        var lastRow = firstRow + lineCount;
                        var firstRowScreen, firstRowHeight;
                        var lineHeight = this.lineHeight;
                        firstRow = session.screenToDocumentRow(firstRow, 0);
                        var foldLine = session.getFoldLine(firstRow);
                        if (foldLine) {
                            firstRow = foldLine.start.row;
                        }
                        firstRowScreen = session.documentToScreenRow(firstRow, 0);
                        firstRowHeight = session.getRowLength(firstRow) * lineHeight;
                        lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
                        minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
                        offset = this.scrollTop - firstRowScreen * lineHeight;
                        var changes = 0;
                        if (this.layerConfig.width != longestLine) changes = CHANGE_H_SCROLL;
                        if (hScrollChanged || vScrollChanged) {
                            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                            this.eventBus._signal("scrollbarVisibilityChanged");
                            if (vScrollChanged) longestLine = this.$getLongestLine();
                        }
                        this.layerConfig = {
                            width: longestLine,
                            padding: this.$padding,
                            firstRow: firstRow,
                            firstRowScreen: firstRowScreen,
                            lastRow: lastRow,
                            lineHeight: lineHeight,
                            characterWidth: this.characterWidth,
                            minHeight: minHeight,
                            maxHeight: maxHeight,
                            offset: offset,
                            gutterOffset: Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
                            height: this.$size.scrollerHeight
                        };
                        return changes;
                    }
                }, {
                    key: "$updateLines",
                    value: function $updateLines() {
                        var firstRow = this.$changedLines.firstRow;
                        var lastRow = this.$changedLines.lastRow;
                        this.$changedLines = null;
                        var layerConfig = this.layerConfig;
                        if (firstRow > layerConfig.lastRow + 1) {
                            return;
                        }
                        if (lastRow < layerConfig.firstRow) {
                            return;
                        }
                        if (lastRow === Infinity) {
                            if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                            this.$textLayer.update(layerConfig);
                            return;
                        }
                        this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
                        return true;
                    }
                }, {
                    key: "$getLongestLine",
                    value: function $getLongestLine() {
                        var charCount = this.session.getScreenWidth();
                        if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;
                        return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
                    }
                }, {
                    key: "updateFrontMarkers",
                    value: function updateFrontMarkers() {
                        this.$markerFront.setMarkers(this.session.getMarkers(true));
                        this.$loop.schedule(CHANGE_MARKER_FRONT);
                    }
                }, {
                    key: "updateBackMarkers",
                    value: function updateBackMarkers() {
                        this.$markerBack.setMarkers(this.session.getMarkers(false));
                        this.$loop.schedule(CHANGE_MARKER_BACK);
                    }
                }, {
                    key: "updateBreakpoints",
                    value: function updateBreakpoints() {
                        this.$loop.schedule(CHANGE_GUTTER);
                    }
                }, {
                    key: "setAnnotations",
                    value: function setAnnotations(annotations) {
                        this.$gutterLayer.setAnnotations(annotations);
                        this.$loop.schedule(CHANGE_GUTTER);
                    }
                }, {
                    key: "updateCursor",
                    value: function updateCursor() {
                        this.$loop.schedule(CHANGE_CURSOR);
                    }
                }, {
                    key: "hideCursor",
                    value: function hideCursor() {
                        this.$cursorLayer.hideCursor();
                    }
                }, {
                    key: "showCursor",
                    value: function showCursor() {
                        this.$cursorLayer.showCursor();
                    }
                }, {
                    key: "scrollSelectionIntoView",
                    value: function scrollSelectionIntoView(anchor, lead, offset) {
                        this.scrollCursorIntoView(anchor, offset);
                        this.scrollCursorIntoView(lead, offset);
                    }
                }, {
                    key: "scrollCursorIntoView",
                    value: function scrollCursorIntoView(cursor, offset, $viewMargin) {
                        if (this.$size.scrollerHeight === 0) return;
                        var pos = this.$cursorLayer.getPixelPosition(cursor);
                        var left = pos.left;
                        var top = pos.top;
                        var topMargin = $viewMargin && $viewMargin.top || 0;
                        var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
                        var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
                        if (scrollTop + topMargin > top) {
                            if (offset) top -= offset * this.$size.scrollerHeight;
                            if (top === 0) top = -this.scrollMargin.top;
                            this.session.setScrollTop(top);
                        } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
                            if (offset) top += offset * this.$size.scrollerHeight;
                            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
                        }
                        var scrollLeft = this.scrollLeft;
                        if (scrollLeft > left) {
                            if (left < this.$padding + 2 * this.layerConfig.characterWidth) left = -this.scrollMargin.left;
                            this.session.setScrollLeft(left);
                        } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
                            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
                        } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
                            this.session.setScrollLeft(0);
                        }
                    }
                }, {
                    key: "getScrollTop",
                    value: function getScrollTop() {
                        return this.session.getScrollTop();
                    }
                }, {
                    key: "getScrollLeft",
                    value: function getScrollLeft() {
                        return this.session.getScrollLeft();
                    }
                }, {
                    key: "getScrollTopRow",
                    value: function getScrollTopRow() {
                        return this.scrollTop / this.lineHeight;
                    }
                }, {
                    key: "getScrollBottomRow",
                    value: function getScrollBottomRow() {
                        return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
                    }
                }, {
                    key: "scrollToRow",
                    value: function scrollToRow(row) {
                        this.session.setScrollTop(row * this.lineHeight);
                    }
                }, {
                    key: "alignCursor",
                    value: function alignCursor(cursor, alignment) {
                        if (typeof cursor == "number") cursor = { row: cursor, column: 0 };
                        var pos = this.$cursorLayer.getPixelPosition(cursor);
                        var h = this.$size.scrollerHeight - this.lineHeight;
                        var offset = pos.top - h * (alignment || 0);
                        this.session.setScrollTop(offset);
                        return offset;
                    }
                }, {
                    key: "$calcSteps",
                    value: function $calcSteps(fromValue, toValue) {
                        var i = 0;
                        var l = this.STEPS;
                        var steps = [];
                        var func = function func(t, x_min, dx) {
                            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
                        };
                        for (i = 0; i < l; ++i) {
                            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
                        }
                        return steps;
                    }
                }, {
                    key: "scrollToLine",
                    value: function scrollToLine(line, center, animate, callback) {
                        var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
                        var offset = pos.top;
                        if (center) {
                            offset -= this.$size.scrollerHeight / 2;
                        }
                        var initialScroll = this.scrollTop;
                        this.session.setScrollTop(offset);
                        if (animate !== false) {
                            this.animateScrolling(initialScroll, callback);
                        }
                    }
                }, {
                    key: "animateScrolling",
                    value: function animateScrolling(fromValue, callback) {
                        var toValue = this.scrollTop;
                        if (!this.$animatedScroll) {
                            return;
                        }
                        var _self = this;
                        if (fromValue == toValue) return;
                        if (this.$scrollAnimation) {
                            var oldSteps = this.$scrollAnimation.steps;
                            if (oldSteps.length) {
                                fromValue = oldSteps[0];
                                if (fromValue == toValue) return;
                            }
                        }
                        var steps = _self.$calcSteps(fromValue, toValue);
                        this.$scrollAnimation = { from: fromValue, to: toValue, steps: steps };
                        clearInterval(this.$timer);
                        _self.session.setScrollTop(steps.shift());
                        _self.session.$scrollTop = toValue;
                        this.$timer = setInterval(function () {
                            if (steps.length) {
                                _self.session.setScrollTop(steps.shift());
                                _self.session.$scrollTop = toValue;
                            } else if (toValue != null) {
                                _self.session.$scrollTop = -1;
                                _self.session.setScrollTop(toValue);
                                toValue = null;
                            } else {
                                _self.$timer = clearInterval(_self.$timer);
                                _self.$scrollAnimation = null;
                                callback && callback();
                            }
                        }, 10);
                    }
                }, {
                    key: "scrollToY",
                    value: function scrollToY(scrollTop) {
                        if (this.scrollTop !== scrollTop) {
                            this.scrollTop = scrollTop;
                            this.$loop.schedule(CHANGE_SCROLL);
                        }
                    }
                }, {
                    key: "scrollToX",
                    value: function scrollToX(scrollLeft) {
                        if (this.scrollLeft !== scrollLeft) {
                            this.scrollLeft = scrollLeft;
                            this.$loop.schedule(CHANGE_H_SCROLL);
                        }
                    }
                }, {
                    key: "scrollTo",
                    value: function scrollTo(x, y) {
                        this.session.setScrollTop(y);
                        this.session.setScrollLeft(y);
                    }
                }, {
                    key: "scrollBy",
                    value: function scrollBy(deltaX, deltaY) {
                        deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
                        deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
                    }
                }, {
                    key: "isScrollableBy",
                    value: function isScrollableBy(deltaX, deltaY) {
                        if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
                        if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
                        if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
                        if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
                    }
                }, {
                    key: "pixelToScreenCoordinates",
                    value: function pixelToScreenCoordinates(x, y) {
                        var canvasPos = this.scroller.getBoundingClientRect();
                        var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
                        var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
                        var col = Math.round(offset);
                        return { row: row, column: col, side: offset - col > 0 ? 1 : -1 };
                    }
                }, {
                    key: "screenToTextCoordinates",
                    value: function screenToTextCoordinates(clientX, clientY) {
                        var canvasPos = this.scroller.getBoundingClientRect();
                        var column = Math.round((clientX + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);
                        var row = (clientY + this.scrollTop - canvasPos.top) / this.lineHeight;
                        return this.session.screenToDocumentPosition(row, Math.max(column, 0));
                    }
                }, {
                    key: "textToScreenCoordinates",
                    value: function textToScreenCoordinates(row, column) {
                        var canvasPos = this.scroller.getBoundingClientRect();
                        var pos = this.session.documentToScreenPosition(row, column);
                        var x = this.$padding + Math.round(pos.column * this.characterWidth);
                        var y = pos.row * this.lineHeight;
                        return {
                            pageX: canvasPos.left + x - this.scrollLeft,
                            pageY: canvasPos.top + y - this.scrollTop
                        };
                    }
                }, {
                    key: "visualizeFocus",
                    value: function visualizeFocus() {
                        _addCssClass(this.container, "ace_focus");
                    }
                }, {
                    key: "visualizeBlur",
                    value: function visualizeBlur() {
                        removeCssClass(this.container, "ace_focus");
                    }
                }, {
                    key: "showComposition",
                    value: function showComposition(position) {
                        if (!this.$composition) this.$composition = {
                            keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
                            cssText: this.textarea.style.cssText
                        };
                        this.$keepTextAreaAtCursor = true;
                        _addCssClass(this.textarea, "ace_composition");
                        this.textarea.style.cssText = "";
                        this.$moveTextAreaToCursor();
                    }
                }, {
                    key: "setCompositionText",
                    value: function setCompositionText(text) {
                        this.$moveTextAreaToCursor();
                    }
                }, {
                    key: "hideComposition",
                    value: function hideComposition() {
                        if (!this.$composition) {
                            return;
                        }
                        removeCssClass(this.textarea, "ace_composition");
                        this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
                        this.textarea.style.cssText = this.$composition.cssText;
                        this.$composition = null;
                    }
                }, {
                    key: "setTheme",
                    value: function setTheme(modJs) {
                        if (!modJs.cssClass) {
                            return;
                        }
                        ensureHTMLStyleElement(modJs.cssText, modJs.cssClass, this.container.ownerDocument);
                        if (this.theme) {
                            removeCssClass(this.container, this.theme.cssClass);
                        }
                        var padding = "padding" in modJs ? modJs.padding : "padding" in (this.theme || {}) ? 4 : this.$padding;
                        if (this.$padding && padding != this.$padding) {
                            this.setPadding(padding);
                        }
                        this.theme = modJs;
                        this.addCssClass(modJs.cssClass);
                        this.setCssClass("ace_dark", modJs.isDark);
                        if (this.$size) {
                            this.$size.width = 0;
                            this.$updateSizeAsync();
                        }
                        this.eventBus._emit('themeLoaded', { theme: modJs });
                    }
                }, {
                    key: "addCssClass",
                    value: function addCssClass(cssClass) {
                        _addCssClass(this.container, cssClass);
                    }
                }, {
                    key: "setCssClass",
                    value: function setCssClass(className, include) {
                        _setCssClass(this.container, className, include);
                    }
                }, {
                    key: "importThemeLink",
                    value: function importThemeLink(themeName) {
                        if (!themeName || typeof themeName === "string") {
                            themeName = themeName || this.getOption("theme").initialValue;
                        }
                        var _self = this;
                        this.$themeId = themeName;
                        _self.eventBus._emit('themeChange', { theme: themeName });
                        return new _Promise(function (success, fail) {
                            System["import"](themeName).then(function (m) {
                                var isDark = m.isDark;
                                var id = m.cssClass;
                                var href = m.cssName;
                                var padding = typeof m.padding === 'number' ? m.padding : 0;
                                var theme = new ThemeLink(isDark, id, 'stylesheet', 'text/css', href, padding);
                                success(theme);
                            })["catch"](function (reason) {
                                console.warn("" + reason);
                                fail(reason);
                            });
                        });
                    }
                }, {
                    key: "setThemeCss",
                    value: function setThemeCss(cssClass, href) {
                        appendHTMLLinkElement(cssClass, 'stylesheet', 'text/css', href, document);
                        this.addCssClass(cssClass);
                    }
                }, {
                    key: "getTheme",
                    value: function getTheme() {
                        return this.$themeId;
                    }
                }, {
                    key: "setStyle",
                    value: function setStyle(style, include) {
                        _setCssClass(this.container, style, include !== false);
                    }
                }, {
                    key: "unsetStyle",
                    value: function unsetStyle(style) {
                        removeCssClass(this.container, style);
                    }
                }, {
                    key: "setCursorStyle",
                    value: function setCursorStyle(style) {
                        if (this.content.style.cursor != style) {
                            this.content.style.cursor = style;
                        }
                    }
                }, {
                    key: "setMouseCursor",
                    value: function setMouseCursor(cursorStyle) {
                        this.content.style.cursor = cursorStyle;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.$textLayer.destroy();
                        this.$cursorLayer.destroy();
                    }
                }, {
                    key: "maxLines",
                    set: function set(maxLines) {
                        this.$maxLines = maxLines;
                    }
                }, {
                    key: "keepTextAreaAtCursor",
                    set: function set(keepTextAreaAtCursor) {
                        this.$keepTextAreaAtCursor = keepTextAreaAtCursor;
                    }
                }]);

                return VirtualRenderer;
            })();

            _export("default", VirtualRenderer);

            defineOptions(VirtualRenderer.prototype, "renderer", {
                animatedScroll: { initialValue: false },
                showInvisibles: {
                    set: function set(value) {
                        if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: false
                },
                showPrintMargin: {
                    set: function set() {
                        this.$updatePrintMargin();
                    },
                    initialValue: true
                },
                printMarginColumn: {
                    set: function set() {
                        this.$updatePrintMargin();
                    },
                    initialValue: 80
                },
                printMargin: {
                    set: function set(val) {
                        if (typeof val == "number") this.$printMarginColumn = val;
                        this.$showPrintMargin = !!val;
                        this.$updatePrintMargin();
                    },
                    get: function get() {
                        return this.$showPrintMargin && this.$printMarginColumn;
                    }
                },
                showGutter: {
                    set: function set(show) {
                        this.$gutter.style.display = show ? "block" : "none";
                        this.$loop.schedule(this.CHANGE_FULL);
                        this.onGutterResize();
                    },
                    initialValue: true
                },
                fadeFoldWidgets: {
                    set: function set(show) {
                        _setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
                    },
                    initialValue: false
                },
                showFoldWidgets: {
                    set: function set(show) {
                        this.$gutterLayer.setShowFoldWidgets(show);
                    },
                    initialValue: true
                },
                showLineNumbers: {
                    set: function set(show) {
                        this.$gutterLayer.setShowLineNumbers(show);
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    },
                    initialValue: true
                },
                displayIndentGuides: {
                    set: function set(show) {
                        if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
                    },
                    initialValue: true
                },
                highlightGutterLine: {
                    set: function set(shouldHighlight) {
                        if (!this.$gutterLineHighlight) {
                            this.$gutterLineHighlight = createElement("div");
                            this.$gutterLineHighlight.className = "ace_gutter-active-line";
                            this.$gutter.appendChild(this.$gutterLineHighlight);
                            return;
                        }
                        this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
                        if (this.$cursorLayer.$pixelPos) this.$updateGutterLineHighlight();
                    },
                    initialValue: false,
                    value: true
                },
                hScrollBarAlwaysVisible: {
                    set: function set(val) {
                        if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                vScrollBarAlwaysVisible: {
                    set: function set(val) {
                        if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: false
                },
                fontSize: {
                    set: function set(fontSize) {
                        var that = this;
                        that.container.style.fontSize = fontSize;
                        that.updateFontSize();
                    },
                    initialValue: "12px"
                },
                fontFamily: {
                    set: function set(fontFamily) {
                        var that = this;
                        that.container.style.fontFamily = fontFamily;
                        that.updateFontSize();
                    }
                },
                maxLines: {
                    set: function set(val) {
                        this.updateFull();
                    }
                },
                minLines: {
                    set: function set(val) {
                        this.updateFull();
                    }
                },
                scrollPastEnd: {
                    set: function set(val) {
                        val = +val || 0;
                        if (this.$scrollPastEnd == val) return;
                        this.$scrollPastEnd = val;
                        this.$loop.schedule(this.CHANGE_SCROLL);
                    },
                    initialValue: 0,
                    handlesSet: true
                },
                fixedWidthGutter: {
                    set: function set(val) {
                        this.$gutterLayer.$fixedWidth = !!val;
                        this.$loop.schedule(this.CHANGE_GUTTER);
                    }
                },
                theme: {
                    set: function set(val) {
                        this.setTheme(val);
                    },
                    get: function get() {
                        return this.$themeId || this.theme;
                    },
                    initialValue: "./theme/textmate",
                    handlesSet: true
                }
            });
        }
    };
});
System.register("src/mode/behaviour/CssBehaviour.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/behaviour/CstyleBehaviour.js", "src/TokenIterator.js"], function (_export) {
    var _get, _inherits, _classCallCheck, CstyleBehaviour, TokenIterator, CssBehavior;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeBehaviourCstyleBehaviourJs) {
            CstyleBehaviour = _srcModeBehaviourCstyleBehaviourJs["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }],
        execute: function () {
            "use strict";

            CssBehavior = (function (_CstyleBehaviour) {
                _inherits(CssBehavior, _CstyleBehaviour);

                function CssBehavior() {
                    _classCallCheck(this, CssBehavior);

                    _get(Object.getPrototypeOf(CssBehavior.prototype), "constructor", this).call(this);
                    this.inherit(new CstyleBehaviour());
                    this.add("colon", "insertion", function (state, action, editor, session, text) {
                        if (text === ':') {
                            var cursor = editor.getCursorPosition();
                            var iterator = new TokenIterator(session, cursor.row, cursor.column);
                            var token = iterator.getCurrentToken();
                            if (token && token.value.match(/\s+/)) {
                                token = iterator.stepBackward();
                            }
                            if (token && token.type === 'support.type') {
                                var line = session.doc.getLine(cursor.row);
                                var rightChar = line.substring(cursor.column, cursor.column + 1);
                                if (rightChar === ':') {
                                    return {
                                        text: '',
                                        selection: [1, 1]
                                    };
                                }
                                if (!line.substring(cursor.column).match(/^\s*;/)) {
                                    return {
                                        text: ':;',
                                        selection: [1, 1]
                                    };
                                }
                            }
                        }
                    });
                    this.add("colon", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected === ':') {
                            var cursor = editor.getCursorPosition();
                            var iterator = new TokenIterator(session, cursor.row, cursor.column);
                            var token = iterator.getCurrentToken();
                            if (token && token.value.match(/\s+/)) {
                                token = iterator.stepBackward();
                            }
                            if (token && token.type === 'support.type') {
                                var line = session.doc.getLine(range.start.row);
                                var rightChar = line.substring(range.end.column, range.end.column + 1);
                                if (rightChar === ';') {
                                    range.end.column++;
                                    return range;
                                }
                            }
                        }
                    });
                    this.add("semicolon", "insertion", function (state, action, editor, session, text) {
                        if (text === ';') {
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === ';') {
                                return {
                                    text: '',
                                    selection: [1, 1]
                                };
                            }
                        }
                    });
                }

                return CssBehavior;
            })(CstyleBehaviour);

            _export("default", CssBehavior);
        }
    };
});
System.register("src/mode/CssMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/mode/TextMode.js", "src/mode/CssHighlightRules.js", "src/mode/MatchingBraceOutdent.js", "src/worker/WorkerClient.js", "src/mode/behaviour/CssBehaviour.js", "src/mode/folding/CstyleFoldMode.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _Promise, TextMode, CssHighlightRules, MatchingBraceOutdent, WorkerClient, CssBehaviour, CStyleFoldMode, CssMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcModeTextModeJs) {
            TextMode = _srcModeTextModeJs["default"];
        }, function (_srcModeCssHighlightRulesJs) {
            CssHighlightRules = _srcModeCssHighlightRulesJs["default"];
        }, function (_srcModeMatchingBraceOutdentJs) {
            MatchingBraceOutdent = _srcModeMatchingBraceOutdentJs["default"];
        }, function (_srcWorkerWorkerClientJs) {
            WorkerClient = _srcWorkerWorkerClientJs["default"];
        }, function (_srcModeBehaviourCssBehaviourJs) {
            CssBehaviour = _srcModeBehaviourCssBehaviourJs["default"];
        }, function (_srcModeFoldingCstyleFoldModeJs) {
            CStyleFoldMode = _srcModeFoldingCstyleFoldModeJs["default"];
        }],
        execute: function () {
            "use strict";

            CssMode = (function (_TextMode) {
                _inherits(CssMode, _TextMode);

                function CssMode(workerUrl, scriptImports) {
                    _classCallCheck(this, CssMode);

                    _get(Object.getPrototypeOf(CssMode.prototype), "constructor", this).call(this, workerUrl, scriptImports);
                    this.$id = "ace/mode/css";
                    this.blockComment = { start: "/*", end: "*/" };
                    this.HighlightRules = CssHighlightRules;
                    this.$outdent = new MatchingBraceOutdent();
                    this.$behaviour = new CssBehaviour();
                    this.foldingRules = new CStyleFoldMode();
                }

                _createClass(CssMode, [{
                    key: "getNextLineIndent",
                    value: function getNextLineIndent(state, line, tab) {
                        var indent = this.$getIndent(line);
                        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;
                        if (tokens.length && tokens[tokens.length - 1].type == "comment") {
                            return indent;
                        }
                        var match = line.match(/^.*\{\s*$/);
                        if (match) {
                            indent += tab;
                        }
                        return indent;
                    }
                }, {
                    key: "checkOutdent",
                    value: function checkOutdent(state, line, text) {
                        return this.$outdent.checkOutdent(line, text);
                    }
                }, {
                    key: "autoOutdent",
                    value: function autoOutdent(state, session, row) {
                        return this.$outdent.autoOutdent(session, row);
                    }
                }, {
                    key: "createWorker",
                    value: function createWorker(session) {
                        var workerUrl = this.workerUrl;
                        var scriptImports = this.scriptImports;
                        return new _Promise(function (resolve, reject) {
                            var worker = new WorkerClient(workerUrl);
                            worker.on("initAfter", function () {
                                worker.attachToDocument(session.getDocument());
                                resolve(worker);
                            });
                            worker.on("initFail", function (message) {
                                reject(new Error("" + message));
                            });
                            worker.on("errors", function (message) {
                                session.setAnnotations(message.data);
                            });
                            worker.on("terminate", function () {
                                worker.detachFromDocument();
                                session.clearAnnotations();
                            });
                            worker.init(scriptImports, 'ace-workers.js', 'CssWorker');
                        });
                    }
                }]);

                return CssMode;
            })(TextMode);

            _export("default", CssMode);
        }
    };
});
System.register("src/mode/CssHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/TextHighlightRules.js"], function (_export) {
    var _get, _inherits, _classCallCheck, TextHighlightRules, supportType, supportFunction, supportConstant, supportConstantColor, supportConstantFonts, numRe, pseudoElements, pseudoClasses, CssHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeTextHighlightRulesJs) {
            TextHighlightRules = _srcModeTextHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";
            supportType = "animation-fill-mode|alignment-adjust|alignment-baseline|animation-delay|animation-direction|animation-duration|animation-iteration-count|animation-name|animation-play-state|animation-timing-function|animation|appearance|azimuth|backface-visibility|background-attachment|background-break|background-clip|background-color|background-image|background-origin|background-position|background-repeat|background-size|background|baseline-shift|binding|bleed|bookmark-label|bookmark-level|bookmark-state|bookmark-target|border-bottom|border-bottom-color|border-bottom-left-radius|border-bottom-right-radius|border-bottom-style|border-bottom-width|border-collapse|border-color|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-left|border-left-color|border-left-style|border-left-width|border-radius|border-right|border-right-color|border-right-style|border-right-width|border-spacing|border-style|border-top|border-top-color|border-top-left-radius|border-top-right-radius|border-top-style|border-top-width|border-width|border|bottom|box-align|box-decoration-break|box-direction|box-flex-group|box-flex|box-lines|box-ordinal-group|box-orient|box-pack|box-shadow|box-sizing|break-after|break-before|break-inside|caption-side|clear|clip|color-profile|color|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|content|counter-increment|counter-reset|crop|cue-after|cue-before|cue|cursor|direction|display|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|elevation|empty-cells|fit|fit-position|float-offset|float|font-family|font-size|font-size-adjust|font-stretch|font-style|font-variant|font-weight|font|grid-columns|grid-rows|hanging-punctuation|height|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|icon|image-orientation|image-rendering|image-resolution|inline-box-align|left|letter-spacing|line-height|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|line-stacking|list-style-image|list-style-position|list-style-type|list-style|margin-bottom|margin-left|margin-right|margin-top|margin|mark-after|mark-before|mark|marks|marquee-direction|marquee-play-count|marquee-speed|marquee-style|max-height|max-width|min-height|min-width|move-to|nav-down|nav-index|nav-left|nav-right|nav-up|opacity|orphans|outline-color|outline-offset|outline-style|outline-width|outline|overflow-style|overflow-x|overflow-y|overflow|padding-bottom|padding-left|padding-right|padding-top|padding|page-break-after|page-break-before|page-break-inside|page-policy|page|pause-after|pause-before|pause|perspective-origin|perspective|phonemes|pitch-range|pitch|play-during|pointer-events|position|presentation-level|punctuation-trim|quotes|rendering-intent|resize|rest-after|rest-before|rest|richness|right|rotation-point|rotation|ruby-align|ruby-overhang|ruby-position|ruby-span|size|speak-header|speak-numeral|speak-punctuation|speak|speech-rate|stress|string-set|table-layout|target-name|target-new|target-position|target|text-align-last|text-align|text-decoration|text-emphasis|text-height|text-indent|text-justify|text-outline|text-shadow|text-transform|text-wrap|top|transform-origin|transform-style|transform|transition-delay|transition-duration|transition-property|transition-timing-function|transition|unicode-bidi|vertical-align|visibility|voice-balance|voice-duration|voice-family|voice-pitch-range|voice-pitch|voice-rate|voice-stress|voice-volume|volume|white-space-collapse|white-space|widows|width|word-break|word-spacing|word-wrap|z-index";

            _export("supportType", supportType);

            supportFunction = "rgb|rgba|url|attr|counter|counters";

            _export("supportFunction", supportFunction);

            supportConstant = "absolute|after-edge|after|all-scroll|all|alphabetic|always|antialiased|armenian|auto|avoid-column|avoid-page|avoid|balance|baseline|before-edge|before|below|bidi-override|block-line-height|block|bold|bolder|border-box|both|bottom|box|break-all|break-word|capitalize|caps-height|caption|center|central|char|circle|cjk-ideographic|clone|close-quote|col-resize|collapse|column|consider-shifts|contain|content-box|cover|crosshair|cubic-bezier|dashed|decimal-leading-zero|decimal|default|disabled|disc|disregard-shifts|distribute-all-lines|distribute-letter|distribute-space|distribute|dotted|double|e-resize|ease-in|ease-in-out|ease-out|ease|ellipsis|end|exclude-ruby|fill|fixed|georgian|glyphs|grid-height|groove|hand|hanging|hebrew|help|hidden|hiragana-iroha|hiragana|horizontal|icon|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space|ideographic|inactive|include-ruby|inherit|initial|inline-block|inline-box|inline-line-height|inline-table|inline|inset|inside|inter-ideograph|inter-word|invert|italic|justify|katakana-iroha|katakana|keep-all|last|left|lighter|line-edge|line-through|line|linear|list-item|local|loose|lower-alpha|lower-greek|lower-latin|lower-roman|lowercase|lr-tb|ltr|mathematical|max-height|max-size|medium|menu|message-box|middle|move|n-resize|ne-resize|newspaper|no-change|no-close-quote|no-drop|no-open-quote|no-repeat|none|normal|not-allowed|nowrap|nw-resize|oblique|open-quote|outset|outside|overline|padding-box|page|pointer|pre-line|pre-wrap|pre|preserve-3d|progress|relative|repeat-x|repeat-y|repeat|replaced|reset-size|ridge|right|round|row-resize|rtl|s-resize|scroll|se-resize|separate|slice|small-caps|small-caption|solid|space|square|start|static|status-bar|step-end|step-start|steps|stretch|strict|sub|super|sw-resize|table-caption|table-cell|table-column-group|table-column|table-footer-group|table-header-group|table-row-group|table-row|table|tb-rl|text-after-edge|text-before-edge|text-bottom|text-size|text-top|text|thick|thin|transparent|underline|upper-alpha|upper-latin|upper-roman|uppercase|use-script|vertical-ideographic|vertical-text|visible|w-resize|wait|whitespace|z-index|zero";

            _export("supportConstant", supportConstant);

            supportConstantColor = "aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow";

            _export("supportConstantColor", supportConstantColor);

            supportConstantFonts = "arial|century|comic|courier|garamond|georgia|helvetica|impact|lucida|symbol|system|tahoma|times|trebuchet|utopia|verdana|webdings|sans-serif|serif|monospace";

            _export("supportConstantFonts", supportConstantFonts);

            numRe = "\\-?(?:(?:[0-9]+)|(?:[0-9]*\\.[0-9]+))";

            _export("numRe", numRe);

            pseudoElements = "(\\:+)\\b(after|before|first-letter|first-line|moz-selection|selection)\\b";

            _export("pseudoElements", pseudoElements);

            pseudoClasses = "(:)\\b(active|checked|disabled|empty|enabled|first-child|first-of-type|focus|hover|indeterminate|invalid|last-child|last-of-type|link|not|nth-child|nth-last-child|nth-last-of-type|nth-of-type|only-child|only-of-type|required|root|target|valid|visited)\\b";

            _export("pseudoClasses", pseudoClasses);

            CssHighlightRules = (function (_TextHighlightRules) {
                _inherits(CssHighlightRules, _TextHighlightRules);

                function CssHighlightRules() {
                    _classCallCheck(this, CssHighlightRules);

                    _get(Object.getPrototypeOf(CssHighlightRules.prototype), "constructor", this).call(this);
                    var keywordMapper = this.createKeywordMapper({
                        "support.function": supportFunction,
                        "support.constant": supportConstant,
                        "support.type": supportType,
                        "support.constant.color": supportConstantColor,
                        "support.constant.fonts": supportConstantFonts
                    }, "text", true);
                    this.$rules = {
                        "start": [{
                            token: "comment",
                            regex: "\\/\\*",
                            push: "comment"
                        }, {
                            token: "paren.lparen",
                            regex: "\\{",
                            push: "ruleset"
                        }, {
                            token: "string",
                            regex: "@.*?{",
                            push: "media"
                        }, {
                            token: "keyword",
                            regex: "#[a-z0-9-_]+"
                        }, {
                            token: "variable",
                            regex: "\\.[a-z0-9-_]+"
                        }, {
                            token: "string",
                            regex: ":[a-z0-9-_]+"
                        }, {
                            token: "constant",
                            regex: "[a-z0-9-_]+"
                        }, {
                            caseInsensitive: true
                        }],
                        "media": [{
                            token: "comment",
                            regex: "\\/\\*",
                            push: "comment"
                        }, {
                            token: "paren.lparen",
                            regex: "\\{",
                            push: "ruleset"
                        }, {
                            token: "string",
                            regex: "\\}",
                            next: "pop"
                        }, {
                            token: "keyword",
                            regex: "#[a-z0-9-_]+"
                        }, {
                            token: "variable",
                            regex: "\\.[a-z0-9-_]+"
                        }, {
                            token: "string",
                            regex: ":[a-z0-9-_]+"
                        }, {
                            token: "constant",
                            regex: "[a-z0-9-_]+"
                        }, {
                            caseInsensitive: true
                        }],
                        "comment": [{
                            token: "comment",
                            regex: "\\*\\/",
                            next: "pop"
                        }, {
                            defaultToken: "comment"
                        }],
                        "ruleset": [{
                            token: "paren.rparen",
                            regex: "\\}",
                            next: "pop"
                        }, {
                            token: "comment",
                            regex: "\\/\\*",
                            push: "comment"
                        }, {
                            token: "string",
                            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]'
                        }, {
                            token: "string",
                            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
                        }, {
                            token: ["constant.numeric", "keyword"],
                            regex: "(" + numRe + ")(ch|cm|deg|em|ex|fr|gd|grad|Hz|in|kHz|mm|ms|pc|pt|px|rad|rem|s|turn|vh|vm|vw|%)"
                        }, {
                            token: "constant.numeric",
                            regex: numRe
                        }, {
                            token: "constant.numeric",
                            regex: "#[a-f0-9]{6}"
                        }, {
                            token: "constant.numeric",
                            regex: "#[a-f0-9]{3}"
                        }, {
                            token: ["punctuation", "entity.other.attribute-name.pseudo-element.css"],
                            regex: pseudoElements
                        }, {
                            token: ["punctuation", "entity.other.attribute-name.pseudo-class.css"],
                            regex: pseudoClasses
                        }, {
                            token: ["support.function", "string", "support.function"],
                            regex: "(url\\()(.*)(\\))"
                        }, {
                            token: keywordMapper,
                            regex: "\\-?[a-zA-Z_][a-zA-Z0-9_\\-]*"
                        }, {
                            caseInsensitive: true
                        }]
                    };
                    this.normalizeRules();
                }

                return CssHighlightRules;
            })(TextHighlightRules);

            _export("default", CssHighlightRules);
        }
    };
});
System.register("src/mode/XmlHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/TextHighlightRules.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, TextHighlightRules, XmlHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeTextHighlightRulesJs) {
            TextHighlightRules = _srcModeTextHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";

            XmlHighlightRules = (function (_TextHighlightRules) {
                _inherits(XmlHighlightRules, _TextHighlightRules);

                function XmlHighlightRules(normalize) {
                    _classCallCheck(this, XmlHighlightRules);

                    _get(Object.getPrototypeOf(XmlHighlightRules.prototype), "constructor", this).call(this);
                    this.$rules = {
                        start: [{ token: "string.cdata.xml", regex: "<\\!\\[CDATA\\[", next: "cdata" }, {
                            token: ["punctuation.xml-decl.xml", "keyword.xml-decl.xml"],
                            regex: "(<\\?)(xml)(?=[\\s])", next: "xml_decl", caseInsensitive: true
                        }, {
                            token: ["punctuation.instruction.xml", "keyword.instruction.xml"],
                            regex: "(<\\?)([-_a-zA-Z0-9]+)", next: "processing_instruction"
                        }, { token: "comment.xml", regex: "<\\!--", next: "comment" }, {
                            token: ["xml-pe.doctype.xml", "xml-pe.doctype.xml"],
                            regex: "(<\\!)(DOCTYPE)(?=[\\s])", next: "doctype", caseInsensitive: true
                        }, { include: "tag" }, { token: "text.end-tag-open.xml", regex: "</" }, { token: "text.tag-open.xml", regex: "<" }, { include: "reference" }, { defaultToken: "text.xml" }],
                        xml_decl: [{
                            token: "entity.other.attribute-name.decl-attribute-name.xml",
                            regex: "(?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+"
                        }, {
                            token: "keyword.operator.decl-attribute-equals.xml",
                            regex: "="
                        }, {
                            include: "whitespace"
                        }, {
                            include: "string"
                        }, {
                            token: "punctuation.xml-decl.xml",
                            regex: "\\?>",
                            next: "start"
                        }],
                        processing_instruction: [{ token: "punctuation.instruction.xml", regex: "\\?>", next: "start" }, { defaultToken: "instruction.xml" }],
                        doctype: [{ include: "whitespace" }, { include: "string" }, { token: "xml-pe.doctype.xml", regex: ">", next: "start" }, { token: "xml-pe.xml", regex: "[-_a-zA-Z0-9:]+" }, { token: "punctuation.int-subset", regex: "\\[", push: "int_subset" }],
                        int_subset: [{
                            token: "text.xml",
                            regex: "\\s+"
                        }, {
                            token: "punctuation.int-subset.xml",
                            regex: "]",
                            next: "pop"
                        }, {
                            token: ["punctuation.markup-decl.xml", "keyword.markup-decl.xml"],
                            regex: "(<\\!)([-_a-zA-Z0-9]+)",
                            push: [{
                                token: "text",
                                regex: "\\s+"
                            }, {
                                token: "punctuation.markup-decl.xml",
                                regex: ">",
                                next: "pop"
                            }, { include: "string" }]
                        }],
                        cdata: [{ token: "string.cdata.xml", regex: "\\]\\]>", next: "start" }, { token: "text.xml", regex: "\\s+" }, { token: "text.xml", regex: "(?:[^\\]]|\\](?!\\]>))+" }],
                        comment: [{ token: "comment.xml", regex: "-->", next: "start" }, { defaultToken: "comment.xml" }],
                        reference: [{
                            token: "constant.language.escape.reference.xml",
                            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                        }],
                        attr_reference: [{
                            token: "constant.language.escape.reference.attribute-value.xml",
                            regex: "(?:&#[0-9]+;)|(?:&#x[0-9a-fA-F]+;)|(?:&[a-zA-Z0-9_:\\.-]+;)"
                        }],
                        tag: [{
                            token: ["meta.tag.punctuation.tag-open.xml", "meta.tag.punctuation.end-tag-open.xml", "meta.tag.tag-name.xml"],
                            regex: "(?:(<)|(</))((?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+)",
                            next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                        }],
                        tag_whitespace: [{ token: "text.tag-whitespace.xml", regex: "\\s+" }],
                        whitespace: [{ token: "text.whitespace.xml", regex: "\\s+" }],
                        string: [{
                            token: "string.xml",
                            regex: "'",
                            push: [{ token: "string.xml", regex: "'", next: "pop" }, { defaultToken: "string.xml" }]
                        }, {
                            token: "string.xml",
                            regex: '"',
                            push: [{ token: "string.xml", regex: '"', next: "pop" }, { defaultToken: "string.xml" }]
                        }],
                        attributes: [{
                            token: "entity.other.attribute-name.xml",
                            regex: "(?:[-_a-zA-Z0-9]+:)?[-_a-zA-Z0-9]+"
                        }, {
                            token: "keyword.operator.attribute-equals.xml",
                            regex: "="
                        }, {
                            include: "tag_whitespace"
                        }, {
                            include: "attribute_value"
                        }],
                        attribute_value: [{
                            token: "string.attribute-value.xml",
                            regex: "'",
                            push: [{ token: "string.attribute-value.xml", regex: "'", next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                        }, {
                            token: "string.attribute-value.xml",
                            regex: '"',
                            push: [{ token: "string.attribute-value.xml", regex: '"', next: "pop" }, { include: "attr_reference" }, { defaultToken: "string.attribute-value.xml" }]
                        }]
                    };
                    if (this.constructor === XmlHighlightRules) this.normalizeRules();
                }

                _createClass(XmlHighlightRules, [{
                    key: "embedTagRules",
                    value: function embedTagRules(HighlightRules, prefix, tag) {
                        this.$rules.tag.unshift({
                            token: ["meta.tag.punctuation.tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                            regex: "(<)(" + tag + "(?=\\s|>|$))",
                            next: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: prefix + "start" }]
                        });
                        this.$rules[tag + "-end"] = [{ include: "attributes" }, {
                            token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start",
                            onMatch: function onMatch(value, currentState, stack) {
                                stack.splice(0);
                                return this.token;
                            }
                        }];
                        this.embedRules(HighlightRules, prefix, [{
                            token: ["meta.tag.punctuation.end-tag-open.xml", "meta.tag." + tag + ".tag-name.xml"],
                            regex: "(</)(" + tag + "(?=\\s|>|$))",
                            next: tag + "-end"
                        }, {
                            token: "string.cdata.xml",
                            regex: "<\\!\\[CDATA\\["
                        }, {
                            token: "string.cdata.xml",
                            regex: "\\]\\]>"
                        }]);
                    }
                }]);

                return XmlHighlightRules;
            })(TextHighlightRules);

            _export("default", XmlHighlightRules);
        }
    };
});
System.register("src/mode/HtmlHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/lang.js", "src/mode/CssHighlightRules.js", "src/mode/JavaScriptHighlightRules.js", "src/mode/XmlHighlightRules.js"], function (_export) {
    var _get, _inherits, _classCallCheck, createMap, CssHighlightRules, JavaScriptHighlightRules, XmlHighlightRules, tagMap, HtmlHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibLangJs) {
            createMap = _srcLibLangJs.createMap;
        }, function (_srcModeCssHighlightRulesJs) {
            CssHighlightRules = _srcModeCssHighlightRulesJs["default"];
        }, function (_srcModeJavaScriptHighlightRulesJs) {
            JavaScriptHighlightRules = _srcModeJavaScriptHighlightRulesJs["default"];
        }, function (_srcModeXmlHighlightRulesJs) {
            XmlHighlightRules = _srcModeXmlHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";
            tagMap = createMap({
                a: 'anchor',
                button: 'form',
                form: 'form',
                img: 'image',
                input: 'form',
                label: 'form',
                option: 'form',
                script: 'script',
                select: 'form',
                textarea: 'form',
                style: 'style',
                table: 'table',
                tbody: 'table',
                td: 'table',
                tfoot: 'table',
                th: 'table',
                tr: 'table'
            });

            HtmlHighlightRules = (function (_XmlHighlightRules) {
                _inherits(HtmlHighlightRules, _XmlHighlightRules);

                function HtmlHighlightRules() {
                    _classCallCheck(this, HtmlHighlightRules);

                    _get(Object.getPrototypeOf(HtmlHighlightRules.prototype), "constructor", this).call(this);
                    this.addRules({
                        attributes: [{
                            include: "tag_whitespace"
                        }, {
                            token: "entity.other.attribute-name.xml",
                            regex: "[-_a-zA-Z0-9:]+"
                        }, {
                            token: "keyword.operator.attribute-equals.xml",
                            regex: "=",
                            push: [{
                                include: "tag_whitespace"
                            }, {
                                token: "string.unquoted.attribute-value.html",
                                regex: "[^<>='\"`\\s]+",
                                next: "pop"
                            }, {
                                token: "empty",
                                regex: "",
                                next: "pop"
                            }]
                        }, {
                            include: "attribute_value"
                        }],
                        tag: [{
                            token: function token(start, tag) {
                                var group = tagMap[tag];
                                return ["meta.tag.punctuation." + (start == "<" ? "" : "end-") + "tag-open.xml", "meta.tag" + (group ? "." + group : "") + ".tag-name.xml"];
                            },
                            regex: "(</?)([-_a-zA-Z0-9:]+)",
                            next: "tag_stuff"
                        }],
                        tag_stuff: [{ include: "attributes" }, { token: "meta.tag.punctuation.tag-close.xml", regex: "/?>", next: "start" }]
                    });
                    this.embedTagRules(CssHighlightRules, "css-", "style");
                    this.embedTagRules(JavaScriptHighlightRules, "js-", "script");
                    if (this.constructor === HtmlHighlightRules) this.normalizeRules();
                }

                return HtmlHighlightRules;
            })(XmlHighlightRules);

            _export("default", HtmlHighlightRules);
        }
    };
});
System.register("src/mode/behaviour/XmlBehaviour.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/Behaviour.js", "src/TokenIterator.js"], function (_export) {
    var _get, _inherits, _classCallCheck, Behaviour, TokenIterator, XmlBehaviour;

    function is(token, type) {
        return token.type.lastIndexOf(type + ".xml") > -1;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeBehaviourJs) {
            Behaviour = _srcModeBehaviourJs["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }],
        execute: function () {
            "use strict";

            XmlBehaviour = (function (_Behaviour) {
                _inherits(XmlBehaviour, _Behaviour);

                function XmlBehaviour() {
                    _classCallCheck(this, XmlBehaviour);

                    _get(Object.getPrototypeOf(XmlBehaviour.prototype), "constructor", this).call(this);
                    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                        if (text === '"' || text === "'") {
                            var quote = text;
                            var selected = session.doc.getTextRange(editor.getSelectionRange());
                            if (selected !== "" && selected !== "'" && selected !== '"' && editor.getWrapBehavioursEnabled()) {
                                return {
                                    text: quote + selected + quote,
                                    selection: void 0
                                };
                            }
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            var iterator = new TokenIterator(session, cursor.row, cursor.column);
                            var token = iterator.getCurrentToken();
                            if (rightChar === quote && (is(token, "attribute-value") || is(token, "string"))) {
                                return {
                                    text: "",
                                    selection: [1, 1]
                                };
                            }
                            if (!token) token = iterator.stepBackward();
                            if (!token) return;
                            while (is(token, "tag-whitespace") || is(token, "whitespace")) {
                                token = iterator.stepBackward();
                            }
                            var rightSpace = !rightChar || rightChar.match(/\s/);
                            if (is(token, "attribute-equals") && (rightSpace || rightChar === '>') || is(token, "decl-attribute-equals") && (rightSpace || rightChar == '?')) {
                                return {
                                    text: quote + quote,
                                    selection: [1, 1]
                                };
                            }
                        }
                    });
                    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && (selected === '"' || selected === "'")) {
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar == selected) {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                    this.add("autoclosing", "insertion", function (state, action, editor, session, text) {
                        if (text === '>') {
                            var position = editor.getCursorPosition();
                            var iterator = new TokenIterator(session, position.row, position.column);
                            var token = iterator.getCurrentToken() || iterator.stepBackward();
                            if (!token || !(is(token, "tag-name") || is(token, "tag-whitespace") || is(token, "attribute-name") || is(token, "attribute-equals") || is(token, "attribute-value"))) return;
                            if (is(token, "reference.attribute-value")) return;
                            if (is(token, "attribute-value")) {
                                var firstChar = token.value.charAt(0);
                                if (firstChar == '"' || firstChar == "'") {
                                    var lastChar = token.value.charAt(token.value.length - 1);
                                    var tokenEnd = iterator.getCurrentTokenColumn() + token.value.length;
                                    if (tokenEnd > position.column || tokenEnd == position.column && firstChar != lastChar) return;
                                }
                            }
                            while (!is(token, "tag-name")) {
                                token = iterator.stepBackward();
                            }
                            var tokenRow = iterator.getCurrentTokenRow();
                            var tokenColumn = iterator.getCurrentTokenColumn();
                            if (is(iterator.stepBackward(), "end-tag-open")) return;
                            var element = token.value;
                            if (tokenRow == position.row) element = element.substring(0, position.column - tokenColumn);
                            if (this.voidElements.hasOwnProperty(element.toLowerCase())) return;
                            return {
                                text: '>' + '</' + element + '>',
                                selection: [1, 1]
                            };
                        }
                    });
                    this.add('autoindent', 'insertion', function (state, action, editor, session, text) {
                        if (text === "\n") {
                            var cursor = editor.getCursorPosition();
                            var line = session.getLine(cursor.row);
                            var rightChars = line.substring(cursor.column, cursor.column + 2);
                            if (rightChars == '</') {
                                var next_indent = this.$getIndent(line);
                                var indent = next_indent + session.getTabString();
                                return {
                                    text: '\n' + indent + '\n' + next_indent,
                                    selection: [1, indent.length, 1, indent.length]
                                };
                            }
                        }
                    });
                }

                return XmlBehaviour;
            })(Behaviour);

            _export("default", XmlBehaviour);
        }
    };
});
System.register("src/mode/behaviour/HtmlBehaviour.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/behaviour/XmlBehaviour.js"], function (_export) {
    var _get, _inherits, _classCallCheck, XmlBehaviour, HtmlBehaviour;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeBehaviourXmlBehaviourJs) {
            XmlBehaviour = _srcModeBehaviourXmlBehaviourJs["default"];
        }],
        execute: function () {
            "use strict";

            HtmlBehaviour = (function (_XmlBehaviour) {
                _inherits(HtmlBehaviour, _XmlBehaviour);

                function HtmlBehaviour() {
                    _classCallCheck(this, HtmlBehaviour);

                    _get(Object.getPrototypeOf(HtmlBehaviour.prototype), "constructor", this).call(this);
                }

                return HtmlBehaviour;
            })(XmlBehaviour);

            _export("default", HtmlBehaviour);
        }
    };
});
System.register("src/mode/folding/MixedFoldMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/folding/FoldMode.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, FoldMode, MixedFoldMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeFoldingFoldModeJs) {
            FoldMode = _srcModeFoldingFoldModeJs["default"];
        }],
        execute: function () {
            "use strict";

            MixedFoldMode = (function (_FoldMode) {
                _inherits(MixedFoldMode, _FoldMode);

                function MixedFoldMode(defaultMode, subModes) {
                    _classCallCheck(this, MixedFoldMode);

                    _get(Object.getPrototypeOf(MixedFoldMode.prototype), "constructor", this).call(this);
                    this.defaultMode = defaultMode;
                    this.subModes = subModes;
                }

                _createClass(MixedFoldMode, [{
                    key: "$getMode",
                    value: function $getMode(state) {
                        if (typeof state !== "string") {
                            state = state[0];
                        }
                        for (var key in this.subModes) {
                            if (state.indexOf(key) === 0) return this.subModes[key];
                        }
                        return null;
                    }
                }, {
                    key: "$tryMode",
                    value: function $tryMode(state, session, foldStyle, row) {
                        var mode = this.$getMode(state);
                        return mode ? mode.getFoldWidget(session, foldStyle, row) : "";
                    }
                }, {
                    key: "getFoldWidget",
                    value: function getFoldWidget(session, foldStyle, row) {
                        return this.$tryMode(session.getState(row - 1), session, foldStyle, row) || this.$tryMode(session.getState(row), session, foldStyle, row) || this.defaultMode.getFoldWidget(session, foldStyle, row);
                    }
                }, {
                    key: "getFoldWidgetRange",
                    value: function getFoldWidgetRange(session, foldStyle, row) {
                        var mode = this.$getMode(session.getState(row - 1));
                        if (!mode || !mode.getFoldWidget(session, foldStyle, row)) {
                            mode = this.$getMode(session.getState(row));
                        }
                        if (!mode || !mode.getFoldWidget(session, foldStyle, row)) {
                            mode = this.defaultMode;
                        }
                        return mode.getFoldWidgetRange(session, foldStyle, row);
                    }
                }]);

                return MixedFoldMode;
            })(FoldMode);

            _export("default", MixedFoldMode);
        }
    };
});
System.register("src/lib/oop.js", ["npm:babel-runtime@5.8.34/core-js/object/create"], function (_export) {
    var _Object$create;

    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = _Object$create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }

    function mixin(obj, base) {
        for (var key in base) {
            obj[key] = base[key];
        }
        return obj;
    }

    function implement(proto, base) {
        mixin(proto, base);
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate["default"];
        }],
        execute: function () {
            "use strict";

            _export("inherits", inherits);

            _export("mixin", mixin);

            _export("implement", implement);
        }
    };
});
System.register("src/mode/folding/XmlFoldMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/lib/oop.js", "src/Range.js", "src/mode/folding/FoldMode.js", "src/TokenIterator.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, mixin, Range, FoldMode, TokenIterator, XmlFoldMode, Tag;

    function is(token, type) {
        return token.type.lastIndexOf(type + ".xml") > -1;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcLibOopJs) {
            mixin = _srcLibOopJs.mixin;
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcModeFoldingFoldModeJs) {
            FoldMode = _srcModeFoldingFoldModeJs["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }],
        execute: function () {
            "use strict";

            XmlFoldMode = (function (_FoldMode) {
                _inherits(XmlFoldMode, _FoldMode);

                function XmlFoldMode(voidElements, optionalEndTags) {
                    _classCallCheck(this, XmlFoldMode);

                    _get(Object.getPrototypeOf(XmlFoldMode.prototype), "constructor", this).call(this);
                    this.voidElements = voidElements || {};
                    this.optionalEndTags = mixin({}, this.voidElements);
                    if (optionalEndTags) {
                        mixin(this.optionalEndTags, optionalEndTags);
                    }
                }

                _createClass(XmlFoldMode, [{
                    key: "getFoldWidget",
                    value: function getFoldWidget(session, foldStyle, row) {
                        var tag = this._getFirstTagInLine(session, row);
                        if (!tag) return "";
                        if (tag.closing || !tag.tagName && tag.selfClosing) return foldStyle === "markbeginend" ? "end" : "";
                        if (!tag.tagName || tag.selfClosing || this.voidElements.hasOwnProperty(tag.tagName.toLowerCase())) return "";
                        if (this._findEndTagInLine(session, row, tag.tagName, tag.end.column)) return "";
                        return "start";
                    }
                }, {
                    key: "_getFirstTagInLine",
                    value: function _getFirstTagInLine(session, row) {
                        var tokens = session.getTokens(row);
                        var tag = new Tag();
                        for (var i = 0; i < tokens.length; i++) {
                            var token = tokens[i];
                            if (is(token, "tag-open")) {
                                tag.end.column = tag.start.column + token.value.length;
                                tag.closing = is(token, "end-tag-open");
                                token = tokens[++i];
                                if (!token) return null;
                                tag.tagName = token.value;
                                tag.end.column += token.value.length;
                                for (i++; i < tokens.length; i++) {
                                    token = tokens[i];
                                    tag.end.column += token.value.length;
                                    if (is(token, "tag-close")) {
                                        tag.selfClosing = token.value == '/>';
                                        break;
                                    }
                                }
                                return tag;
                            } else if (is(token, "tag-close")) {
                                tag.selfClosing = token.value == '/>';
                                return tag;
                            }
                            tag.start.column += token.value.length;
                        }
                        return null;
                    }
                }, {
                    key: "_findEndTagInLine",
                    value: function _findEndTagInLine(session, row, tagName, startColumn) {
                        var tokens = session.getTokens(row);
                        var column = 0;
                        for (var i = 0; i < tokens.length; i++) {
                            var token = tokens[i];
                            column += token.value.length;
                            if (column < startColumn) continue;
                            if (is(token, "end-tag-open")) {
                                token = tokens[i + 1];
                                if (token && token.value == tagName) return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "_readTagForward",
                    value: function _readTagForward(iterator) {
                        var token = iterator.getCurrentToken();
                        if (!token) return null;
                        var tag = new Tag();
                        do {
                            if (is(token, "tag-open")) {
                                tag.closing = is(token, "end-tag-open");
                                tag.start.row = iterator.getCurrentTokenRow();
                                tag.start.column = iterator.getCurrentTokenColumn();
                            } else if (is(token, "tag-name")) {
                                tag.tagName = token.value;
                            } else if (is(token, "tag-close")) {
                                tag.selfClosing = token.value == "/>";
                                tag.end.row = iterator.getCurrentTokenRow();
                                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                                iterator.stepForward();
                                return tag;
                            }
                        } while (token = iterator.stepForward());
                        return null;
                    }
                }, {
                    key: "_readTagBackward",
                    value: function _readTagBackward(iterator) {
                        var token = iterator.getCurrentToken();
                        if (!token) return null;
                        var tag = new Tag();
                        do {
                            if (is(token, "tag-open")) {
                                tag.closing = is(token, "end-tag-open");
                                tag.start.row = iterator.getCurrentTokenRow();
                                tag.start.column = iterator.getCurrentTokenColumn();
                                iterator.stepBackward();
                                return tag;
                            } else if (is(token, "tag-name")) {
                                tag.tagName = token.value;
                            } else if (is(token, "tag-close")) {
                                tag.selfClosing = token.value == "/>";
                                tag.end.row = iterator.getCurrentTokenRow();
                                tag.end.column = iterator.getCurrentTokenColumn() + token.value.length;
                            }
                        } while (token = iterator.stepBackward());
                        return null;
                    }
                }, {
                    key: "_pop",
                    value: function _pop(stack, tag) {
                        while (stack.length) {
                            var top = stack[stack.length - 1];
                            if (!tag || top.tagName == tag.tagName) {
                                return stack.pop();
                            } else if (this.optionalEndTags.hasOwnProperty(tag.tagName)) {
                                return;
                            } else if (this.optionalEndTags.hasOwnProperty(top.tagName)) {
                                stack.pop();
                                continue;
                            } else {
                                return null;
                            }
                        }
                    }
                }, {
                    key: "getFoldWidgetRange",
                    value: function getFoldWidgetRange(session, foldStyle, row) {
                        var firstTag = this._getFirstTagInLine(session, row);
                        if (!firstTag) {
                            return null;
                        }
                        var isBackward = firstTag.closing || firstTag.selfClosing;
                        var stack = [];
                        var tag;
                        if (!isBackward) {
                            var iterator = new TokenIterator(session, row, firstTag.start.column);
                            var start = {
                                row: row,
                                column: firstTag.start.column + firstTag.tagName.length + 2
                            };
                            while (tag = this._readTagForward(iterator)) {
                                if (tag.selfClosing) {
                                    if (!stack.length) {
                                        tag.start.column += tag.tagName.length + 2;
                                        tag.end.column -= 2;
                                        return Range.fromPoints(tag.start, tag.end);
                                    } else continue;
                                }
                                if (tag.closing) {
                                    this._pop(stack, tag);
                                    if (stack.length == 0) return Range.fromPoints(start, tag.start);
                                } else {
                                    stack.push(tag);
                                }
                            }
                        } else {
                            var iterator = new TokenIterator(session, row, firstTag.end.column);
                            var end = {
                                row: row,
                                column: firstTag.start.column
                            };
                            while (tag = this._readTagBackward(iterator)) {
                                if (tag.selfClosing) {
                                    if (!stack.length) {
                                        tag.start.column += tag.tagName.length + 2;
                                        tag.end.column -= 2;
                                        return Range.fromPoints(tag.start, tag.end);
                                    } else {
                                        continue;
                                    }
                                }
                                if (!tag.closing) {
                                    this._pop(stack, tag);
                                    if (stack.length === 0) {
                                        tag.start.column += tag.tagName.length + 2;
                                        return Range.fromPoints(tag.start, end);
                                    }
                                } else {
                                    stack.push(tag);
                                }
                            }
                        }
                    }
                }]);

                return XmlFoldMode;
            })(FoldMode);

            _export("default", XmlFoldMode);

            Tag = function Tag() {
                _classCallCheck(this, Tag);

                this.tagName = "";
                this.closing = false;
                this.selfClosing = false;
                this.start = { row: 0, column: 0 };
                this.end = { row: 0, column: 0 };
            };

            _export("Tag", Tag);
        }
    };
});
System.register("src/mode/folding/HtmlFoldMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/folding/MixedFoldMode.js", "src/mode/folding/XmlFoldMode.js", "src/mode/folding/CstyleFoldMode.js"], function (_export) {
    var _get, _inherits, _classCallCheck, MixedFoldMode, XmlFoldMode, CStyleFoldMode, HtmlFoldMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeFoldingMixedFoldModeJs) {
            MixedFoldMode = _srcModeFoldingMixedFoldModeJs["default"];
        }, function (_srcModeFoldingXmlFoldModeJs) {
            XmlFoldMode = _srcModeFoldingXmlFoldModeJs["default"];
        }, function (_srcModeFoldingCstyleFoldModeJs) {
            CStyleFoldMode = _srcModeFoldingCstyleFoldModeJs["default"];
        }],
        execute: function () {
            "use strict";

            HtmlFoldMode = (function (_MixedFoldMode) {
                _inherits(HtmlFoldMode, _MixedFoldMode);

                function HtmlFoldMode(voidElements, optionalTags) {
                    _classCallCheck(this, HtmlFoldMode);

                    _get(Object.getPrototypeOf(HtmlFoldMode.prototype), "constructor", this).call(this, new XmlFoldMode(voidElements, optionalTags), { "js-": new CStyleFoldMode(), "css-": new CStyleFoldMode() });
                }

                return HtmlFoldMode;
            })(MixedFoldMode);

            _export("default", HtmlFoldMode);
        }
    };
});
System.register("src/mode/HtmlCompletions.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/object/keys", "src/TokenIterator.js"], function (_export) {
    var _createClass, _classCallCheck, _Object$keys, TokenIterator, commonAttributes, eventAttributes, globalAttributes, attributeMap, elements, HtmlCompletions;

    function is(token, type) {
        return token.type.lastIndexOf(type + ".xml") > -1;
    }
    function findTagName(session, pos) {
        var iterator = new TokenIterator(session, pos.row, pos.column);
        var token = iterator.getCurrentToken();
        while (token && !is(token, "tag-name")) {
            token = iterator.stepBackward();
        }
        if (token) return token.value;
    }
    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }],
        execute: function () {
            "use strict";
            commonAttributes = ["accesskey", "class", "contenteditable", "contextmenu", "dir", "draggable", "dropzone", "hidden", "id", "inert", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "spellcheck", "style", "tabindex", "title", "translate"];
            eventAttributes = ["onabort", "onblur", "oncancel", "oncanplay", "oncanplaythrough", "onchange", "onclick", "onclose", "oncontextmenu", "oncuechange", "ondblclick", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onended", "onerror", "onfocus", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onload", "onloadeddata", "onloadedmetadata", "onloadstart", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onpause", "onplay", "onplaying", "onprogress", "onratechange", "onreset", "onscroll", "onseeked", "onseeking", "onselect", "onshow", "onstalled", "onsubmit", "onsuspend", "ontimeupdate", "onvolumechange", "onwaiting"];
            globalAttributes = commonAttributes.concat(eventAttributes);
            attributeMap = {
                "html": ["manifest"],
                "head": [],
                "title": [],
                "base": ["href", "target"],
                "link": ["href", "hreflang", "rel", "media", "type", "sizes"],
                "meta": ["http-equiv", "name", "content", "charset"],
                "style": ["type", "media", "scoped"],
                "script": ["charset", "type", "src", "defer", "async"],
                "noscript": ["href"],
                "body": ["onafterprint", "onbeforeprint", "onbeforeunload", "onhashchange", "onmessage", "onoffline", "onpopstate", "onredo", "onresize", "onstorage", "onundo", "onunload"],
                "section": [],
                "nav": [],
                "article": ["pubdate"],
                "aside": [],
                "h1": [],
                "h2": [],
                "h3": [],
                "h4": [],
                "h5": [],
                "h6": [],
                "header": [],
                "footer": [],
                "address": [],
                "main": [],
                "p": [],
                "hr": [],
                "pre": [],
                "blockquote": ["cite"],
                "ol": ["start", "reversed"],
                "ul": [],
                "li": ["value"],
                "dl": [],
                "dt": [],
                "dd": [],
                "figure": [],
                "figcaption": [],
                "div": [],
                "a": ["href", "target", "ping", "rel", "media", "hreflang", "type"],
                "em": [],
                "strong": [],
                "small": [],
                "s": [],
                "cite": [],
                "q": ["cite"],
                "dfn": [],
                "abbr": [],
                "data": [],
                "time": ["datetime"],
                "code": [],
                "var": [],
                "samp": [],
                "kbd": [],
                "sub": [],
                "sup": [],
                "i": [],
                "b": [],
                "u": [],
                "mark": [],
                "ruby": [],
                "rt": [],
                "rp": [],
                "bdi": [],
                "bdo": [],
                "span": [],
                "br": [],
                "wbr": [],
                "ins": ["cite", "datetime"],
                "del": ["cite", "datetime"],
                "img": ["alt", "src", "height", "width", "usemap", "ismap"],
                "iframe": ["name", "src", "height", "width", "sandbox", "seamless"],
                "embed": ["src", "height", "width", "type"],
                "object": ["param", "data", "type", "height", "width", "usemap", "name", "form", "classid"],
                "param": ["name", "value"],
                "video": ["src", "autobuffer", "autoplay", "loop", "controls", "width", "height", "poster"],
                "audio": ["src", "autobuffer", "autoplay", "loop", "controls"],
                "source": ["src", "type", "media"],
                "track": ["kind", "src", "srclang", "label", "default"],
                "canvas": ["width", "height"],
                "map": ["name"],
                "area": ["shape", "coords", "href", "hreflang", "alt", "target", "media", "rel", "ping", "type"],
                "svg": [],
                "math": [],
                "table": ["summary"],
                "caption": [],
                "colgroup": ["span"],
                "col": ["span"],
                "tbody": [],
                "thead": [],
                "tfoot": [],
                "tr": [],
                "td": ["headers", "rowspan", "colspan"],
                "th": ["headers", "rowspan", "colspan", "scope"],
                "form": ["accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"],
                "fieldset": ["disabled", "form", "name"],
                "legend": [],
                "label": ["form", "for"],
                "input": ["type", "accept", "alt", "autocomplete", "checked", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "list", "max", "maxlength", "min", "multiple", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "width", "files", "value"],
                "button": ["autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "value", "type"],
                "select": ["autofocus", "disabled", "form", "multiple", "name", "size"],
                "datalist": [],
                "optgroup": ["disabled", "label"],
                "option": ["disabled", "selected", "label", "value"],
                "textarea": ["autofocus", "disabled", "form", "maxlength", "name", "placeholder", "readonly", "required", "rows", "cols", "wrap"],
                "keygen": ["autofocus", "challenge", "disabled", "form", "keytype", "name"],
                "output": ["for", "form", "name"],
                "progress": ["value", "max"],
                "meter": ["value", "min", "max", "low", "high", "optimum"],
                "details": ["open"],
                "summary": [],
                "command": ["type", "label", "icon", "disabled", "checked", "radiogroup", "command"],
                "menu": ["type", "label"],
                "dialog": ["open"]
            };
            elements = _Object$keys(attributeMap);

            HtmlCompletions = (function () {
                function HtmlCompletions() {
                    _classCallCheck(this, HtmlCompletions);
                }

                _createClass(HtmlCompletions, [{
                    key: "getCompletions",
                    value: function getCompletions(state, session, pos, prefix) {
                        var token = session.getTokenAt(pos.row, pos.column);
                        if (!token) return [];
                        if (is(token, "tag-name") || is(token, "tag-open") || is(token, "end-tag-open")) return this.getTagCompletions(state, session, pos, prefix);
                        if (is(token, "tag-whitespace") || is(token, "attribute-name")) return this.getAttributeCompetions(state, session, pos, prefix);
                        return [];
                    }
                }, {
                    key: "getTagCompletions",
                    value: function getTagCompletions(state, session, pos, prefix) {
                        return elements.map(function (element) {
                            return {
                                value: element,
                                meta: "tag",
                                score: Number.MAX_VALUE
                            };
                        });
                    }
                }, {
                    key: "getAttributeCompetions",
                    value: function getAttributeCompetions(state, session, pos, prefix) {
                        var tagName = findTagName(session, pos);
                        if (!tagName) return [];
                        var attributes = globalAttributes;
                        if (tagName in attributeMap) {
                            attributes = attributes.concat(attributeMap[tagName]);
                        }
                        return attributes.map(function (attribute) {
                            return {
                                caption: attribute,
                                snippet: attribute + '="$0"',
                                meta: "attribute",
                                score: Number.MAX_VALUE
                            };
                        });
                    }
                }]);

                return HtmlCompletions;
            })();

            _export("default", HtmlCompletions);
        }
    };
});
System.register("src/mode/HtmlMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/lib/lang.js", "src/mode/TextMode.js", "src/mode/JavaScriptMode.js", "src/mode/CssMode.js", "src/mode/HtmlHighlightRules.js", "src/mode/behaviour/HtmlBehaviour.js", "src/mode/folding/HtmlFoldMode.js", "src/mode/HtmlCompletions.js", "src/worker/WorkerClient.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _Promise, arrayToMap, TextMode, JavaScriptMode, CssMode, HtmlHighlightRules, HtmlBehaviour, HtmlFoldMode, HtmlCompletions, WorkerClient, voidElements, optionalEndTags, HtmlMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcLibLangJs) {
            arrayToMap = _srcLibLangJs.arrayToMap;
        }, function (_srcModeTextModeJs) {
            TextMode = _srcModeTextModeJs["default"];
        }, function (_srcModeJavaScriptModeJs) {
            JavaScriptMode = _srcModeJavaScriptModeJs["default"];
        }, function (_srcModeCssModeJs) {
            CssMode = _srcModeCssModeJs["default"];
        }, function (_srcModeHtmlHighlightRulesJs) {
            HtmlHighlightRules = _srcModeHtmlHighlightRulesJs["default"];
        }, function (_srcModeBehaviourHtmlBehaviourJs) {
            HtmlBehaviour = _srcModeBehaviourHtmlBehaviourJs["default"];
        }, function (_srcModeFoldingHtmlFoldModeJs) {
            HtmlFoldMode = _srcModeFoldingHtmlFoldModeJs["default"];
        }, function (_srcModeHtmlCompletionsJs) {
            HtmlCompletions = _srcModeHtmlCompletionsJs["default"];
        }, function (_srcWorkerWorkerClientJs) {
            WorkerClient = _srcWorkerWorkerClientJs["default"];
        }],
        execute: function () {
            "use strict";
            voidElements = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
            optionalEndTags = ["li", "dt", "dd", "p", "rt", "rp", "optgroup", "option", "colgroup", "td", "th"];

            HtmlMode = (function (_TextMode) {
                _inherits(HtmlMode, _TextMode);

                function HtmlMode(workerUrl, scriptImports, options) {
                    _classCallCheck(this, HtmlMode);

                    _get(Object.getPrototypeOf(HtmlMode.prototype), "constructor", this).call(this, workerUrl, scriptImports);
                    this.blockComment = { start: "<!--", end: "-->" };
                    this.voidElements = arrayToMap(voidElements, 1);
                    this.$id = "ace/mode/html";
                    this.fragmentContext = options && options.fragmentContext;
                    this.HighlightRules = HtmlHighlightRules;
                    this.$behaviour = new HtmlBehaviour();
                    this.$completer = new HtmlCompletions();
                    var X = JavaScriptMode;
                    this.createModeDelegates({
                        "js-": JavaScriptMode,
                        "css-": CssMode
                    });
                    this.foldingRules = new HtmlFoldMode(this.voidElements, arrayToMap(optionalEndTags, 1));
                }

                _createClass(HtmlMode, [{
                    key: "getNextLineIndent",
                    value: function getNextLineIndent(state, line, tab) {
                        return this.$getIndent(line);
                    }
                }, {
                    key: "checkOutdent",
                    value: function checkOutdent(state, line, text) {
                        return false;
                    }
                }, {
                    key: "getCompletions",
                    value: function getCompletions(state, session, pos, prefix) {
                        return this.$completer.getCompletions(state, session, pos, prefix);
                    }
                }, {
                    key: "createWorker",
                    value: function createWorker(session) {
                        var workerUrl = this.workerUrl;
                        var scriptImports = this.scriptImports;
                        var mode = this;
                        return new _Promise(function (resolve, reject) {
                            var worker = new WorkerClient(workerUrl);
                            worker.on("initAfter", function () {
                                worker.attachToDocument(session.getDocument());
                                if (mode.fragmentContext) {
                                    worker.call("setOptions", [{ context: mode.fragmentContext }]);
                                }
                                resolve(worker);
                            });
                            worker.on("initFail", function (message) {
                                reject(new Error("" + message));
                            });
                            worker.on("error", function (message) {
                                session.setAnnotations(message.data);
                            });
                            worker.on("terminate", function () {
                                worker.detachFromDocument();
                                session.clearAnnotations();
                            });
                            worker.init(scriptImports, 'ace-workers.js', 'HtmlWorker');
                        });
                    }
                }]);

                return HtmlMode;
            })(TextMode);

            _export("default", HtmlMode);
        }
    };
});
System.register("src/Tokenizer.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, MAX_TOKEN_COUNT, Tokenizer;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";
            MAX_TOKEN_COUNT = 1000;

            Tokenizer = (function () {
                function Tokenizer(rules) {
                    _classCallCheck(this, Tokenizer);

                    this.states = rules;
                    this.regExps = {};
                    this.matchMappings = {};
                    for (var key in this.states) {
                        var state = this.states[key];
                        var ruleRegExps = [];
                        var matchTotal = 0;
                        var mapping = this.matchMappings[key] = { defaultToken: "text" };
                        var flag = "g";
                        var splitterRules = [];
                        for (var i = 0; i < state.length; i++) {
                            var rule = state[i];
                            if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                            if (rule.caseInsensitive) flag = "gi";
                            if (rule.regex == null) continue;
                            if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
                            var adjustedregex = rule.regex;
                            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                            if (Array.isArray(rule.token)) {
                                if (rule.token.length == 1 || matchcount == 1) {
                                    rule.token = rule.token[0];
                                } else if (matchcount - 1 != rule.token.length) {
                                    throw new Error("number of classes and regexp groups in '" + rule.token + "'\n'" + rule.regex + "' doesn't match\n" + (matchcount - 1) + "!=" + rule.token.length);
                                } else {
                                    rule.tokenArray = rule.token;
                                    rule.token = null;
                                    rule.onMatch = this.$arrayTokens;
                                }
                            } else if (typeof rule.token === "function" && !rule.onMatch) {
                                if (matchcount > 1) rule.onMatch = this.$applyToken;else rule.onMatch = rule.token;
                            }
                            if (matchcount > 1) {
                                if (/\\\d/.test(rule.regex)) {
                                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function (match, digit) {
                                        return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                                    });
                                } else {
                                    matchcount = 1;
                                    adjustedregex = this.removeCapturingGroups(rule.regex);
                                }
                                if (!rule.splitRegex && typeof rule.token != "string") splitterRules.push(rule);
                            }
                            mapping[matchTotal] = i;
                            matchTotal += matchcount;
                            ruleRegExps.push(adjustedregex);
                            if (!rule.onMatch) rule.onMatch = null;
                        }
                        if (!ruleRegExps.length) {
                            mapping[0] = 0;
                            ruleRegExps.push("$");
                        }
                        splitterRules.forEach(function (rule) {
                            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                        }, this);
                        this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
                    }
                }

                _createClass(Tokenizer, [{
                    key: "$setMaxTokenCount",
                    value: function $setMaxTokenCount(m) {
                        MAX_TOKEN_COUNT = m | 0;
                    }
                }, {
                    key: "$applyToken",
                    value: function $applyToken(str) {
                        var values = this.splitRegex.exec(str).slice(1);
                        var types = this.token.apply(this, values);
                        if (typeof types === "string") return [{ type: types, value: str }];
                        var tokens = [];
                        for (var i = 0, l = types.length; i < l; i++) {
                            if (values[i]) tokens[tokens.length] = {
                                type: types[i],
                                value: values[i]
                            };
                        }
                        return tokens;
                    }
                }, {
                    key: "$arrayTokens",
                    value: function $arrayTokens(str) {
                        if (!str) {
                            return [];
                        }
                        var values = this.splitRegex.exec(str);
                        if (!values) return "text";
                        var tokens = [];
                        var types = this.tokenArray;
                        for (var i = 0, l = types.length; i < l; i++) {
                            if (values[i + 1]) tokens[tokens.length] = {
                                type: types[i],
                                value: values[i + 1]
                            };
                        }
                        return tokens;
                    }
                }, {
                    key: "removeCapturingGroups",
                    value: function removeCapturingGroups(src) {
                        var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function (x, y) {
                            return y ? "(?:" : x;
                        });
                        return r;
                    }
                }, {
                    key: "createSplitterRegexp",
                    value: function createSplitterRegexp(src, flag) {
                        if (src.indexOf("(?=") != -1) {
                            var stack = 0;
                            var inChClass = false;
                            var lastCapture = {};
                            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function (m, esc, parenOpen, parenClose, square, index) {
                                if (inChClass) {
                                    inChClass = square != "]";
                                } else if (square) {
                                    inChClass = true;
                                } else if (parenClose) {
                                    if (stack == lastCapture.stack) {
                                        lastCapture.end = index + 1;
                                        lastCapture.stack = -1;
                                    }
                                    stack--;
                                } else if (parenOpen) {
                                    stack++;
                                    if (parenOpen.length != 1) {
                                        lastCapture.stack = stack;
                                        lastCapture.start = index;
                                    }
                                }
                                return m;
                            });
                            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
                        }
                        return new RegExp(src, (flag || "").replace("g", ""));
                    }
                }, {
                    key: "getLineTokens",
                    value: function getLineTokens(line, startState) {
                        var stack;
                        if (startState && typeof startState !== 'string') {
                            stack = startState.slice(0);
                            startState = stack[0];
                            if (startState === '#tmp') {
                                stack.shift();
                                startState = stack.shift();
                            }
                        } else {
                            stack = [];
                        }
                        var currentState = startState || "start";
                        var state = this.states[currentState];
                        if (!state) {
                            currentState = "start";
                            state = this.states[currentState];
                        }
                        var mapping = this.matchMappings[currentState];
                        var re = this.regExps[currentState];
                        re.lastIndex = 0;
                        var match,
                            tokens = [];
                        var lastIndex = 0;
                        var token = { type: null, value: "" };
                        while (match = re.exec(line)) {
                            var type = mapping.defaultToken;
                            var rule = null;
                            var value = match[0];
                            var index = re.lastIndex;
                            if (index - value.length > lastIndex) {
                                var skipped = line.substring(lastIndex, index - value.length);
                                if (token.type == type) {
                                    token.value += skipped;
                                } else {
                                    if (token.type) tokens.push(token);
                                    token = { type: type, value: skipped };
                                }
                            }
                            for (var i = 0; i < match.length - 2; i++) {
                                if (match[i + 1] === undefined) continue;
                                rule = state[mapping[i]];
                                if (rule.onMatch) type = rule.onMatch(value, currentState, stack);else type = rule.token;
                                if (rule.next) {
                                    if (typeof rule.next === 'string') {
                                        currentState = rule.next;
                                    } else {
                                        currentState = rule.next(currentState, stack);
                                    }
                                    state = this.states[currentState];
                                    if (!state) {
                                        window.console && console.error && console.error(currentState, "doesn't exist");
                                        currentState = "start";
                                        state = this.states[currentState];
                                    }
                                    mapping = this.matchMappings[currentState];
                                    lastIndex = index;
                                    re = this.regExps[currentState];
                                    re.lastIndex = index;
                                }
                                break;
                            }
                            if (value) {
                                if (typeof type == "string") {
                                    if ((!rule || rule.merge !== false) && token.type === type) {
                                        token.value += value;
                                    } else {
                                        if (token.type) tokens.push(token);
                                        token = { type: type, value: value };
                                    }
                                } else if (type) {
                                    if (token.type) tokens.push(token);
                                    token = { type: null, value: "" };
                                    for (var i = 0; i < type.length; i++) tokens.push(type[i]);
                                }
                            }
                            if (lastIndex == line.length) break;
                            lastIndex = index;
                            if (tokens.length > MAX_TOKEN_COUNT) {
                                while (lastIndex < line.length) {
                                    if (token.type) tokens.push(token);
                                    token = {
                                        value: line.substring(lastIndex, lastIndex += 2000),
                                        type: "overflow"
                                    };
                                }
                                currentState = "start";
                                stack = [];
                                break;
                            }
                        }
                        if (token.type) tokens.push(token);
                        if (stack.length > 1) {
                            if (stack[0] !== currentState) {
                                stack.unshift('#tmp', currentState);
                            }
                        }
                        return {
                            tokens: tokens,
                            state: stack.length ? stack : currentState
                        };
                    }
                }]);

                return Tokenizer;
            })();

            _export("default", Tokenizer);
        }
    };
});
System.register("src/unicode.js", [], function (_export) {
    "use strict";
    var packages;

    function addUnicodePackage(pack) {
        var codePoint = /\w{4}/g;
        for (var name in pack) packages[name] = pack[name].replace(codePoint, "\\u$&");
    }
    return {
        setters: [],
        execute: function () {
            packages = { L: undefined, Mn: undefined, Mc: undefined, Nd: undefined, Pc: undefined };

            _export("packages", packages);

            addUnicodePackage({
                L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
                Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
                Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
                Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
                Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
                M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
                Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
                Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
                Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
                N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
                Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
                No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
                P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
                Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
                Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
                Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
                Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
                Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
                Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
                Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
                S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
                Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
                Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
                Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
                So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
                Z: "002000A01680180E2000-200A20282029202F205F3000",
                Zs: "002000A01680180E2000-200A202F205F3000",
                Zl: "2028",
                Zp: "2029",
                C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
                Cc: "0000-001F007F-009F",
                Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
                Co: "E000-F8FF",
                Cs: "D800-DFFF",
                Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
            });
        }
    };
});
System.register("src/mode/TextMode.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/Tokenizer.js", "src/mode/TextHighlightRules.js", "src/mode/Behaviour.js", "src/unicode.js", "src/lib/lang.js", "src/TokenIterator.js", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, _Promise, Tokenizer, TextHighlightRules, Behaviour, packages, escapeRegExp, TokenIterator, Range, TextMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcTokenizerJs) {
            Tokenizer = _srcTokenizerJs["default"];
        }, function (_srcModeTextHighlightRulesJs) {
            TextHighlightRules = _srcModeTextHighlightRulesJs["default"];
        }, function (_srcModeBehaviourJs) {
            Behaviour = _srcModeBehaviourJs["default"];
        }, function (_srcUnicodeJs) {
            packages = _srcUnicodeJs.packages;
        }, function (_srcLibLangJs) {
            escapeRegExp = _srcLibLangJs.escapeRegExp;
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            TextMode = (function () {
                function TextMode(workerUrl, scriptImports) {
                    _classCallCheck(this, TextMode);

                    this.HighlightRules = TextHighlightRules;
                    this.$behaviour = new Behaviour();
                    this.tokenRe = new RegExp("^[" + packages.L + packages.Mn + packages.Mc + packages.Nd + packages.Pc + "\\$_]+", "g");
                    this.nonTokenRe = new RegExp("^(?:[^" + packages.L + packages.Mn + packages.Mc + packages.Nd + packages.Pc + "\\$_]|\\s])+", "g");
                    this.lineCommentStart = "";
                    this.blockComment = "";
                    this.$id = "ace/mode/text";
                    this.scriptImports = [];
                    if (typeof workerUrl === 'string') {
                        this.workerUrl = workerUrl;
                    } else {
                        throw new TypeError("workerUrl must be a string.");
                    }
                    this.scriptImports = scriptImports;
                }

                _createClass(TextMode, [{
                    key: "getTokenizer",
                    value: function getTokenizer() {
                        if (!this.$tokenizer) {
                            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
                            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
                        }
                        return this.$tokenizer;
                    }
                }, {
                    key: "toggleCommentLines",
                    value: function toggleCommentLines(state, session, startRow, endRow) {
                        var doc = session.doc;
                        var ignoreBlankLines = true;
                        var shouldRemove = true;
                        var minIndent = Infinity;
                        var tabSize = session.getTabSize();
                        var insertAtTabStop = false;
                        if (!this.lineCommentStart) {
                            if (!this.blockComment) return false;
                            var lineCommentStart = this.blockComment.start;
                            var lineCommentEnd = this.blockComment.end;
                            var regexpStart = new RegExp("^(\\s*)(?:" + escapeRegExp(lineCommentStart) + ")");
                            var regexpEnd = new RegExp("(?:" + escapeRegExp(lineCommentEnd) + ")\\s*$");
                            var comment = function comment(line, i) {
                                if (testRemove(line, i)) return;
                                if (!ignoreBlankLines || /\S/.test(line)) {
                                    doc.insertInLine({ row: i, column: line.length }, lineCommentEnd);
                                    doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                                }
                            };
                            var uncomment = function uncomment(line, i) {
                                var m;
                                if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                                if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                            };
                            var testRemove = function testRemove(line, row) {
                                if (regexpStart.test(line)) return true;
                                var tokens = session.getTokens(row);
                                for (var i = 0; i < tokens.length; i++) {
                                    if (tokens[i].type === 'comment') return true;
                                }
                            };
                        } else {
                            if (Array.isArray(this.lineCommentStart)) {
                                var regexpStartString = this.lineCommentStart.map(escapeRegExp).join("|");
                                lineCommentStart = this.lineCommentStart[0];
                            } else {
                                var regexpStartString = escapeRegExp(this.lineCommentStart);
                                lineCommentStart = this.lineCommentStart;
                            }
                            regexpStart = new RegExp("^(\\s*)(?:" + regexpStartString + ") ?");
                            insertAtTabStop = session.getUseSoftTabs();
                            var uncomment = function uncomment(line, i) {
                                var m = line.match(regexpStart);
                                if (!m) return;
                                var start = m[1].length,
                                    end = m[0].length;
                                if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                                doc.removeInLine(i, start, end);
                            };
                            var commentWithSpace = lineCommentStart + " ";
                            var comment = function comment(line, i) {
                                if (!ignoreBlankLines || /\S/.test(line)) {
                                    if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({ row: i, column: minIndent }, commentWithSpace);else doc.insertInLine({ row: i, column: minIndent }, lineCommentStart);
                                }
                            };
                            var testRemove = function testRemove(line, i) {
                                return regexpStart.test(line);
                            };
                            var shouldInsertSpace = function shouldInsertSpace(line, before, after) {
                                var spaces = 0;
                                while (before-- && line.charAt(before) == " ") spaces++;
                                if (spaces % tabSize != 0) return false;
                                var spaces = 0;
                                while (line.charAt(after++) == " ") spaces++;
                                if (tabSize > 2) return spaces % tabSize != tabSize - 1;else return spaces % tabSize == 0;
                                return true;
                            };
                        }
                        function iter(fun) {
                            for (var i = startRow; i <= endRow; i++) fun(doc.getLine(i), i);
                        }
                        var minEmptyLength = Infinity;
                        iter(function (line, row) {
                            var indent = line.search(/\S/);
                            if (indent !== -1) {
                                if (indent < minIndent) minIndent = indent;
                                if (shouldRemove && !testRemove(line, row)) shouldRemove = false;
                            } else if (minEmptyLength > line.length) {
                                minEmptyLength = line.length;
                            }
                        });
                        if (minIndent == Infinity) {
                            minIndent = minEmptyLength;
                            ignoreBlankLines = false;
                            shouldRemove = false;
                        }
                        if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;
                        iter(shouldRemove ? uncomment : comment);
                    }
                }, {
                    key: "toggleBlockComment",
                    value: function toggleBlockComment(state, session, range, cursor) {
                        var comment = this.blockComment;
                        if (!comment) return;
                        if (!comment.start && comment[0]) comment = comment[0];
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        var token = iterator.getCurrentToken();
                        var selection = session.getSelection();
                        var initialRange = selection.toOrientedRange();
                        var startRow, colDiff;
                        if (token && /comment/.test(token.type)) {
                            var startRange, endRange;
                            while (token && /comment/.test(token.type)) {
                                var i = token.value.indexOf(comment.start);
                                if (i != -1) {
                                    var row = iterator.getCurrentTokenRow();
                                    var column = iterator.getCurrentTokenColumn() + i;
                                    startRange = new Range(row, column, row, column + comment.start.length);
                                    break;
                                }
                                token = iterator.stepBackward();
                            }
                            var iterator = new TokenIterator(session, cursor.row, cursor.column);
                            var token = iterator.getCurrentToken();
                            while (token && /comment/.test(token.type)) {
                                var i = token.value.indexOf(comment.end);
                                if (i != -1) {
                                    var row = iterator.getCurrentTokenRow();
                                    var column = iterator.getCurrentTokenColumn() + i;
                                    endRange = new Range(row, column, row, column + comment.end.length);
                                    break;
                                }
                                token = iterator.stepForward();
                            }
                            if (endRange) session.remove(endRange);
                            if (startRange) {
                                session.remove(startRange);
                                startRow = startRange.start.row;
                                colDiff = -comment.start.length;
                            }
                        } else {
                            colDiff = comment.start.length;
                            startRow = range.start.row;
                            session.insert(range.end, comment.end);
                            session.insert(range.start, comment.start);
                        }
                        if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
                        if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
                        session.getSelection().fromOrientedRange(initialRange);
                    }
                }, {
                    key: "getNextLineIndent",
                    value: function getNextLineIndent(state, line, tab) {
                        return this.$getIndent(line);
                    }
                }, {
                    key: "checkOutdent",
                    value: function checkOutdent(state, line, text) {
                        return false;
                    }
                }, {
                    key: "autoOutdent",
                    value: function autoOutdent(state, session, row) {
                        return 0;
                    }
                }, {
                    key: "$getIndent",
                    value: function $getIndent(line) {
                        return line.match(/^\s*/)[0];
                    }
                }, {
                    key: "createWorker",
                    value: function createWorker(session) {
                        return new _Promise(function (success, fail) {
                            success(void 0);
                        });
                    }
                }, {
                    key: "createModeDelegates",
                    value: function createModeDelegates(mapping) {
                        this.$embeds = [];
                        this.$modes = {};
                        for (var p in mapping) {
                            if (mapping[p]) {
                                this.$embeds.push(p);
                                this.$modes[p] = new mapping[p](this.workerUrl, this.scriptImports);
                            }
                        }
                        var delegations = ['toggleBlockComment', 'toggleCommentLines', 'getNextLineIndent', 'checkOutdent', 'autoOutdent', 'transformAction', 'getCompletions'];
                        for (var k = 0; k < delegations.length; k++) {
                            (function (scope) {
                                var functionName = delegations[k];
                                var defaultHandler = scope[functionName];
                                scope[delegations[k]] = function () {
                                    return this.$delegator(functionName, arguments, defaultHandler);
                                };
                            })(this);
                        }
                    }
                }, {
                    key: "$delegator",
                    value: function $delegator(method, args, defaultHandler) {
                        var state = args[0];
                        if (typeof state != "string") state = state[0];
                        for (var i = 0; i < this.$embeds.length; i++) {
                            if (!this.$modes[this.$embeds[i]]) continue;
                            var split = state.split(this.$embeds[i]);
                            if (!split[0] && split[1]) {
                                args[0] = split[1];
                                var mode = this.$modes[this.$embeds[i]];
                                return mode[method].apply(mode, args);
                            }
                        }
                        var ret = defaultHandler.apply(this, args);
                        return defaultHandler ? ret : undefined;
                    }
                }, {
                    key: "transformAction",
                    value: function transformAction(state, action, editor, session, param) {
                        if (this.$behaviour) {
                            var behaviours = this.$behaviour.getBehaviours();
                            for (var key in behaviours) {
                                if (behaviours[key][action]) {
                                    var ret = behaviours[key][action].apply(this, arguments);
                                    if (ret) {
                                        return ret;
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "getKeywords",
                    value: function getKeywords(append) {
                        if (!this.completionKeywords) {
                            var rules = this.$tokenizer.states;
                            var completionKeywords = [];
                            for (var rule in rules) {
                                var ruleItr = rules[rule];
                                for (var r = 0, l = ruleItr.length; r < l; r++) {
                                    if (typeof ruleItr[r].token === "string") {
                                        if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                                    } else if (typeof ruleItr[r].token === "object") {
                                        for (var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++) {
                                            if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                                completionKeywords.push(rule.substr(1, rule.length - 2));
                                            }
                                        }
                                    }
                                }
                            }
                            this.completionKeywords = completionKeywords;
                        }
                        if (!append) {
                            return this.$keywordList;
                        }
                        return completionKeywords.concat(this.$keywordList || []);
                    }
                }, {
                    key: "$createKeywordList",
                    value: function $createKeywordList() {
                        if (!this.$highlightRules) this.getTokenizer();
                        return this.$keywordList = this.$highlightRules.$keywordList || [];
                    }
                }, {
                    key: "getCompletions",
                    value: function getCompletions(state, session, pos, prefix) {
                        var keywords = this.$keywordList || this.$createKeywordList();
                        return keywords.map(function (word) {
                            return {
                                name: word,
                                value: word,
                                score: 0,
                                meta: "keyword"
                            };
                        });
                    }
                }]);

                return TextMode;
            })();

            _export("default", TextMode);
        }
    };
});
System.register("src/mode/JavaScriptMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/mode/TextMode.js", "src/mode/JavaScriptHighlightRules.js", "src/mode/MatchingBraceOutdent.js", "src/worker/WorkerClient.js", "src/mode/behaviour/CstyleBehaviour.js", "src/mode/folding/CstyleFoldMode.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _Promise, TextMode, JavaScriptHighlightRules, MatchingBraceOutdent, WorkerClient, CstyleBehaviour, CStyleFoldMode, JavaScriptMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcModeTextModeJs) {
            TextMode = _srcModeTextModeJs["default"];
        }, function (_srcModeJavaScriptHighlightRulesJs) {
            JavaScriptHighlightRules = _srcModeJavaScriptHighlightRulesJs["default"];
        }, function (_srcModeMatchingBraceOutdentJs) {
            MatchingBraceOutdent = _srcModeMatchingBraceOutdentJs["default"];
        }, function (_srcWorkerWorkerClientJs) {
            WorkerClient = _srcWorkerWorkerClientJs["default"];
        }, function (_srcModeBehaviourCstyleBehaviourJs) {
            CstyleBehaviour = _srcModeBehaviourCstyleBehaviourJs["default"];
        }, function (_srcModeFoldingCstyleFoldModeJs) {
            CStyleFoldMode = _srcModeFoldingCstyleFoldModeJs["default"];
        }],
        execute: function () {
            "use strict";

            JavaScriptMode = (function (_TextMode) {
                _inherits(JavaScriptMode, _TextMode);

                function JavaScriptMode(workerUrl, scriptImports) {
                    _classCallCheck(this, JavaScriptMode);

                    _get(Object.getPrototypeOf(JavaScriptMode.prototype), "constructor", this).call(this, workerUrl, scriptImports);
                    this.HighlightRules = JavaScriptHighlightRules;
                    this.$outdent = new MatchingBraceOutdent();
                    this.$behaviour = new CstyleBehaviour();
                    this.foldingRules = new CStyleFoldMode();
                    this.lineCommentStart = "//";
                    this.blockComment = { start: "/*", end: "*/" };
                    this.$id = "ace/mode/javascript";
                }

                _createClass(JavaScriptMode, [{
                    key: "getNextLineIndent",
                    value: function getNextLineIndent(state, line, tab) {
                        var indent = this.$getIndent(line);
                        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
                        var tokens = tokenizedLine.tokens;
                        var endState = tokenizedLine.state;
                        if (tokens.length && tokens[tokens.length - 1].type === "comment") {
                            return indent;
                        }
                        if (state === "start" || state === "no_regex") {
                            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
                            if (match) {
                                indent += tab;
                            }
                        } else if (state === "doc-start") {
                            if (endState == "start" || endState == "no_regex") {
                                return "";
                            }
                            var match = line.match(/^\s*(\/?)\*/);
                            if (match) {
                                if (match[1]) {
                                    indent += " ";
                                }
                                indent += "* ";
                            }
                        }
                        return indent;
                    }
                }, {
                    key: "checkOutdent",
                    value: function checkOutdent(state, line, text) {
                        return this.$outdent.checkOutdent(line, text);
                    }
                }, {
                    key: "autoOutdent",
                    value: function autoOutdent(state, session, row) {
                        return this.$outdent.autoOutdent(session, row);
                    }
                }, {
                    key: "createWorker",
                    value: function createWorker(session) {
                        var _this = this;

                        return new _Promise(function (resolve, reject) {
                            var worker = new WorkerClient(_this.workerUrl);
                            worker.on("initAfter", function () {
                                worker.attachToDocument(session.getDocument());
                                resolve(worker);
                            });
                            worker.on("initFailed", function (event) {
                                reject(event.data);
                            });
                            worker.on("errors", function (errors) {
                                session.setAnnotations(errors.data);
                            });
                            worker.on("terminate", function () {
                                worker.detachFromDocument();
                                session.clearAnnotations();
                            });
                            worker.init(_this.scriptImports, 'ace-workers.js', 'JavaScriptWorker');
                        });
                    }
                }]);

                return JavaScriptMode;
            })(TextMode);

            _export("default", JavaScriptMode);
        }
    };
});
System.register("src/mode/DocCommentHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/TextHighlightRules.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, TextHighlightRules, DocCommentHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeTextHighlightRulesJs) {
            TextHighlightRules = _srcModeTextHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";

            DocCommentHighlightRules = (function (_TextHighlightRules) {
                _inherits(DocCommentHighlightRules, _TextHighlightRules);

                function DocCommentHighlightRules() {
                    _classCallCheck(this, DocCommentHighlightRules);

                    _get(Object.getPrototypeOf(DocCommentHighlightRules.prototype), "constructor", this).call(this);
                    this.$rules = {
                        "start": [{
                            token: "comment.doc.tag",
                            regex: "@[\\w\\d_]+"
                        }, {
                            token: "comment.doc.tag",
                            regex: "\\bTODO\\b"
                        }, {
                            defaultToken: "comment.doc"
                        }]
                    };
                }

                _createClass(DocCommentHighlightRules, null, [{
                    key: "getStartRule",
                    value: function getStartRule(start) {
                        return {
                            token: "comment.doc",
                            regex: "\\/\\*(?=\\*)",
                            next: start
                        };
                    }
                }, {
                    key: "getEndRule",
                    value: function getEndRule(start) {
                        return {
                            token: "comment.doc",
                            regex: "\\*\\/",
                            next: start
                        };
                    }
                }]);

                return DocCommentHighlightRules;
            })(TextHighlightRules);

            _export("default", DocCommentHighlightRules);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-object", ["npm:core-js@1.2.6/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('npm:core-js@1.2.6/library/modules/$.defined');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.keys", ["npm:core-js@1.2.6/library/modules/$.to-object", "npm:core-js@1.2.6/library/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = $__require('npm:core-js@1.2.6/library/modules/$.to-object');
  $__require('npm:core-js@1.2.6/library/modules/$.object-sap')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/keys", ["npm:core-js@1.2.6/library/modules/es6.object.keys", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.keys');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').Object.keys;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/keys", ["npm:core-js@1.2.6/library/fn/object/keys"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/keys'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("src/mode/TextHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/object/keys", "npm:babel-runtime@5.8.34/core-js/object/create", "src/lib/lang.js"], function (_export) {
    var _createClass, _classCallCheck, _Object$keys, _Object$create, deepCopy, TextHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectKeys) {
            _Object$keys = _npmBabelRuntime5834CoreJsObjectKeys["default"];
        }, function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate["default"];
        }, function (_srcLibLangJs) {
            deepCopy = _srcLibLangJs.deepCopy;
        }],
        execute: function () {
            "use strict";

            TextHighlightRules = (function () {
                function TextHighlightRules() {
                    _classCallCheck(this, TextHighlightRules);

                    this.$rules = {
                        "start": [{
                            token: "empty_line",
                            regex: '^$'
                        }, {
                            defaultToken: "text"
                        }]
                    };
                }

                _createClass(TextHighlightRules, [{
                    key: "addRules",
                    value: function addRules(rules, prefix) {
                        if (!prefix) {
                            for (var key in rules) this.$rules[key] = rules[key];
                            return;
                        }
                        for (var key in rules) {
                            var state = rules[key];
                            for (var i = 0; i < state.length; i++) {
                                var rule = state[i];
                                if (rule.next || rule.onMatch) {
                                    if (typeof rule.next != "string") {
                                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                                    } else {
                                        if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                                    }
                                }
                            }
                            this.$rules[prefix + key] = state;
                        }
                    }
                }, {
                    key: "getRules",
                    value: function getRules() {
                        return this.$rules;
                    }
                }, {
                    key: "embedRules",
                    value: function embedRules(HighlightRules, prefix, escapeRules, states, append) {
                        var embedRules = typeof HighlightRules === "function" ? new HighlightRules().getRules() : HighlightRules;
                        if (states) {
                            for (var i = 0; i < states.length; i++) states[i] = prefix + states[i];
                        } else {
                            states = [];
                            for (var key in embedRules) states.push(prefix + key);
                        }
                        this.addRules(embedRules, prefix);
                        if (escapeRules) {
                            var addRules = Array.prototype[append ? "push" : "unshift"];
                            for (var i = 0; i < states.length; i++) addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
                        }
                        if (!this.$embeds) this.$embeds = [];
                        this.$embeds.push(prefix);
                    }
                }, {
                    key: "getEmbeds",
                    value: function getEmbeds() {
                        return this.$embeds;
                    }
                }, {
                    key: "normalizeRules",
                    value: function normalizeRules() {
                        var pushState = function pushState(currentState, stack) {
                            if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
                            return this.nextState;
                        };
                        var popState = function popState(currentState, stack) {
                            stack.shift();
                            return stack.shift() || "start";
                        };
                        var id = 0;
                        var rules = this.$rules;
                        function processState(key) {
                            var state = rules[key];
                            state.processed = true;
                            for (var i = 0; i < state.length; i++) {
                                var rule = state[i];
                                if (!rule.regex && rule.start) {
                                    rule.regex = rule.start;
                                    if (!rule.next) rule.next = [];
                                    rule.next.push({
                                        defaultToken: rule.token
                                    }, {
                                        token: rule.token + ".end",
                                        regex: rule.end || rule.start,
                                        next: "pop"
                                    });
                                    rule.token = rule.token + ".start";
                                    rule.push = true;
                                }
                                var next = rule.next || rule.push;
                                if (next && Array.isArray(next)) {
                                    var stateName = rule.stateName;
                                    if (!stateName) {
                                        stateName = rule.token;
                                        if (typeof stateName != "string") stateName = stateName[0] || "";
                                        if (rules[stateName]) stateName += id++;
                                    }
                                    rules[stateName] = next;
                                    rule.next = stateName;
                                    processState(stateName);
                                } else if (next == "pop") {
                                    rule.next = popState;
                                }
                                if (rule.push) {
                                    rule.nextState = rule.next || rule.push;
                                    rule.next = pushState;
                                    delete rule.push;
                                }
                                if (rule.rules) {
                                    for (var r in rule.rules) {
                                        if (rules[r]) {
                                            if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                                        } else {
                                            rules[r] = rule.rules[r];
                                        }
                                    }
                                }
                                if (rule.include || typeof rule === "string") {
                                    var includeName = rule.include || rule;
                                    var toInsert = rules[includeName];
                                } else if (Array.isArray(rule)) toInsert = rule;
                                if (toInsert) {
                                    var args = [i, 1].concat(toInsert);
                                    if (rule.noEscape) {
                                        args = args.filter(function (x) {
                                            return !x['next'];
                                        });
                                    }
                                    state.splice.apply(state, args);
                                    i--;
                                    toInsert = null;
                                }
                                if (rule.keywordMap) {
                                    rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                                    delete rule.defaultToken;
                                }
                            }
                        }
                        _Object$keys(rules).forEach(processState, this);
                    }
                }, {
                    key: "createKeywordMapper",
                    value: function createKeywordMapper(map, defaultToken, ignoreCase, splitChar) {
                        var keywords = _Object$create(null);
                        _Object$keys(map).forEach(function (className) {
                            var a = map[className];
                            if (ignoreCase) a = a.toLowerCase();
                            var list = a.split(splitChar || "|");
                            for (var i = list.length; i--;) keywords[list[i]] = className;
                        });
                        if (Object.getPrototypeOf(keywords)) {
                            keywords.__proto__ = null;
                        }
                        this.$keywordList = _Object$keys(keywords);
                        map = null;
                        return ignoreCase ? function (value) {
                            return keywords[value.toLowerCase()] || defaultToken;
                        } : function (value) {
                            return keywords[value] || defaultToken;
                        };
                    }
                }, {
                    key: "getKeywords",
                    value: function getKeywords() {
                        return this.$keywordList;
                    }
                }]);

                return TextHighlightRules;
            })();

            _export("default", TextHighlightRules);
        }
    };
});
System.register("src/mode/JavaScriptHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/DocCommentHighlightRules.js", "src/mode/TextHighlightRules.js"], function (_export) {
    var _get, _inherits, _classCallCheck, DocCommentHighlightRules, TextHighlightRules, JavaScriptHighlightRules;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeDocCommentHighlightRulesJs) {
            DocCommentHighlightRules = _srcModeDocCommentHighlightRulesJs["default"];
        }, function (_srcModeTextHighlightRulesJs) {
            TextHighlightRules = _srcModeTextHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";

            JavaScriptHighlightRules = (function (_TextHighlightRules) {
                _inherits(JavaScriptHighlightRules, _TextHighlightRules);

                function JavaScriptHighlightRules(options) {
                    _classCallCheck(this, JavaScriptHighlightRules);

                    _get(Object.getPrototypeOf(JavaScriptHighlightRules.prototype), "constructor", this).call(this);
                    var keywordMapper = this.createKeywordMapper({
                        "variable.language": "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|" + "Namespace|QName|XML|XMLList|" + "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|" + "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|" + "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|" + "SyntaxError|TypeError|URIError|" + "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + "isNaN|parseFloat|parseInt|" + "JSON|Math|" + "this|arguments|prototype|window|document",
                        "keyword": "const|yield|import|get|set|" + "break|case|catch|continue|default|delete|do|else|finally|for|function|" + "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" + "__parent__|__count__|escape|unescape|with|__proto__|" + "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
                        "storage.type": "const|let|var|function",
                        "constant.language": "null|Infinity|NaN|undefined",
                        "support.function": "alert",
                        "constant.language.boolean": "true|false"
                    }, "identifier");
                    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
                    var identifierRe = "[a-zA-Z\\$_¡-￿][a-zA-Z\\d\\$_¡-￿]*\\b";
                    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + "u[0-9a-fA-F]{4}|" + "[0-2][0-7]{0,2}|" + "3[0-6][0-7]?|" + "37[0-7]?|" + "[4-7][0-7]?|" + ".)";
                    this.$rules = {
                        "no_regex": [{
                            token: "comment",
                            regex: "\\/\\/",
                            next: "line_comment"
                        }, DocCommentHighlightRules.getStartRule("doc-start"), {
                            token: "comment",
                            regex: /\/\*/,
                            next: "comment"
                        }, {
                            token: "string",
                            regex: "'(?=.)",
                            next: "qstring"
                        }, {
                            token: "string",
                            regex: '"(?=.)',
                            next: "qqstring"
                        }, {
                            token: "constant.numeric",
                            regex: /0[xX][0-9a-fA-F]+\b/
                        }, {
                            token: "constant.numeric",
                            regex: /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
                        }, {
                            token: ["storage.type", "punctuation.operator", "support.function", "punctuation.operator", "entity.name.function", "text", "keyword.operator"],
                            regex: "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe + ")(\\s*)(=)",
                            next: "function_arguments"
                        }, {
                            token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                            regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: ["entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "paren.lparen"],
                            regex: "(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: ["storage.type", "punctuation.operator", "entity.name.function", "text", "keyword.operator", "text", "storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                            regex: "(" + identifierRe + ")(\\.)(" + identifierRe + ")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: ["storage.type", "text", "entity.name.function", "text", "paren.lparen"],
                            regex: "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: ["entity.name.function", "text", "punctuation.operator", "text", "storage.type", "text", "paren.lparen"],
                            regex: "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: ["text", "text", "storage.type", "text", "paren.lparen"],
                            regex: "(:)(\\s*)(function)(\\s*)(\\()",
                            next: "function_arguments"
                        }, {
                            token: "keyword",
                            regex: "(?:" + kwBeforeRe + ")\\b",
                            next: "start"
                        }, {
                            token: ["punctuation.operator", "support.function"],
                            regex: /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
                        }, {
                            token: ["punctuation.operator", "support.function.dom"],
                            regex: /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
                        }, {
                            token: ["punctuation.operator", "support.constant"],
                            regex: /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
                        }, {
                            token: ["support.constant"],
                            regex: /that\b/
                        }, {
                            token: ["storage.type", "punctuation.operator", "support.function.firebug"],
                            regex: /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
                        }, {
                            token: keywordMapper,
                            regex: identifierRe
                        }, {
                            token: "keyword.operator",
                            regex: /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
                            next: "start"
                        }, {
                            token: "punctuation.operator",
                            regex: /[?:,;.]/,
                            next: "start"
                        }, {
                            token: "paren.lparen",
                            regex: /[\[({]/,
                            next: "start"
                        }, {
                            token: "paren.rparen",
                            regex: /[\])}]/
                        }, {
                            token: "comment",
                            regex: /^#!.*$/
                        }],
                        "start": [DocCommentHighlightRules.getStartRule("doc-start"), {
                            token: "comment",
                            regex: "\\/\\*",
                            next: "comment_regex_allowed"
                        }, {
                            token: "comment",
                            regex: "\\/\\/",
                            next: "line_comment_regex_allowed"
                        }, {
                            token: "string.regexp",
                            regex: "\\/",
                            next: "regex"
                        }, {
                            token: "text",
                            regex: "\\s+|^$",
                            next: "start"
                        }, {
                            token: "empty",
                            regex: "",
                            next: "no_regex"
                        }],
                        "regex": [{
                            token: "regexp.keyword.operator",
                            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                        }, {
                            token: "string.regexp",
                            regex: "/[sxngimy]*",
                            next: "no_regex"
                        }, {
                            token: "invalid",
                            regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
                        }, {
                            token: "constant.language.escape",
                            regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
                        }, {
                            token: "constant.language.delimiter",
                            regex: /\|/
                        }, {
                            token: "constant.language.escape",
                            regex: /\[\^?/,
                            next: "regex_character_class"
                        }, {
                            token: "empty",
                            regex: "$",
                            next: "no_regex"
                        }, {
                            defaultToken: "string.regexp"
                        }],
                        "regex_character_class": [{
                            token: "regexp.charclass.keyword.operator",
                            regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
                        }, {
                            token: "constant.language.escape",
                            regex: "]",
                            next: "regex"
                        }, {
                            token: "constant.language.escape",
                            regex: "-"
                        }, {
                            token: "empty",
                            regex: "$",
                            next: "no_regex"
                        }, {
                            defaultToken: "string.regexp.charachterclass"
                        }],
                        "function_arguments": [{
                            token: "variable.parameter",
                            regex: identifierRe
                        }, {
                            token: "punctuation.operator",
                            regex: "[, ]+"
                        }, {
                            token: "punctuation.operator",
                            regex: "$"
                        }, {
                            token: "empty",
                            regex: "",
                            next: "no_regex"
                        }],
                        "comment_regex_allowed": [{ token: "comment", regex: "\\*\\/", next: "start" }, { defaultToken: "comment" }],
                        "comment": [{ token: "comment", regex: "\\*\\/", next: "no_regex" }, { defaultToken: "comment" }],
                        "line_comment_regex_allowed": [{ token: "comment", regex: "$|^", next: "start" }, { defaultToken: "comment" }],
                        "line_comment": [{ token: "comment", regex: "$|^", next: "no_regex" }, { defaultToken: "comment" }],
                        "qqstring": [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "string",
                            regex: "\\\\$",
                            next: "qqstring"
                        }, {
                            token: "string",
                            regex: '"|$',
                            next: "no_regex"
                        }, {
                            defaultToken: "string"
                        }],
                        "qstring": [{
                            token: "constant.language.escape",
                            regex: escapedRe
                        }, {
                            token: "string",
                            regex: "\\\\$",
                            next: "qstring"
                        }, {
                            token: "string",
                            regex: "'|$",
                            next: "no_regex"
                        }, {
                            defaultToken: "string"
                        }]
                    };
                    if (!options || !options.noES6) {
                        this.$rules.no_regex.unshift({
                            regex: "[{}]", onMatch: function onMatch(val, state, stack) {
                                this.next = val == "{" ? this.nextState : "";
                                if (val == "{" && stack.length) {
                                    stack.unshift("start", state);
                                    return "paren";
                                }
                                if (val == "}" && stack.length) {
                                    stack.shift();
                                    this.next = stack.shift();
                                    if (this.next.indexOf("string") != -1) return "paren.quasi.end";
                                }
                                return val == "{" ? "paren.lparen" : "paren.rparen";
                            },
                            nextState: "start"
                        }, {
                            token: "string.quasi.start",
                            regex: /`/,
                            push: [{
                                token: "constant.language.escape",
                                regex: escapedRe
                            }, {
                                token: "paren.quasi.start",
                                regex: /\${/,
                                push: "start"
                            }, {
                                token: "string.quasi.end",
                                regex: /`/,
                                next: "pop"
                            }, {
                                defaultToken: "string.quasi"
                            }]
                        });
                    }
                    this.embedRules(DocCommentHighlightRules, "doc-", [DocCommentHighlightRules.getEndRule("no_regex")]);
                    this.normalizeRules();
                }

                return JavaScriptHighlightRules;
            })(TextHighlightRules);

            _export("default", JavaScriptHighlightRules);
        }
    };
});
System.register("src/mode/TypeScriptHighlightRules.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/JavaScriptHighlightRules.js"], function (_export) {
    var _get, _inherits, _classCallCheck, JavaScriptHighlightRules, TypeScriptHighlightRiles;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeJavaScriptHighlightRulesJs) {
            JavaScriptHighlightRules = _srcModeJavaScriptHighlightRulesJs["default"];
        }],
        execute: function () {
            "use strict";

            TypeScriptHighlightRiles = (function (_JavaScriptHighlightRules) {
                _inherits(TypeScriptHighlightRiles, _JavaScriptHighlightRules);

                function TypeScriptHighlightRiles(options) {
                    _classCallCheck(this, TypeScriptHighlightRiles);

                    _get(Object.getPrototypeOf(TypeScriptHighlightRiles.prototype), "constructor", this).call(this, options);
                    var tsRules = [{
                        token: ["keyword.operator.ts", "text", "variable.parameter.function.ts", "text"],
                        regex: "\\b(module)(\\s*)([a-zA-Z0-9_?.$][\\w?.$]*)(\\s*\\{)"
                    }, {
                        token: ["storage.type.variable.ts", "text", "keyword.other.ts", "text"],
                        regex: "(super)(\\s*\\()([a-zA-Z0-9,_?.$\\s]+\\s*)(\\))"
                    }, {
                        token: ["entity.name.function.ts", "paren.lparen", "paren.rparen"],
                        regex: "([a-zA-Z_?.$][\\w?.$]*)(\\()(\\))"
                    }, {
                        token: ["variable.parameter.function.ts", "text", "variable.parameter.function.ts"],
                        regex: "([a-zA-Z0-9_?.$][\\w?.$]*)(\\s*:\\s*)([a-zA-Z0-9_?.$][\\w?.$]*)"
                    }, {
                        token: ["keyword.operator.ts"],
                        regex: "(?:\\b(constructor|declare|interface|as|AS|public|private|class|extends|export|super)\\b)"
                    }, {
                        token: ["storage.type.variable.ts"],
                        regex: "(?:\\b(this\\.|string\\b|bool\\b|number)\\b)"
                    }, {
                        token: ["keyword.operator.ts", "storage.type.variable.ts", "keyword.operator.ts", "storage.type.variable.ts"],
                        regex: "(class)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*\\s+)(extends)(\\s+[a-zA-Z0-9_?.$][\\w?.$]*\\s+)?"
                    }, {
                        token: "keyword",
                        regex: "(?:super|export|class|extends|import)\\b"
                    }];
                    var JSRules = new JavaScriptHighlightRules().getRules();
                    JSRules.start = tsRules.concat(JSRules.start);
                    this.$rules = JSRules;
                }

                return TypeScriptHighlightRiles;
            })(JavaScriptHighlightRules);

            _export("default", TypeScriptHighlightRiles);
        }
    };
});
System.register("src/mode/Behaviour.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, Behaviour;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            Behaviour = (function () {
                function Behaviour() {
                    _classCallCheck(this, Behaviour);

                    this.$behaviours = {};
                }

                _createClass(Behaviour, [{
                    key: "add",
                    value: function add(name, action, callback) {
                        switch (undefined) {
                            case this.$behaviours:
                                this.$behaviours = {};
                            case this.$behaviours[name]:
                                this.$behaviours[name] = {};
                        }
                        this.$behaviours[name][action] = callback;
                    }
                }, {
                    key: "addBehaviours",
                    value: function addBehaviours(behaviours) {
                        for (var key in behaviours) {
                            for (var action in behaviours[key]) {
                                this.add(key, action, behaviours[key][action]);
                            }
                        }
                    }
                }, {
                    key: "remove",
                    value: function remove(name) {
                        if (this.$behaviours && this.$behaviours[name]) {
                            delete this.$behaviours[name];
                        }
                    }
                }, {
                    key: "inherit",
                    value: function inherit(base, filter) {
                        var behaviours = base.getBehaviours(filter);
                        this.addBehaviours(behaviours);
                    }
                }, {
                    key: "getBehaviours",
                    value: function getBehaviours(filter) {
                        if (!filter) {
                            return this.$behaviours;
                        } else {
                            var ret = {};
                            for (var i = 0; i < filter.length; i++) {
                                if (this.$behaviours[filter[i]]) {
                                    ret[filter[i]] = this.$behaviours[filter[i]];
                                }
                            }
                            return ret;
                        }
                    }
                }]);

                return Behaviour;
            })();

            _export("default", Behaviour);
        }
    };
});
System.register("src/TokenIterator.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, TokenIterator;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            TokenIterator = (function () {
                function TokenIterator(session, initialRow, initialColumn) {
                    _classCallCheck(this, TokenIterator);

                    this.session = session;
                    this.$row = initialRow;
                    this.$rowTokens = session.getTokens(initialRow);
                    var token = session.getTokenAt(initialRow, initialColumn);
                    this.$tokenIndex = token ? token.index : -1;
                }

                _createClass(TokenIterator, [{
                    key: "stepBackward",
                    value: function stepBackward() {
                        this.$tokenIndex -= 1;
                        while (this.$tokenIndex < 0) {
                            this.$row -= 1;
                            if (this.$row < 0) {
                                this.$row = 0;
                                return null;
                            }
                            this.$rowTokens = this.session.getTokens(this.$row);
                            this.$tokenIndex = this.$rowTokens.length - 1;
                        }
                        return this.$rowTokens[this.$tokenIndex];
                    }
                }, {
                    key: "stepForward",
                    value: function stepForward() {
                        if (this.$rowTokens) {
                            this.$tokenIndex += 1;
                            var rowCount;
                            while (this.$tokenIndex >= this.$rowTokens.length) {
                                this.$row += 1;
                                if (!rowCount) {
                                    rowCount = this.session.getLength();
                                }
                                if (this.$row >= rowCount) {
                                    this.$row = rowCount - 1;
                                    return null;
                                }
                                this.$rowTokens = this.session.getTokens(this.$row);
                                this.$tokenIndex = 0;
                            }
                            return this.$rowTokens[this.$tokenIndex];
                        } else {
                            return void 0;
                        }
                    }
                }, {
                    key: "getCurrentToken",
                    value: function getCurrentToken() {
                        if (this.$rowTokens) {
                            return this.$rowTokens[this.$tokenIndex];
                        } else {
                            return void 0;
                        }
                    }
                }, {
                    key: "getCurrentTokenRow",
                    value: function getCurrentTokenRow() {
                        return this.$row;
                    }
                }, {
                    key: "getCurrentTokenColumn",
                    value: function getCurrentTokenColumn() {
                        var rowTokens = this.$rowTokens;
                        var tokenIndex = this.$tokenIndex;
                        var column = rowTokens[tokenIndex].start;
                        if (column !== undefined) return column;
                        column = 0;
                        while (tokenIndex > 0) {
                            tokenIndex -= 1;
                            column += rowTokens[tokenIndex].value.length;
                        }
                        return column;
                    }
                }]);

                return TokenIterator;
            })();

            _export("default", TokenIterator);
        }
    };
});
System.register("src/lib/lang.js", ["npm:babel-runtime@5.8.34/core-js/object/create"], function (_export) {
    var _Object$create, trimBeginRegexp, trimEndRegexp;

    function last(a) {
        return a[a.length - 1];
    }

    function stringReverse(s) {
        return s.split("").reverse().join("");
    }

    function stringRepeat(s, count) {
        var result = '';
        while (count > 0) {
            if (count & 1) {
                result += s;
            }
            if (count >>= 1) {
                s += s;
            }
        }
        return result;
    }

    function stringTrimLeft(s) {
        return s.replace(trimBeginRegexp, '');
    }

    function stringTrimRight(s) {
        return s.replace(trimEndRegexp, '');
    }

    function copyObject(obj) {
        var copy = {};
        for (var key in obj) {
            copy[key] = obj[key];
        }
        return copy;
    }

    function copyArray(array) {
        var copy = [];
        for (var i = 0, l = array.length; i < l; i++) {
            if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);else copy[i] = array[i];
        }
        return copy;
    }

    function deepCopy(obj) {
        if (typeof obj !== "object" || !obj) return obj;
        var cons = obj.constructor;
        if (cons === RegExp) return obj;
        var copy = cons();
        for (var key in obj) {
            if (typeof obj[key] === "object") {
                copy[key] = deepCopy(obj[key]);
            } else {
                copy[key] = obj[key];
            }
        }
        return copy;
    }

    function arrayToMap(xs, value) {
        var map = {};
        for (var i = 0, iLength = xs.length; i < iLength; i++) {
            map[xs[i]] = value;
        }
        return map;
    }

    function createMap(props) {
        var map = _Object$create(null);
        for (var i in props) {
            map[i] = props[i];
        }
        return map;
    }

    function arrayRemove(array, value) {
        for (var i = 0; i <= array.length; i++) {
            if (value === array[i]) {
                array.splice(i, 1);
            }
        }
    }

    function escapeRegExp(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
    }

    function escapeHTML(str) {
        return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    }

    function getMatchOffsets(s, searchValue) {
        var matches = [];
        s.replace(searchValue, function (str) {
            matches.push({
                offset: arguments[arguments.length - 2],
                length: str.length
            });
            return "lang.getMatchOffsets";
        });
        return matches;
    }

    function deferredCall(fcn) {
        var timer = null;
        var callback = function callback() {
            timer = null;
            fcn();
        };
        var deferred = function deferred(timeout) {
            deferred.cancel();
            timer = setTimeout(callback, timeout || 0);
            return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function () {
            this.cancel();
            fcn();
            return deferred;
        };
        deferred.cancel = function () {
            clearTimeout(timer);
            timer = null;
            return deferred;
        };
        deferred.isPending = function () {
            return timer;
        };
        return deferred;
    }

    function delayedCall(fcn, defaultTimeout) {
        var timer = null;
        var callback = function callback() {
            timer = null;
            fcn();
        };
        var _self = function _self(timeout) {
            if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function (timeout) {
            timer && clearTimeout(timer);
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function () {
            this.cancel();
            fcn();
        };
        _self.cancel = function () {
            timer && clearTimeout(timer);
            timer = null;
        };
        _self.isPending = function () {
            return timer;
        };
        return _self;
    }

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectCreate) {
            _Object$create = _npmBabelRuntime5834CoreJsObjectCreate["default"];
        }],
        execute: function () {
            "use strict";

            _export("last", last);

            _export("stringReverse", stringReverse);

            _export("stringRepeat", stringRepeat);

            _export("stringTrimLeft", stringTrimLeft);

            _export("stringTrimRight", stringTrimRight);

            _export("copyObject", copyObject);

            _export("copyArray", copyArray);

            _export("deepCopy", deepCopy);

            _export("arrayToMap", arrayToMap);

            _export("createMap", createMap);

            _export("arrayRemove", arrayRemove);

            _export("escapeRegExp", escapeRegExp);

            _export("escapeHTML", escapeHTML);

            _export("getMatchOffsets", getMatchOffsets);

            _export("deferredCall", deferredCall);

            _export("delayedCall", delayedCall);

            trimBeginRegexp = /^\s\s*/;
            trimEndRegexp = /\s\s*$/;

            ;

            ;

            ;

            ;

            ;
        }
    };
});
System.register("src/mode/behaviour/CstyleBehaviour.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/mode/Behaviour.js", "src/TokenIterator.js", "src/lib/lang.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Behaviour, TokenIterator, stringRepeat, SAFE_INSERT_IN_TOKENS, SAFE_INSERT_BEFORE_TOKENS, context, contextCache, initContext, CstyleBehaviour;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcModeBehaviourJs) {
            Behaviour = _srcModeBehaviourJs["default"];
        }, function (_srcTokenIteratorJs) {
            TokenIterator = _srcTokenIteratorJs["default"];
        }, function (_srcLibLangJs) {
            stringRepeat = _srcLibLangJs.stringRepeat;
        }],
        execute: function () {
            "use strict";
            SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "punctuation.operator"];
            SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "punctuation.operator", "comment"];
            contextCache = {};

            initContext = function initContext(editor) {
                var id = -1;
                if (editor.multiSelect) {
                    id = editor.selection['id'];
                    if (contextCache.rangeCount != editor.multiSelect.rangeCount) {
                        contextCache = { rangeCount: editor.multiSelect.rangeCount };
                    }
                }
                if (contextCache[id]) {
                    return context = contextCache[id];
                }
                context = contextCache[id] = {
                    autoInsertedBrackets: 0,
                    autoInsertedRow: -1,
                    autoInsertedLineEnd: "",
                    maybeInsertedBrackets: 0,
                    maybeInsertedRow: -1,
                    maybeInsertedLineStart: "",
                    maybeInsertedLineEnd: ""
                };
            };

            CstyleBehaviour = (function (_Behaviour) {
                _inherits(CstyleBehaviour, _Behaviour);

                function CstyleBehaviour() {
                    _classCallCheck(this, CstyleBehaviour);

                    _get(Object.getPrototypeOf(CstyleBehaviour.prototype), "constructor", this).call(this);
                    this.add("braces", "insertion", function (state, action, editor, session, text) {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        if (text === '{') {
                            initContext(editor);
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                                return {
                                    text: '{' + selected + '}',
                                    selection: void 0
                                };
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                                    return {
                                        text: '{}',
                                        selection: [1, 1]
                                    };
                                } else {
                                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                                    return {
                                        text: '{',
                                        selection: [1, 1]
                                    };
                                }
                            }
                        } else if (text === '}') {
                            initContext(editor);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === '}') {
                                var matching = session.findOpeningBracket('}', { column: cursor.column + 1, row: cursor.row });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return { text: '', selection: [1, 1] };
                                }
                            }
                        } else if (text === "\n" || text === "\r\n") {
                            initContext(editor);
                            var closing = "";
                            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                                closing = stringRepeat("}", context.maybeInsertedBrackets);
                                CstyleBehaviour.clearMaybeInsertedClosing();
                            }
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === '}') {
                                var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, '}');
                                if (!openBracePos) return null;
                                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                            } else if (closing) {
                                var next_indent = this.$getIndent(line);
                            } else {
                                CstyleBehaviour.clearMaybeInsertedClosing();
                                return;
                            }
                            var indent = next_indent + session.getTabString();
                            return {
                                text: '\n' + indent + '\n' + next_indent + closing,
                                selection: [1, indent.length, 1, indent.length]
                            };
                        } else {
                            CstyleBehaviour.clearMaybeInsertedClosing();
                        }
                    });
                    this.add("braces", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected === '{') {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.end.column, range.end.column + 1);
                            if (rightChar === '}') {
                                range.end.column++;
                                return range;
                            } else {
                                context.maybeInsertedBrackets--;
                            }
                        }
                    });
                    this.add("parens", "insertion", function (state, action, editor, session, text) {
                        if (text === '(') {
                            initContext(editor);
                            var selectionRange = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selectionRange);
                            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                                return { text: '(' + selected + ')', selection: void 0 };
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                                return { text: '()', selection: [1, 1] };
                            }
                        } else if (text === ')') {
                            initContext(editor);
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar === ')') {
                                var matching = session.findOpeningBracket(')', { column: cursor.column + 1, row: cursor.row });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return { text: '', selection: [1, 1] };
                                }
                            }
                        }
                    });
                    this.add("parens", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected === '(') {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar === ')') {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                    this.add("brackets", "insertion", function (state, action, editor, session, text) {
                        if (text === '[') {
                            initContext(editor);
                            var selectionRange = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selectionRange);
                            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                                return { text: '[' + selected + ']', selection: void 0 };
                            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                                return { text: '[]', selection: [1, 1] };
                            }
                        } else if (text === ']') {
                            initContext(editor);
                            var cursor = editor.getCursorPosition();
                            var line = session.doc.getLine(cursor.row);
                            var rightChar = line.substring(cursor.column, cursor.column + 1);
                            if (rightChar == ']') {
                                var matching = session.findOpeningBracket(']', { column: cursor.column + 1, row: cursor.row });
                                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                                    CstyleBehaviour.popAutoInsertedClosing();
                                    return { text: '', selection: [1, 1] };
                                }
                            }
                        }
                    });
                    this.add("brackets", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && selected === '[') {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar === ']') {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                    this.add("string_dquotes", "insertion", function (state, action, editor, session, text) {
                        if (text === '"' || text === "'") {
                            initContext(editor);
                            var quote = text;
                            var selection = editor.getSelectionRange();
                            var selected = session.doc.getTextRange(selection);
                            if (selected !== "" && selected !== "'" && selected !== '"' && editor.getWrapBehavioursEnabled()) {
                                return { text: quote + selected + quote, selection: void 0 };
                            } else {
                                var cursor = editor.getCursorPosition();
                                var line = session.doc.getLine(cursor.row);
                                var leftChar = line.substring(cursor.column - 1, cursor.column);
                                if (leftChar === '\\') {
                                    return null;
                                }
                                var tokens = session.getTokens(selection.start.row);
                                var col = 0;
                                var token;
                                var quotepos = -1;
                                for (var x = 0; x < tokens.length; x++) {
                                    token = tokens[x];
                                    if (token.type === "string") {
                                        quotepos = -1;
                                    } else if (quotepos < 0) {
                                        quotepos = token.value.indexOf(quote);
                                    }
                                    if (token.value.length + col > selection.start.column) {
                                        break;
                                    }
                                    col += tokens[x].value.length;
                                }
                                if (!token || quotepos < 0 && token.type !== "comment" && (token.type !== "string" || selection.start.column !== token.value.length + col - 1 && token.value.lastIndexOf(quote) === token.value.length - 1)) {
                                    if (!CstyleBehaviour.isSaneInsertion(editor, session)) return;
                                    return { text: quote + quote, selection: [1, 1] };
                                } else if (token && token.type === "string") {
                                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                                    if (rightChar == quote) {
                                        return { text: '', selection: [1, 1] };
                                    }
                                }
                            }
                        }
                    });
                    this.add("string_dquotes", "deletion", function (state, action, editor, session, range) {
                        var selected = session.doc.getTextRange(range);
                        if (!range.isMultiLine() && (selected === '"' || selected === "'")) {
                            initContext(editor);
                            var line = session.doc.getLine(range.start.row);
                            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                            if (rightChar == selected) {
                                range.end.column++;
                                return range;
                            }
                        }
                    });
                }

                _createClass(CstyleBehaviour, null, [{
                    key: "isSaneInsertion",
                    value: function isSaneInsertion(editor, session) {
                        var cursor = editor.getCursorPosition();
                        var iterator = new TokenIterator(session, cursor.row, cursor.column);
                        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
                            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
                                return false;
                            }
                        }
                        iterator.stepForward();
                        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
                    }
                }, {
                    key: "$matchTokenType",
                    value: function $matchTokenType(token, types) {
                        if (typeof token === 'string') {
                            return types.indexOf(token) > -1;
                        } else {
                            return types.indexOf(token.type) > -1;
                        }
                    }
                }, {
                    key: "recordAutoInsert",
                    value: function recordAutoInsert(editor, session, bracket) {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0])) {
                            context.autoInsertedBrackets = 0;
                        }
                        context.autoInsertedRow = cursor.row;
                        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
                        context.autoInsertedBrackets++;
                    }
                }, {
                    key: "recordMaybeInsert",
                    value: function recordMaybeInsert(editor, session, bracket) {
                        var cursor = editor.getCursorPosition();
                        var line = session.doc.getLine(cursor.row);
                        if (!this.isMaybeInsertedClosing(cursor, line)) {
                            context.maybeInsertedBrackets = 0;
                        }
                        context.maybeInsertedRow = cursor.row;
                        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
                        context.maybeInsertedLineEnd = line.substr(cursor.column);
                        context.maybeInsertedBrackets++;
                    }
                }, {
                    key: "isAutoInsertedClosing",
                    value: function isAutoInsertedClosing(cursor, line, bracket) {
                        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
                    }
                }, {
                    key: "isMaybeInsertedClosing",
                    value: function isMaybeInsertedClosing(cursor, line) {
                        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
                    }
                }, {
                    key: "popAutoInsertedClosing",
                    value: function popAutoInsertedClosing() {
                        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
                        context.autoInsertedBrackets--;
                    }
                }, {
                    key: "clearMaybeInsertedClosing",
                    value: function clearMaybeInsertedClosing() {
                        if (context) {
                            context.maybeInsertedBrackets = 0;
                            context.maybeInsertedRow = -1;
                        }
                    }
                }]);

                return CstyleBehaviour;
            })(Behaviour);

            _export("default", CstyleBehaviour);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-sap", ["npm:core-js@1.2.6/library/modules/$.export", "npm:core-js@1.2.6/library/modules/$.core", "npm:core-js@1.2.6/library/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core'),
      fails = $__require('npm:core-js@1.2.6/library/modules/$.fails');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor", ["npm:core-js@1.2.6/library/modules/$.to-iobject", "npm:core-js@1.2.6/library/modules/$.object-sap"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject');
  $__require('npm:core-js@1.2.6/library/modules/$.object-sap')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  $__require('npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/get-own-property-descriptor", ["npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/get", ["npm:babel-runtime@5.8.34/core-js/object/get-own-property-descriptor"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('npm:babel-runtime@5.8.34/core-js/object/get-own-property-descriptor')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/create", ["npm:core-js@1.2.6/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/create", ["npm:core-js@1.2.6/library/fn/object/create"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/create'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of", ["npm:core-js@1.2.6/library/modules/$.export", "npm:core-js@1.2.6/library/modules/$.set-proto"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export');
  $export($export.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.2.6/library/modules/$.set-proto').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/set-prototype-of", ["npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/set-prototype-of", ["npm:core-js@1.2.6/library/fn/object/set-prototype-of"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/set-prototype-of'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/inherits", ["npm:babel-runtime@5.8.34/core-js/object/create", "npm:babel-runtime@5.8.34/core-js/object/set-prototype-of"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('npm:babel-runtime@5.8.34/core-js/object/create')["default"];
  var _Object$setPrototypeOf = $__require('npm:babel-runtime@5.8.34/core-js/object/set-prototype-of')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("src/mode/folding/FoldMode.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, Range, FoldMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            FoldMode = (function () {
                function FoldMode() {
                    _classCallCheck(this, FoldMode);

                    this.foldingStartMarker = null;
                    this.foldingStopMarker = null;
                }

                _createClass(FoldMode, [{
                    key: "getFoldWidget",
                    value: function getFoldWidget(session, foldStyle, row) {
                        var line = session.getLine(row);
                        if (this.foldingStartMarker.test(line)) {
                            return "start";
                        }
                        if (foldStyle === "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) {
                            return "end";
                        }
                        return "";
                    }
                }, {
                    key: "getFoldWidgetRange",
                    value: function getFoldWidgetRange(session, foldStyle, row) {
                        return null;
                    }
                }, {
                    key: "indentationBlock",
                    value: function indentationBlock(session, row, column) {
                        var re = /\S/;
                        var line = session.getLine(row);
                        var startLevel = line.search(re);
                        if (startLevel === -1) {
                            return;
                        }
                        var startColumn = column || line.length;
                        var maxRow = session.getLength();
                        var startRow = row;
                        var endRow = row;
                        while (++row < maxRow) {
                            var level = session.getLine(row).search(re);
                            if (level === -1) {
                                continue;
                            }
                            if (level <= startLevel) {
                                break;
                            }
                            endRow = row;
                        }
                        if (endRow > startRow) {
                            var endColumn = session.getLine(endRow).length;
                            return new Range(startRow, startColumn, endRow, endColumn);
                        }
                    }
                }, {
                    key: "openingBracketBlock",
                    value: function openingBracketBlock(session, bracket, row, column, typeRe) {
                        var start = { row: row, column: column + 1 };
                        var end = session.findClosingBracket(bracket, start, typeRe);
                        if (!end) return;
                        var fw = session.foldWidgets[end.row];
                        if (fw == null) fw = session.getFoldWidget(end.row);
                        if (fw == "start" && end.row > start.row) {
                            end.row--;
                            end.column = session.getLine(end.row).length;
                        }
                        return Range.fromPoints(start, end);
                    }
                }, {
                    key: "closingBracketBlock",
                    value: function closingBracketBlock(session, bracket, row, column, typeRe) {
                        var end = { row: row, column: column };
                        var start = session.findOpeningBracket(bracket, end);
                        if (!start) {
                            return;
                        }
                        start.column++;
                        end.column--;
                        return Range.fromPoints(start, end);
                    }
                }]);

                return FoldMode;
            })();

            _export("default", FoldMode);
        }
    };
});
System.register("src/mode/folding/CstyleFoldMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/Range.js", "src/mode/folding/FoldMode.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Range, FoldMode, CstyleFoldMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcModeFoldingFoldModeJs) {
            FoldMode = _srcModeFoldingFoldModeJs["default"];
        }],
        execute: function () {
            "use strict";

            CstyleFoldMode = (function (_FoldMode) {
                _inherits(CstyleFoldMode, _FoldMode);

                function CstyleFoldMode(commentRegex) {
                    _classCallCheck(this, CstyleFoldMode);

                    _get(Object.getPrototypeOf(CstyleFoldMode.prototype), "constructor", this).call(this);
                    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
                    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;
                    if (commentRegex) {
                        this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start));
                        this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end));
                    }
                }

                _createClass(CstyleFoldMode, [{
                    key: "getFoldWidgetRange",
                    value: function getFoldWidgetRange(session, foldStyle, row, forceMultiline) {
                        var line = session.getLine(row);
                        var match = line.match(this.foldingStartMarker);
                        if (match) {
                            var i = match.index;
                            if (match[1]) return this.openingBracketBlock(session, match[1], row, i);
                            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
                            if (range && !range.isMultiLine()) {
                                if (forceMultiline) {
                                    range = this.getSectionRange(session, row);
                                } else if (foldStyle != "all") range = null;
                            }
                            return range;
                        }
                        if (foldStyle === "markbegin") return;
                        var match = line.match(this.foldingStopMarker);
                        if (match) {
                            var i = match.index + match[0].length;
                            if (match[1]) return this.closingBracketBlock(session, match[1], row, i);
                            return session.getCommentFoldRange(row, i, -1);
                        }
                    }
                }, {
                    key: "getSectionRange",
                    value: function getSectionRange(session, row) {
                        var line = session.getLine(row);
                        var startIndent = line.search(/\S/);
                        var startRow = row;
                        var startColumn = line.length;
                        row = row + 1;
                        var endRow = row;
                        var maxRow = session.getLength();
                        while (++row < maxRow) {
                            line = session.getLine(row);
                            var indent = line.search(/\S/);
                            if (indent === -1) continue;
                            if (startIndent > indent) break;
                            var subRange = this.getFoldWidgetRange(session, "all", row);
                            if (subRange) {
                                if (subRange.start.row <= startRow) {
                                    break;
                                } else if (subRange.isMultiLine()) {
                                    row = subRange.end.row;
                                } else if (startIndent == indent) {
                                    break;
                                }
                            }
                            endRow = row;
                        }
                        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
                    }
                }]);

                return CstyleFoldMode;
            })(FoldMode);

            _export("default", CstyleFoldMode);
        }
    };
});
System.register("src/Range.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, Range;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            Range = (function () {
                function Range(startRow, startColumn, endRow, endColumn) {
                    _classCallCheck(this, Range);

                    this.start = {
                        row: startRow,
                        column: startColumn
                    };
                    this.end = {
                        row: endRow,
                        column: endColumn
                    };
                }

                _createClass(Range, [{
                    key: "isEqual",
                    value: function isEqual(range) {
                        return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
                    }
                }, {
                    key: "contains",
                    value: function contains(row, column) {
                        return this.compare(row, column) === 0;
                    }
                }, {
                    key: "compareRange",
                    value: function compareRange(range) {
                        var cmp;
                        var end = range.end;
                        var start = range.start;
                        cmp = this.compare(end.row, end.column);
                        if (cmp === 1) {
                            cmp = this.compare(start.row, start.column);
                            if (cmp === 1) {
                                return 2;
                            } else if (cmp === 0) {
                                return 1;
                            } else {
                                return 0;
                            }
                        } else if (cmp === -1) {
                            return -2;
                        } else {
                            cmp = this.compare(start.row, start.column);
                            if (cmp === -1) {
                                return -1;
                            } else if (cmp === 1) {
                                return 42;
                            } else {
                                return 0;
                            }
                        }
                    }
                }, {
                    key: "comparePoint",
                    value: function comparePoint(point) {
                        return this.compare(point.row, point.column);
                    }
                }, {
                    key: "containsRange",
                    value: function containsRange(range) {
                        return this.comparePoint(range.start) === 0 && this.comparePoint(range.end) === 0;
                    }
                }, {
                    key: "intersects",
                    value: function intersects(range) {
                        var cmp = this.compareRange(range);
                        return cmp === -1 || cmp === 0 || cmp === 1;
                    }
                }, {
                    key: "isEnd",
                    value: function isEnd(row, column) {
                        return this.end.row === row && this.end.column === column;
                    }
                }, {
                    key: "isStart",
                    value: function isStart(row, column) {
                        return this.start.row === row && this.start.column === column;
                    }
                }, {
                    key: "setStart",
                    value: function setStart(row, column) {
                        this.start.row = row;
                        this.start.column = column;
                    }
                }, {
                    key: "setEnd",
                    value: function setEnd(row, column) {
                        this.end.row = row;
                        this.end.column = column;
                    }
                }, {
                    key: "inside",
                    value: function inside(row, column) {
                        if (this.compare(row, column) === 0) {
                            if (this.isEnd(row, column) || this.isStart(row, column)) {
                                return false;
                            } else {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "insideStart",
                    value: function insideStart(row, column) {
                        if (this.compare(row, column) === 0) {
                            if (this.isEnd(row, column)) {
                                return false;
                            } else {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "insideEnd",
                    value: function insideEnd(row, column) {
                        if (this.compare(row, column) === 0) {
                            if (this.isStart(row, column)) {
                                return false;
                            } else {
                                return true;
                            }
                        }
                        return false;
                    }
                }, {
                    key: "compare",
                    value: function compare(row, column) {
                        if (!this.isMultiLine()) {
                            if (row === this.start.row) {
                                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
                            }
                        }
                        if (row < this.start.row) return -1;
                        if (row > this.end.row) return 1;
                        if (this.start.row === row) return column >= this.start.column ? 0 : -1;
                        if (this.end.row === row) return column <= this.end.column ? 0 : 1;
                        return 0;
                    }
                }, {
                    key: "compareStart",
                    value: function compareStart(row, column) {
                        if (this.start.row === row && this.start.column === column) {
                            return -1;
                        } else {
                            return this.compare(row, column);
                        }
                    }
                }, {
                    key: "compareEnd",
                    value: function compareEnd(row, column) {
                        if (this.end.row === row && this.end.column === column) {
                            return 1;
                        } else {
                            return this.compare(row, column);
                        }
                    }
                }, {
                    key: "compareInside",
                    value: function compareInside(row, column) {
                        if (this.end.row === row && this.end.column === column) {
                            return 1;
                        } else if (this.start.row === row && this.start.column === column) {
                            return -1;
                        } else {
                            return this.compare(row, column);
                        }
                    }
                }, {
                    key: "clipRows",
                    value: function clipRows(firstRow, lastRow) {
                        var start;
                        var end;
                        if (this.end.row > lastRow) end = { row: lastRow + 1, column: 0 };else if (this.end.row < firstRow) end = { row: firstRow, column: 0 };
                        if (this.start.row > lastRow) start = { row: lastRow + 1, column: 0 };else if (this.start.row < firstRow) start = { row: firstRow, column: 0 };
                        return Range.fromPoints(start || this.start, end || this.end);
                    }
                }, {
                    key: "extend",
                    value: function extend(row, column) {
                        var cmp = this.compare(row, column);
                        if (cmp === 0) {
                            return this;
                        } else if (cmp === -1) {
                            var start = { row: row, column: column };
                        } else {
                            var end = { row: row, column: column };
                        }
                        return Range.fromPoints(start || this.start, end || this.end);
                    }
                }, {
                    key: "isEmpty",
                    value: function isEmpty() {
                        return this.start.row === this.end.row && this.start.column === this.end.column;
                    }
                }, {
                    key: "isMultiLine",
                    value: function isMultiLine() {
                        return this.start.row !== this.end.row;
                    }
                }, {
                    key: "clone",
                    value: function clone() {
                        return Range.fromPoints(this.start, this.end);
                    }
                }, {
                    key: "collapseRows",
                    value: function collapseRows() {
                        if (this.end.column === 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);else return new Range(this.start.row, 0, this.end.row, 0);
                    }
                }, {
                    key: "moveBy",
                    value: function moveBy(row, column) {
                        this.start.row += row;
                        this.start.column += column;
                        this.end.row += row;
                        this.end.column += column;
                    }
                }], [{
                    key: "fromPoints",
                    value: function fromPoints(start, end) {
                        return new Range(start.row, start.column, end.row, end.column);
                    }
                }, {
                    key: "comparePoints",
                    value: function comparePoints(p1, p2) {
                        return p1.row - p2.row || p1.column - p2.column;
                    }
                }]);

                return Range;
            })();

            _export("default", Range);
        }
    };
});
System.register("src/mode/MatchingBraceOutdent.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "src/Range.js"], function (_export) {
    var _createClass, _classCallCheck, Range, MatchingBraceOutdent;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }],
        execute: function () {
            "use strict";

            MatchingBraceOutdent = (function () {
                function MatchingBraceOutdent() {
                    _classCallCheck(this, MatchingBraceOutdent);
                }

                _createClass(MatchingBraceOutdent, [{
                    key: "checkOutdent",
                    value: function checkOutdent(line, text) {
                        if (!/^\s+$/.test(line)) {
                            return false;
                        }
                        return (/^\s*\}/.test(text)
                        );
                    }
                }, {
                    key: "autoOutdent",
                    value: function autoOutdent(session, row) {
                        var line = session.getLine(row);
                        var match = line.match(/^(\s*\})/);
                        if (!match) return 0;
                        var column = match[1].length;
                        var openBracePos = session.findMatchingBracket({ row: row, column: column });
                        if (!openBracePos || openBracePos.row == row) return 0;
                        var indent = this.$getIndent(session.getLine(openBracePos.row));
                        session.replace(new Range(row, 0, row, column - 1), indent);
                    }
                }, {
                    key: "$getIndent",
                    value: function $getIndent(line) {
                        return line.match(/^\s*/)[0];
                    }
                }]);

                return MatchingBraceOutdent;
            })();

            _export("default", MatchingBraceOutdent);
        }
    };
});
System.register("src/mode/TypeScriptMode.js", ["npm:babel-runtime@5.8.34/helpers/get", "npm:babel-runtime@5.8.34/helpers/inherits", "npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check", "npm:babel-runtime@5.8.34/core-js/promise", "src/mode/JavaScriptMode.js", "src/mode/TypeScriptHighlightRules.js", "src/mode/behaviour/CstyleBehaviour.js", "src/mode/folding/CstyleFoldMode.js", "src/mode/MatchingBraceOutdent.js", "src/worker/WorkerClient.js"], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, _Promise, JavaScriptMode, TypeScriptHighlightRules, CstyleBehaviour, CStyleFoldMode, MatchingBraceOutdent, WorkerClient, TypeScriptMode;

    return {
        setters: [function (_npmBabelRuntime5834HelpersGet) {
            _get = _npmBabelRuntime5834HelpersGet["default"];
        }, function (_npmBabelRuntime5834HelpersInherits) {
            _inherits = _npmBabelRuntime5834HelpersInherits["default"];
        }, function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise["default"];
        }, function (_srcModeJavaScriptModeJs) {
            JavaScriptMode = _srcModeJavaScriptModeJs["default"];
        }, function (_srcModeTypeScriptHighlightRulesJs) {
            TypeScriptHighlightRules = _srcModeTypeScriptHighlightRulesJs["default"];
        }, function (_srcModeBehaviourCstyleBehaviourJs) {
            CstyleBehaviour = _srcModeBehaviourCstyleBehaviourJs["default"];
        }, function (_srcModeFoldingCstyleFoldModeJs) {
            CStyleFoldMode = _srcModeFoldingCstyleFoldModeJs["default"];
        }, function (_srcModeMatchingBraceOutdentJs) {
            MatchingBraceOutdent = _srcModeMatchingBraceOutdentJs["default"];
        }, function (_srcWorkerWorkerClientJs) {
            WorkerClient = _srcWorkerWorkerClientJs["default"];
        }],
        execute: function () {
            "use strict";

            TypeScriptMode = (function (_JavaScriptMode) {
                _inherits(TypeScriptMode, _JavaScriptMode);

                function TypeScriptMode(workerUrl, scriptImports) {
                    _classCallCheck(this, TypeScriptMode);

                    _get(Object.getPrototypeOf(TypeScriptMode.prototype), "constructor", this).call(this, workerUrl, scriptImports);
                    this.$id = "ace/mode/typescript";
                    this.HighlightRules = TypeScriptHighlightRules;
                    this.$outdent = new MatchingBraceOutdent();
                    this.$behaviour = new CstyleBehaviour();
                    this.foldingRules = new CStyleFoldMode();
                }

                _createClass(TypeScriptMode, [{
                    key: "createWorker",
                    value: function createWorker(session) {
                        var workerUrl = this.workerUrl;
                        var scriptImports = this.scriptImports;
                        return new _Promise(function (resolve, reject) {
                            var worker = new WorkerClient(workerUrl);
                            worker.on("initAfter", function (event) {
                                worker.attachToDocument(session.getDocument());
                                resolve(worker);
                            });
                            worker.on("initFail", function (message) {
                                reject(new Error("" + message));
                            });
                            worker.on("terminate", function () {
                                worker.detachFromDocument();
                                session.clearAnnotations();
                            });
                            worker.on("compileErrors", function (event) {
                                session.setAnnotations(event.data);
                                session._emit("compileErrors", { data: event.data });
                            });
                            worker.on("compiled", function (event) {
                                session._emit("compiled", { data: event.data });
                            });
                            worker.on("getFileNames", function (event) {
                                session._emit("getFileNames", { data: event.data });
                            });
                            worker.init(scriptImports, 'ace-workers.js', 'TypeScriptWorker');
                        });
                    }
                }]);

                return TypeScriptMode;
            })(JavaScriptMode);

            _export("default", TypeScriptMode);
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.to-string", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.string-at", ["npm:core-js@1.2.6/library/modules/$.to-integer", "npm:core-js@1.2.6/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.string.iterator", ["npm:core-js@1.2.6/library/modules/$.string-at", "npm:core-js@1.2.6/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.2.6/library/modules/$.string-at')(true);
  $__require('npm:core-js@1.2.6/library/modules/$.iter-define')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.add-to-unscopables", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-step", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject", ["npm:core-js@1.2.6/library/modules/$.cof"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject", ["npm:core-js@1.2.6/library/modules/$.iobject", "npm:core-js@1.2.6/library/modules/$.defined"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-create", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.property-desc", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag", "npm:core-js@1.2.6/library/modules/$.hide", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$'),
      descriptor = $__require('npm:core-js@1.2.6/library/modules/$.property-desc'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.6/library/modules/$.hide')(IteratorPrototype, $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-define", ["npm:core-js@1.2.6/library/modules/$.library", "npm:core-js@1.2.6/library/modules/$.export", "npm:core-js@1.2.6/library/modules/$.redefine", "npm:core-js@1.2.6/library/modules/$.hide", "npm:core-js@1.2.6/library/modules/$.has", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.iter-create", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag", "npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export'),
      redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide'),
      has = $__require('npm:core-js@1.2.6/library/modules/$.has'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators'),
      $iterCreate = $__require('npm:core-js@1.2.6/library/modules/$.iter-create'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag'),
      getProto = $__require('npm:core-js@1.2.6/library/modules/$').getProto,
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.array.iterator", ["npm:core-js@1.2.6/library/modules/$.add-to-unscopables", "npm:core-js@1.2.6/library/modules/$.iter-step", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.to-iobject", "npm:core-js@1.2.6/library/modules/$.iter-define"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('npm:core-js@1.2.6/library/modules/$.add-to-unscopables'),
      step = $__require('npm:core-js@1.2.6/library/modules/$.iter-step'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators'),
      toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.iter-define')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/web.dom.iterable", ["npm:core-js@1.2.6/library/modules/es6.array.iterator", "npm:core-js@1.2.6/library/modules/$.iterators"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.array.iterator');
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.library", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export", ["npm:core-js@1.2.6/library/modules/$.global", "npm:core-js@1.2.6/library/modules/$.core", "npm:core-js@1.2.6/library/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.strict-new", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-call", ["npm:core-js@1.2.6/library/modules/$.an-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-array-iter", ["npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-integer", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-length", ["npm:core-js@1.2.6/library/modules/$.to-integer"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.classof", ["npm:core-js@1.2.6/library/modules/$.cof", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iterators", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator-method", ["npm:core-js@1.2.6/library/modules/$.classof", "npm:core-js@1.2.6/library/modules/$.wks", "npm:core-js@1.2.6/library/modules/$.iterators", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.for-of", ["npm:core-js@1.2.6/library/modules/$.ctx", "npm:core-js@1.2.6/library/modules/$.iter-call", "npm:core-js@1.2.6/library/modules/$.is-array-iter", "npm:core-js@1.2.6/library/modules/$.an-object", "npm:core-js@1.2.6/library/modules/$.to-length", "npm:core-js@1.2.6/library/modules/core.get-iterator-method"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx'),
      call = $__require('npm:core-js@1.2.6/library/modules/$.iter-call'),
      isArrayIter = $__require('npm:core-js@1.2.6/library/modules/$.is-array-iter'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object'),
      toLength = $__require('npm:core-js@1.2.6/library/modules/$.to-length'),
      getIterFn = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-proto", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.is-object", "npm:core-js@1.2.6/library/modules/$.an-object", "npm:core-js@1.2.6/library/modules/$.ctx"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.2.6/library/modules/$').getDesc,
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.6/library/modules/$.ctx')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.same-value", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.an-object", ["npm:core-js@1.2.6/library/modules/$.is-object"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.species-constructor", ["npm:core-js@1.2.6/library/modules/$.an-object", "npm:core-js@1.2.6/library/modules/$.a-function", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object'),
      aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx", ["npm:core-js@1.2.6/library/modules/$.a-function"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.invoke", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.html", ["npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.global').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.dom-create", ["npm:core-js@1.2.6/library/modules/$.is-object", "npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object'),
      document = $__require('npm:core-js@1.2.6/library/modules/$.global').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.task", ["npm:core-js@1.2.6/library/modules/$.ctx", "npm:core-js@1.2.6/library/modules/$.invoke", "npm:core-js@1.2.6/library/modules/$.html", "npm:core-js@1.2.6/library/modules/$.dom-create", "npm:core-js@1.2.6/library/modules/$.global", "npm:core-js@1.2.6/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx'),
        invoke = $__require('npm:core-js@1.2.6/library/modules/$.invoke'),
        html = $__require('npm:core-js@1.2.6/library/modules/$.html'),
        cel = $__require('npm:core-js@1.2.6/library/modules/$.dom-create'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.2.6/library/modules/$.cof')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.microtask", ["npm:core-js@1.2.6/library/modules/$.global", "npm:core-js@1.2.6/library/modules/$.task", "npm:core-js@1.2.6/library/modules/$.cof", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
        macrotask = $__require('npm:core-js@1.2.6/library/modules/$.task').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('npm:core-js@1.2.6/library/modules/$.cof')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.property-desc", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.hide", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.property-desc", "npm:core-js@1.2.6/library/modules/$.descriptors"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$'),
      createDesc = $__require('npm:core-js@1.2.6/library/modules/$.property-desc');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.descriptors') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine", ["npm:core-js@1.2.6/library/modules/$.hide"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.hide');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine-all", ["npm:core-js@1.2.6/library/modules/$.redefine"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.has", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-to-string-tag", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.has", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('npm:core-js@1.2.6/library/modules/$').setDesc,
      has = $__require('npm:core-js@1.2.6/library/modules/$.has'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.descriptors", ["npm:core-js@1.2.6/library/modules/$.fails"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.2.6/library/modules/$.fails')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-species", ["npm:core-js@1.2.6/library/modules/$.core", "npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.descriptors", "npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = $__require('npm:core-js@1.2.6/library/modules/$.core'),
      $ = $__require('npm:core-js@1.2.6/library/modules/$'),
      DESCRIPTORS = $__require('npm:core-js@1.2.6/library/modules/$.descriptors'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.shared", ["npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.uid", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.wks", ["npm:core-js@1.2.6/library/modules/$.shared", "npm:core-js@1.2.6/library/modules/$.uid", "npm:core-js@1.2.6/library/modules/$.global"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.2.6/library/modules/$.shared')('wks'),
      uid = $__require('npm:core-js@1.2.6/library/modules/$.uid'),
      Symbol = $__require('npm:core-js@1.2.6/library/modules/$.global').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-detect", ["npm:core-js@1.2.6/library/modules/$.wks"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.promise", ["npm:core-js@1.2.6/library/modules/$", "npm:core-js@1.2.6/library/modules/$.library", "npm:core-js@1.2.6/library/modules/$.global", "npm:core-js@1.2.6/library/modules/$.ctx", "npm:core-js@1.2.6/library/modules/$.classof", "npm:core-js@1.2.6/library/modules/$.export", "npm:core-js@1.2.6/library/modules/$.is-object", "npm:core-js@1.2.6/library/modules/$.an-object", "npm:core-js@1.2.6/library/modules/$.a-function", "npm:core-js@1.2.6/library/modules/$.strict-new", "npm:core-js@1.2.6/library/modules/$.for-of", "npm:core-js@1.2.6/library/modules/$.set-proto", "npm:core-js@1.2.6/library/modules/$.same-value", "npm:core-js@1.2.6/library/modules/$.wks", "npm:core-js@1.2.6/library/modules/$.species-constructor", "npm:core-js@1.2.6/library/modules/$.microtask", "npm:core-js@1.2.6/library/modules/$.descriptors", "npm:core-js@1.2.6/library/modules/$.redefine-all", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag", "npm:core-js@1.2.6/library/modules/$.set-species", "npm:core-js@1.2.6/library/modules/$.core", "npm:core-js@1.2.6/library/modules/$.iter-detect", "github:jspm/nodelibs-process@0.1.2"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.2.6/library/modules/$'),
        LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global'),
        ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx'),
        classof = $__require('npm:core-js@1.2.6/library/modules/$.classof'),
        $export = $__require('npm:core-js@1.2.6/library/modules/$.export'),
        isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object'),
        anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object'),
        aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function'),
        strictNew = $__require('npm:core-js@1.2.6/library/modules/$.strict-new'),
        forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of'),
        setProto = $__require('npm:core-js@1.2.6/library/modules/$.set-proto').set,
        same = $__require('npm:core-js@1.2.6/library/modules/$.same-value'),
        SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks')('species'),
        speciesConstructor = $__require('npm:core-js@1.2.6/library/modules/$.species-constructor'),
        asap = $__require('npm:core-js@1.2.6/library/modules/$.microtask'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.2.6/library/modules/$.descriptors')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.2.6/library/modules/$.redefine-all')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag')(P, PROMISE);
    $__require('npm:core-js@1.2.6/library/modules/$.set-species')(PROMISE);
    Wrapper = $__require('npm:core-js@1.2.6/library/modules/$.core')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('npm:core-js@1.2.6/library/modules/$.iter-detect')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/promise", ["npm:core-js@1.2.6/library/modules/es6.object.to-string", "npm:core-js@1.2.6/library/modules/es6.string.iterator", "npm:core-js@1.2.6/library/modules/web.dom.iterable", "npm:core-js@1.2.6/library/modules/es6.promise", "npm:core-js@1.2.6/library/modules/$.core"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.to-string');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator');
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable');
  $__require('npm:core-js@1.2.6/library/modules/es6.promise');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core').Promise;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/promise", ["npm:core-js@1.2.6/library/fn/promise"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/promise'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register("src/lib/dom.js", [], function (_export) {
    "use strict";

    var XHTML_NS, computedStyle, getInnerText, setInnerText;

    _export("getDocumentHead", getDocumentHead);

    _export("getDocumentBody", getDocumentBody);

    _export("createElement", createElement);

    _export("hasCssClass", hasCssClass);

    _export("addCssClass", addCssClass);

    _export("removeCssClass", removeCssClass);

    _export("toggleCssClass", toggleCssClass);

    _export("setCssClass", setCssClass);

    _export("hasCssString", hasCssString);

    _export("ensureHTMLStyleElement", ensureHTMLStyleElement);

    _export("appendHTMLLinkElement", appendHTMLLinkElement);

    _export("scrollbarWidth", scrollbarWidth);

    _export("setInnerHtml", setInnerHtml);

    _export("getParentWindow", getParentWindow);

    function getDocumentHead() {
        var doc = arguments.length <= 0 || arguments[0] === undefined ? document : arguments[0];

        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    }

    function getDocumentBody() {
        var doc = arguments.length <= 0 || arguments[0] === undefined ? document : arguments[0];

        return doc.body || doc.getElementsByTagName("body")[0];
    }

    function createElement(tagName, namespaceURI) {
        return document.createElementNS ? document.createElementNS(namespaceURI || XHTML_NS, tagName) : document.createElement(tagName);
    }

    function hasCssClass(element, name) {
        var classes = element.className.split(/\s+/g);
        return classes.indexOf(name) !== -1;
    }

    function addCssClass(element, name) {
        if (!hasCssClass(element, name)) {
            element.className += " " + name;
        }
    }

    function removeCssClass(element, name) {
        var classes = element.className.split(/\s+/g);
        while (true) {
            var index = classes.indexOf(name);
            if (index === -1) {
                break;
            }
            classes.splice(index, 1);
        }
        element.className = classes.join(" ");
    }

    function toggleCssClass(element, name) {
        var classes = element.className.split(/\s+/g);
        var add = true;
        while (true) {
            var index = classes.indexOf(name);
            if (index == -1) {
                break;
            }
            add = false;
            classes.splice(index, 1);
        }
        if (add) classes.push(name);
        element.className = classes.join(" ");
        return add;
    }

    function setCssClass(node, className, include) {
        if (include) {
            addCssClass(node, className);
        } else {
            removeCssClass(node, className);
        }
    }

    function hasCssString(id) {
        var doc = arguments.length <= 1 || arguments[1] === undefined ? document : arguments[1];

        var index = 0;
        var sheets = doc.getElementsByTagName('style');
        if (sheets) {
            while (index < sheets.length) {
                if (sheets[index++].id === id) {
                    return true;
                }
            }
        }
        return false;
    }

    function ensureHTMLStyleElement(cssText, id) {
        var doc = arguments.length <= 2 || arguments[2] === undefined ? document : arguments[2];

        if (id && hasCssString(id, doc)) {
            return;
        } else {
            var style = createElement('style');
            style.appendChild(doc.createTextNode(cssText));
            if (id) {
                style.id = id;
            }
            getDocumentHead(doc).appendChild(style);
        }
    }

    function appendHTMLLinkElement(id, rel, type, href) {
        var doc = arguments.length <= 4 || arguments[4] === undefined ? document : arguments[4];

        var link = createElement('link');
        link.id = id;
        link.rel = rel;
        if (typeof type === 'string') {
            link.type = type;
        }
        link.href = href;
        getDocumentHead(doc).appendChild(link);
    }

    function makeComputedStyle() {
        if (window.getComputedStyle) {
            return function (element, style) {
                return (window.getComputedStyle(element, "") || {})[style] || "";
            };
        } else {
            return function (element, style) {
                if (style) {
                    return element['currentStyle'][style];
                }
                return element['currentStyle'];
            };
        }
    }

    function scrollbarWidth(document) {
        var inner = createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = document.documentElement;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
            withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
    }

    function setInnerHtml(element, innerHTML) {
        var clonedElement = element.cloneNode(false);
        clonedElement.innerHTML = innerHTML;
        element.parentNode.replaceChild(clonedElement, element);
        return clonedElement;
    }

    function makeGetInnerText() {
        if ("textContent" in document.documentElement) {
            return function (el) {
                return el.textContent;
            };
        } else {
            return function (el) {
                return el.innerText;
            };
        }
    }
    function makeSetInnerText() {
        if ("textContent" in document.documentElement) {
            return function (el, innerText) {
                el.textContent = innerText;
            };
        } else {
            return function (el, innerText) {
                el.innerText = innerText;
            };
        }
    }

    function getParentWindow(document) {
        return document.defaultView;
    }

    return {
        setters: [],
        execute: function () {
            XHTML_NS = "http://www.w3.org/1999/xhtml";
            computedStyle = makeComputedStyle();

            _export("computedStyle", computedStyle);

            getInnerText = makeGetInnerText();

            _export("getInnerText", getInnerText);

            setInnerText = makeSetInnerText();

            _export("setInnerText", setInnerText);
        }
    };
});
System.register('src/lib/net.js', ['src/lib/dom.js'], function (_export) {
    'use strict';

    var getDocumentHead;

    _export('get', get);

    _export('loadScript', loadScript);

    _export('qualifyURL', qualifyURL);

    function get(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                callback(xhr.responseText);
            }
        };
        xhr.send(null);
    }

    function loadScript(src, callback, doc) {
        var head = getDocumentHead();
        var s = doc.createElement('script');
        s.src = src;
        head.appendChild(s);
        s.onload = s['onreadystatechange'] = function (_, isAbort) {
            if (isAbort || !s['readyState'] || s['readyState'] === "loaded" || s['readyState'] === "complete") {
                s = s.onload = s['onreadystatechange'] = null;
                if (!isAbort) {
                    callback();
                }
            }
        };
    }

    function qualifyURL(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
    }

    return {
        setters: [function (_srcLibDomJs) {
            getDocumentHead = _srcLibDomJs.getDocumentHead;
        }],
        execute: function () {
            ;
        }
    };
});
System.registerDynamic("npm:core-js@1.2.6/library/modules/$", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/define-property", ["npm:core-js@1.2.6/library/modules/$"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/core-js/object/define-property", ["npm:core-js@1.2.6/library/fn/object/define-property"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/define-property'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/create-class", ["npm:babel-runtime@5.8.34/core-js/object/define-property"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.34/core-js/object/define-property')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.34/helpers/class-call-check", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.register("src/lib/EventEmitterClass.js", ["npm:babel-runtime@5.8.34/helpers/create-class", "npm:babel-runtime@5.8.34/helpers/class-call-check"], function (_export) {
    var _createClass, _classCallCheck, stopPropagation, preventDefault, EventEmitterClass;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass["default"];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck["default"];
        }],
        execute: function () {
            "use strict";

            stopPropagation = function stopPropagation() {
                this.propagationStopped = true;
            };

            preventDefault = function preventDefault() {
                this.defaultPrevented = true;
            };

            EventEmitterClass = (function () {
                function EventEmitterClass(owner) {
                    _classCallCheck(this, EventEmitterClass);

                    this.owner = owner;
                }

                _createClass(EventEmitterClass, [{
                    key: "_dispatchEvent",
                    value: function _dispatchEvent(eventName, event) {
                        this._eventRegistry || (this._eventRegistry = {});
                        this._defaultHandlers || (this._defaultHandlers = {});
                        var listeners = this._eventRegistry[eventName] || [];
                        var defaultHandler = this._defaultHandlers[eventName];
                        if (!listeners.length && !defaultHandler) return;
                        if (typeof event !== "object" || !event) {
                            event = {};
                        }
                        if (!event.type) {
                            event.type = eventName;
                        }
                        if (!event.stopPropagation) {
                            event.stopPropagation = stopPropagation;
                        }
                        if (!event.preventDefault) {
                            event.preventDefault = preventDefault;
                        }
                        listeners = listeners.slice();
                        for (var i = 0; i < listeners.length; i++) {
                            listeners[i](event, this.owner);
                            if (event['propagationStopped']) {
                                break;
                            }
                        }
                        if (defaultHandler && !event.defaultPrevented) {
                            return defaultHandler(event, this.owner);
                        }
                    }
                }, {
                    key: "hasListeners",
                    value: function hasListeners(eventName) {
                        var registry = this._eventRegistry;
                        var listeners = registry && registry[eventName];
                        return listeners && listeners.length > 0;
                    }
                }, {
                    key: "_emit",
                    value: function _emit(eventName, event) {
                        return this._dispatchEvent(eventName, event);
                    }
                }, {
                    key: "_signal",
                    value: function _signal(eventName, e) {
                        var listeners = (this._eventRegistry || {})[eventName];
                        if (!listeners) {
                            return;
                        }
                        listeners = listeners.slice();
                        for (var i = 0, iLength = listeners.length; i < iLength; i++) {
                            listeners[i](e, this.owner);
                        }
                    }
                }, {
                    key: "once",
                    value: function once(eventName, callback) {
                        var _self = this;
                        callback && this.addEventListener(eventName, function newCallback() {
                            _self.removeEventListener(eventName, newCallback);
                            callback.apply(null, arguments);
                        });
                    }
                }, {
                    key: "setDefaultHandler",
                    value: function setDefaultHandler(eventName, callback) {
                        var handlers = this._defaultHandlers;
                        if (!handlers) {
                            handlers = this._defaultHandlers = { _disabled_: {} };
                        }
                        if (handlers[eventName]) {
                            var old = handlers[eventName];
                            var disabled = handlers._disabled_[eventName];
                            if (!disabled) handlers._disabled_[eventName] = disabled = [];
                            disabled.push(old);
                            var i = disabled.indexOf(callback);
                            if (i != -1) disabled.splice(i, 1);
                        }
                        handlers[eventName] = callback;
                    }
                }, {
                    key: "removeDefaultHandler",
                    value: function removeDefaultHandler(eventName, callback) {
                        var handlers = this._defaultHandlers;
                        if (!handlers) {
                            return;
                        }
                        var disabled = handlers._disabled_[eventName];
                        if (handlers[eventName] === callback) {
                            var old = handlers[eventName];
                            if (disabled) this.setDefaultHandler(eventName, disabled.pop());
                        } else if (disabled) {
                            var i = disabled.indexOf(callback);
                            if (i != -1) disabled.splice(i, 1);
                        }
                    }
                }, {
                    key: "addEventListener",
                    value: function addEventListener(eventName, callback, capturing) {
                        this._eventRegistry = this._eventRegistry || {};
                        var listeners = this._eventRegistry[eventName];
                        if (!listeners) {
                            listeners = this._eventRegistry[eventName] = [];
                        }
                        if (listeners.indexOf(callback) === -1) {
                            if (capturing) {
                                listeners.unshift(callback);
                            } else {
                                listeners.push(callback);
                            }
                        }
                        return callback;
                    }
                }, {
                    key: "on",
                    value: function on(eventName, callback, capturing) {
                        this.addEventListener(eventName, callback, capturing);
                    }
                }, {
                    key: "removeEventListener",
                    value: function removeEventListener(eventName, callback) {
                        this._eventRegistry = this._eventRegistry || {};
                        var listeners = this._eventRegistry[eventName];
                        if (!listeners) return;
                        var index = listeners.indexOf(callback);
                        if (index !== -1) {
                            listeners.splice(index, 1);
                        }
                    }
                }, {
                    key: "removeListener",
                    value: function removeListener(eventName, callback) {
                        return this.removeEventListener(eventName, callback);
                    }
                }, {
                    key: "off",
                    value: function off(eventName, callback) {
                        return this.removeEventListener(eventName, callback);
                    }
                }, {
                    key: "removeAllListeners",
                    value: function removeAllListeners(eventName) {
                        if (this._eventRegistry) this._eventRegistry[eventName] = [];
                    }
                }]);

                return EventEmitterClass;
            })();

            _export("default", EventEmitterClass);
        }
    };
});
System.register('src/worker/WorkerClient.js', ['npm:babel-runtime@5.8.34/helpers/create-class', 'npm:babel-runtime@5.8.34/helpers/class-call-check', 'npm:babel-runtime@5.8.34/core-js/promise', 'src/lib/net.js', 'src/lib/EventEmitterClass.js'], function (_export) {
    var _createClass, _classCallCheck, _Promise, qualifyURL, EventEmitterClass, WorkerClient;

    return {
        setters: [function (_npmBabelRuntime5834HelpersCreateClass) {
            _createClass = _npmBabelRuntime5834HelpersCreateClass['default'];
        }, function (_npmBabelRuntime5834HelpersClassCallCheck) {
            _classCallCheck = _npmBabelRuntime5834HelpersClassCallCheck['default'];
        }, function (_npmBabelRuntime5834CoreJsPromise) {
            _Promise = _npmBabelRuntime5834CoreJsPromise['default'];
        }, function (_srcLibNetJs) {
            qualifyURL = _srcLibNetJs.qualifyURL;
        }, function (_srcLibEventEmitterClassJs) {
            EventEmitterClass = _srcLibEventEmitterClassJs['default'];
        }],
        execute: function () {
            "use strict";

            WorkerClient = (function () {
                function WorkerClient(workerUrl) {
                    _classCallCheck(this, WorkerClient);

                    this.callbacks = {};
                    this.callbackId = 1;
                    this.eventBus = new EventEmitterClass(this);
                    this.sendDeltaQueue = this.sendDeltaQueue.bind(this);
                    this.changeListener = this.changeListener.bind(this);
                    this.onMessage = this.onMessage.bind(this);
                    var workerUrl = qualifyURL(workerUrl);
                    try {
                        this.$worker = new Worker(workerUrl);
                    } catch (e) {
                        if (e instanceof window['DOMException']) {
                            var blob = this.$workerBlob(workerUrl);
                            var URL = window['URL'] || window['webkitURL'];
                            var blobURL = URL.createObjectURL(blob);
                            this.$worker = new Worker(blobURL);
                            URL.revokeObjectURL(blobURL);
                        } else {
                            throw e;
                        }
                    }
                    this.$worker.onmessage = this.onMessage;
                }

                _createClass(WorkerClient, [{
                    key: 'init',
                    value: function init(scriptImports, moduleName, className) {
                        this.$worker.postMessage({
                            init: true,
                            scriptImports: scriptImports,
                            moduleName: moduleName,
                            className: className
                        });
                    }
                }, {
                    key: 'onMessage',
                    value: function onMessage(event) {
                        var origin = event.origin;
                        var source = event.source;
                        var msg = event.data;
                        switch (msg.type) {
                            case "log":
                                window.console && console.log && console.log.apply(console, msg.data);
                                break;
                            case "event":
                                this.eventBus._signal(msg.name, { data: msg.data });
                                break;
                            case "call":
                                var callback = this.callbacks[msg.id];
                                if (callback) {
                                    callback(msg.data);
                                    delete this.callbacks[msg.id];
                                }
                                break;
                        }
                    }
                }, {
                    key: '$normalizePath',
                    value: function $normalizePath(path) {
                        return qualifyURL(path);
                    }
                }, {
                    key: 'terminate',
                    value: function terminate() {
                        this.eventBus._signal("terminate", {});
                        this.deltaQueue = void 0;
                        this.$worker.terminate();
                        this.$worker = void 0;
                    }
                }, {
                    key: 'send',
                    value: function send(cmd, args) {
                        this.$worker.postMessage({ command: cmd, args: args });
                    }
                }, {
                    key: 'call',
                    value: function call(cmd, args, callback) {
                        if (callback) {
                            var id = this.callbackId++;
                            this.callbacks[id] = callback;
                            args.push(id);
                        }
                        this.send(cmd, args);
                    }
                }, {
                    key: 'invoke',
                    value: function invoke(cmd, args) {
                        var workerClient = this;
                        return new _Promise(function (resolve, reject) {
                            workerClient.call(cmd, args, function (retval) {
                                if (retval.err) {
                                    reject(retval.err);
                                } else {
                                    resolve(retval.data);
                                }
                            });
                        });
                    }
                }, {
                    key: 'emit',
                    value: function emit(event, data) {
                        try {
                            this.$worker.postMessage({ event: event, data: { data: data.data } });
                        } catch (e) {
                            console.error(e.stack);
                        }
                    }
                }, {
                    key: 'attachToDocument',
                    value: function attachToDocument(doc) {
                        if (this.$doc) {
                            if (this.$doc === doc) {
                                return;
                            } else {
                                this.$doc.off('change', this.changeListener);
                            }
                        }
                        this.$doc = doc;
                        this.call("setValue", [doc.getValue()]);
                        doc.on('change', this.changeListener);
                    }
                }, {
                    key: 'detachFromDocument',
                    value: function detachFromDocument() {
                        if (this.$doc) {
                            this.$doc.off('change', this.changeListener);
                            this.$doc = null;
                        }
                    }
                }, {
                    key: 'changeListener',
                    value: function changeListener(e, doc) {
                        if (!this.deltaQueue) {
                            this.deltaQueue = [e.data];
                            setTimeout(this.sendDeltaQueue, 0);
                        } else {
                            this.deltaQueue.push(e.data);
                        }
                    }
                }, {
                    key: 'on',
                    value: function on(eventName, callback) {
                        this.eventBus.on(eventName, callback, false);
                    }
                }, {
                    key: 'off',
                    value: function off(eventName, callback) {
                        this.eventBus.off(eventName, callback);
                    }
                }, {
                    key: 'sendDeltaQueue',
                    value: function sendDeltaQueue() {
                        var doc = this.$doc;
                        var queue = this.deltaQueue;
                        if (!queue) return;
                        this.deltaQueue = void 0;
                        if (queue.length > 20 && queue.length > doc.getLength() >> 1) {
                            this.call("setValue", [doc.getValue()]);
                        } else {
                            this.emit("change", { data: queue });
                        }
                    }
                }, {
                    key: '$workerBlob',
                    value: function $workerBlob(workerUrl) {
                        var script = "importScripts('" + qualifyURL(workerUrl) + "');";
                        try {
                            return new Blob([script], { "type": "application/javascript" });
                        } catch (e) {
                            var BlobBuilder = window['BlobBuilder'] || window['WebKitBlobBuilder'] || window['MozBlobBuilder'];
                            var blobBuilder = new BlobBuilder();
                            blobBuilder.append(script);
                            return blobBuilder.getBlob("application/javascript");
                        }
                    }
                }]);

                return WorkerClient;
            })();

            _export('default', WorkerClient);
        }
    };
});
System.register("ace.js", ["npm:babel-runtime@5.8.34/core-js/object/define-properties", "src/Editor.js", "src/Document.js", "src/EditSession.js", "src/Range.js", "src/UndoManager.js", "src/VirtualRenderer.js", "src/mode/CssMode.js", "src/mode/HtmlMode.js", "src/mode/JavaScriptMode.js", "src/mode/TextMode.js", "src/mode/TypeScriptMode.js", "src/worker/WorkerClient.js"], function (_export) {
    var _Object$defineProperties, Editor, Document, EditSession, Range, UndoManager, VirtualRenderer, CssMode, HtmlMode, JavaScriptMode, TextMode, TypeScriptMode, WorkerClient, ace;

    return {
        setters: [function (_npmBabelRuntime5834CoreJsObjectDefineProperties) {
            _Object$defineProperties = _npmBabelRuntime5834CoreJsObjectDefineProperties["default"];
        }, function (_srcEditorJs) {
            Editor = _srcEditorJs["default"];
        }, function (_srcDocumentJs) {
            Document = _srcDocumentJs["default"];
        }, function (_srcEditSessionJs) {
            EditSession = _srcEditSessionJs["default"];
        }, function (_srcRangeJs) {
            Range = _srcRangeJs["default"];
        }, function (_srcUndoManagerJs) {
            UndoManager = _srcUndoManagerJs["default"];
        }, function (_srcVirtualRendererJs) {
            VirtualRenderer = _srcVirtualRendererJs["default"];
        }, function (_srcModeCssModeJs) {
            CssMode = _srcModeCssModeJs["default"];
        }, function (_srcModeHtmlModeJs) {
            HtmlMode = _srcModeHtmlModeJs["default"];
        }, function (_srcModeJavaScriptModeJs) {
            JavaScriptMode = _srcModeJavaScriptModeJs["default"];
        }, function (_srcModeTextModeJs) {
            TextMode = _srcModeTextModeJs["default"];
        }, function (_srcModeTypeScriptModeJs) {
            TypeScriptMode = _srcModeTypeScriptModeJs["default"];
        }, function (_srcWorkerWorkerClientJs) {
            WorkerClient = _srcWorkerWorkerClientJs["default"];
        }],
        execute: function () {
            "use strict";

            ace = _Object$defineProperties({}, {
                Document: {
                    get: function get() {
                        return Document;
                    },
                    configurable: true,
                    enumerable: true
                },
                EditSession: {
                    get: function get() {
                        return EditSession;
                    },
                    configurable: true,
                    enumerable: true
                },
                Editor: {
                    get: function get() {
                        return Editor;
                    },
                    configurable: true,
                    enumerable: true
                },
                Range: {
                    get: function get() {
                        return Range;
                    },
                    configurable: true,
                    enumerable: true
                },
                UndoManager: {
                    get: function get() {
                        return UndoManager;
                    },
                    configurable: true,
                    enumerable: true
                },
                VirtualRenderer: {
                    get: function get() {
                        return VirtualRenderer;
                    },
                    configurable: true,
                    enumerable: true
                },
                WorkerClient: {
                    get: function get() {
                        return WorkerClient;
                    },
                    configurable: true,
                    enumerable: true
                },
                CssMode: {
                    get: function get() {
                        return CssMode;
                    },
                    configurable: true,
                    enumerable: true
                },
                HtmlMode: {
                    get: function get() {
                        return HtmlMode;
                    },
                    configurable: true,
                    enumerable: true
                },
                TextMode: {
                    get: function get() {
                        return TextMode;
                    },
                    configurable: true,
                    enumerable: true
                },
                JavaScriptMode: {
                    get: function get() {
                        return JavaScriptMode;
                    },
                    configurable: true,
                    enumerable: true
                },
                TypeScriptMode: {
                    get: function get() {
                        return TypeScriptMode;
                    },
                    configurable: true,
                    enumerable: true
                }
            });

            _export("default", ace);
        }
    };
});
//# sourceMappingURL=ace.js.map